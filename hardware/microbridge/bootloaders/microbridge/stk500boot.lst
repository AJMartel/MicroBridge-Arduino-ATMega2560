   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB21:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  ****  Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****  Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  ****  Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  ****  File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  ****  Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  ****  Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  ****  License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  ****  Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  ****  Date:      17 October 2007
  12:stk500boot.c  ****  Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte r
  13:stk500boot.c  ****  Compiler:  WINAVR20060421
  14:stk500boot.c  ****  Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  ****  DESCRIPTION:
  17:stk500boot.c  ****  This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****  read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****  an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****  is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****  "reset" vector in Application area.
  22:stk500boot.c  ****  Size fits into a 1024 word bootloader section
  23:stk500boot.c  ****  when compiled with avr-gcc 4.1
  24:stk500boot.c  ****  (direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  ****  USAGE:
  27:stk500boot.c  ****  - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****  - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****  - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****  - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****  for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****  - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****  - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****  - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****  - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****  - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****  - AVRISP will detect the bootloader
  38:stk500boot.c  ****  - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  ****  Note:
  41:stk500boot.c  ****  Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****  is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****  Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  ****  AVRdude:
  46:stk500boot.c  ****  Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  ****  Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  ****  Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  ****  NOTES:
  51:stk500boot.c  ****  Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****  Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  ****  LICENSE:
  55:stk500boot.c  ****  Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****  This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****  it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****  the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****  any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****  This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****  but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****  GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  ****  *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //************************************************************************
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** #include <string.h>
 115:stk500boot.c  **** #include "pff.h"
 116:stk500boot.c  **** 
 117:stk500boot.c  **** void flash_erase(DWORD); /* Erase a flash page (asmfunc.S) */
 118:stk500boot.c  **** void flash_write(DWORD, const BYTE*); /* Program a flash page (asmfunc.S) */
 119:stk500boot.c  **** 
 120:stk500boot.c  **** #define BLINK_LED_WHILE_WAITING
 121:stk500boot.c  **** //#define _DEBUG_WITH_LEDS_
 122:stk500boot.c  **** //#define _DEBUG_SERIAL_
 123:stk500boot.c  **** 
 124:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 125:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 126:stk500boot.c  **** #undef		ENABLE_MONITOR
 127:stk500boot.c  **** #define		ENABLE_MONITOR
 128:stk500boot.c  **** #endif
 129:stk500boot.c  **** 
 130:stk500boot.c  **** #ifndef EEWE
 131:stk500boot.c  **** #define EEWE    1
 132:stk500boot.c  **** #endif
 133:stk500boot.c  **** #ifndef EEMWE
 134:stk500boot.c  **** #define EEMWE   2
 135:stk500boot.c  **** #endif
 136:stk500boot.c  **** 
 137:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 138:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 139:stk500boot.c  **** 
 140:stk500boot.c  **** /*
 141:stk500boot.c  ****  * Uncomment the following lines to save code space
 142:stk500boot.c  ****  */
 143:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 144:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 145:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 146:stk500boot.c  **** //
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 149:stk500boot.c  **** //*	indicates that bootloader is active
 150:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 151:stk500boot.c  **** //************************************************************************
 152:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 153:stk500boot.c  **** 
 154:stk500boot.c  **** 
 155:stk500boot.c  **** #define SPI_DDRA DDRA
 156:stk500boot.c  **** #define SPI_PORTA PORTA
 157:stk500boot.c  **** #define SPI_DDRB DDRB
 158:stk500boot.c  **** #define SPI_PORTB PORTB
 159:stk500boot.c  **** 
 160:stk500boot.c  **** #define SCK PINB1 //Pin 52
 161:stk500boot.c  **** #define MISO PINB3 //Pin 50
 162:stk500boot.c  **** #define MOSI PINB2 //Pin 51
 163:stk500boot.c  **** #define SS PINB4 //Pin 22
 164:stk500boot.c  **** #define SS_MASTER PINB0 //Pin 53
 165:stk500boot.c  **** #define LED1 PINB5
 166:stk500boot.c  **** #define LED2 PINB6
 167:stk500boot.c  **** #define LED3 PINB7
 168:stk500boot.c  **** 		
 169:stk500boot.c  **** 
 170:stk500boot.c  **** #define LED1_LOW() SPI_PORTB &= ~(_BV(LED1))
 171:stk500boot.c  **** #define LED1_HIGH() SPI_PORTB |= _BV(LED1)
 172:stk500boot.c  **** #define LED2_LOW() SPI_PORTB &= ~(_BV(LED2))
 173:stk500boot.c  **** #define LED2_HIGH() SPI_PORTB |= _BV(LED2)
 174:stk500boot.c  **** #define LED3_LOW() SPI_PORTB &= ~(_BV(LED3))
 175:stk500boot.c  **** #define LED3_HIGH() SPI_PORTB |= _BV(LED3)
 176:stk500boot.c  **** 
 177:stk500boot.c  **** 
 178:stk500boot.c  **** #define SS_LOW() SPI_PORTB &= ~(_BV(SS))
 179:stk500boot.c  **** #define SS_HIGH() SPI_PORTB |= _BV(SS)
 180:stk500boot.c  **** #define SS_MASTER_LOW() SPI_PORTB &= ~_BV(SS_MASTER)
 181:stk500boot.c  **** #define SS_MASTER_HIGH() SPI_PORTB |= _BV(SS_MASTER)
 182:stk500boot.c  **** 
 183:stk500boot.c  **** /*
 184:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 185:stk500boot.c  ****  */
 186:stk500boot.c  **** #ifndef F_CPU
 187:stk500boot.c  **** #define F_CPU 16000000UL
 188:stk500boot.c  **** #endif
 189:stk500boot.c  **** 
 190:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 191:stk500boot.c  **** /*
 192:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 193:stk500boot.c  ****  */
 194:stk500boot.c  **** 
 195:stk500boot.c  **** #ifndef BAUDRATE
 196:stk500boot.c  **** #define BAUDRATE 115200
 197:stk500boot.c  **** #endif
 198:stk500boot.c  **** 
 199:stk500boot.c  **** /*
 200:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 201:stk500boot.c  ****  */
 202:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 203:stk500boot.c  **** #if defined (__AVR_ATmega32__)
 204:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 0
 205:stk500boot.c  **** #else
 206:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 1
 207:stk500boot.c  **** #endif
 208:stk500boot.c  **** #endif
 209:stk500boot.c  **** 
 210:stk500boot.c  **** /*
 211:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 212:stk500boot.c  ****  */
 213:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 214:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 215:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 216:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 217:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 218:stk500boot.c  **** 
 219:stk500boot.c  **** /*
 220:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 221:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 222:stk500boot.c  ****  */
 223:stk500boot.c  **** //#define BOOTSIZE 1024
 224:stk500boot.c  **** #if FLASHEND > 0x0F000
 225:stk500boot.c  **** #define BOOTSIZE 8192
 226:stk500boot.c  **** #else
 227:stk500boot.c  **** #define BOOTSIZE 2048
 228:stk500boot.c  **** #endif
 229:stk500boot.c  **** 
 230:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 231:stk500boot.c  **** 
 232:stk500boot.c  **** /*
 233:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 234:stk500boot.c  ****  */
 235:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 236:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9307
 237:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 238:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9403
 239:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 240:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9502
 241:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 242:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9306
 243:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 244:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9308
 245:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 246:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9404
 247:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 248:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9702
 249:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 250:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9703
 251:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 252:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9801
 253:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 254:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9802
 255:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 256:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9705
 257:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 258:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9608
 259:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 260:stk500boot.c  **** #define SIGNATURE_BYTES  0x1E9602
 261:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 262:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9405
 263:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 264:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9782
 265:stk500boot.c  **** #else
 266:stk500boot.c  **** #error "no signature definition for MCU available"
 267:stk500boot.c  **** #endif
 268:stk500boot.c  **** 
 269:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 270:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR1L
 271:stk500boot.c  **** #define	UART_STATUS_REG				UCSR1A
 272:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR1B
 273:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN1
 274:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN1
 275:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC1
 276:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC1
 277:stk500boot.c  **** #define	UART_DATA_REG				UDR1
 278:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X1
 279:stk500boot.c  **** 
 280:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 281:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 282:stk500boot.c  **** /* ATMega8 with one USART */
 283:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 284:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 285:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 286:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 287:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 288:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 289:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 290:stk500boot.c  **** #define	UART_DATA_REG				UDR
 291:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 292:stk500boot.c  **** 
 293:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 294:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 295:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 296:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 297:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 298:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 299:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 300:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 301:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 302:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 303:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 304:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 305:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 306:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 307:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 308:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 309:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 310:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 311:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 312:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 313:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 314:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 315:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 316:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 317:stk500boot.c  **** //* catch all
 318:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 319:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 320:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 321:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 322:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 323:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 324:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 325:stk500boot.c  **** #define	UART_DATA_REG				UDR
 326:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 327:stk500boot.c  **** #else
 328:stk500boot.c  **** #error "no UART definition for MCU available"
 329:stk500boot.c  **** #endif
 330:stk500boot.c  **** 
 331:stk500boot.c  **** #define SPI_MODE_MASK 0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
 332:stk500boot.c  **** #define SPI_CLOCK_MASK 0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
 333:stk500boot.c  **** #define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR
 334:stk500boot.c  **** 
 335:stk500boot.c  **** #define LSBFIRST 0
 336:stk500boot.c  **** #define MSBFIRST 1
 337:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
 338:stk500boot.c  **** 	SPDR = _data;
 339:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
 340:stk500boot.c  **** 		;
 341:stk500boot.c  **** 	return SPDR;
 342:stk500boot.c  **** }
 343:stk500boot.c  **** void setDataMode(uint8_t mode) {
 344:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
 345:stk500boot.c  **** }
 346:stk500boot.c  **** 
 347:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
 348:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
 349:stk500boot.c  **** 		SPCR |= _BV(DORD);
 350:stk500boot.c  **** 	} else {
 351:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 352:stk500boot.c  **** 	}
 353:stk500boot.c  **** }
 354:stk500boot.c  **** 
 355:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 356:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 357:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 358:stk500boot.c  **** }
 359:stk500boot.c  **** 
 360:stk500boot.c  **** /// return the STATUS register
 361:stk500boot.c  **** #define SPIFLASH_STATUSREAD       0x05
 362:stk500boot.c  **** uint8_t readStatus() {
 363:stk500boot.c  **** 	SS_LOW();
 364:stk500boot.c  **** 	SS_MASTER_HIGH();
 365:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 366:stk500boot.c  **** 	uint8_t status = transfer(0);
 367:stk500boot.c  **** 	SS_HIGH();
 368:stk500boot.c  **** 	SS_MASTER_LOW();
 369:stk500boot.c  **** 	return status;
 370:stk500boot.c  **** }
 371:stk500boot.c  **** uint8_t busy() {
 372:stk500boot.c  **** 	return readStatus() & 1;
 373:stk500boot.c  **** }
 374:stk500boot.c  **** 
 375:stk500boot.c  **** void command(uint8_t cmd) {
 376:stk500boot.c  **** 
 377:stk500boot.c  **** 	while (busy())
 378:stk500boot.c  **** 		; //wait for any write/erase to complete
 379:stk500boot.c  **** 	SS_LOW();
 380:stk500boot.c  **** 	transfer(cmd);
 381:stk500boot.c  **** }
 382:stk500boot.c  **** 
 383:stk500boot.c  **** #define SPIFLASH_ARRAYREADLOWFREQ 0x03
 384:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 385:stk500boot.c  **** 	SS_LOW();
 386:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 387:stk500boot.c  **** 	transfer(address >> 16);
 388:stk500boot.c  **** 	transfer(address >> 8);
 389:stk500boot.c  **** 	transfer(address);
 390:stk500boot.c  **** 	uint8_t result = transfer(0);
 391:stk500boot.c  **** 	SS_HIGH();
 392:stk500boot.c  **** 	return result;
 393:stk500boot.c  **** }
 394:stk500boot.c  **** 
 395:stk500boot.c  **** /*
 396:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 397:stk500boot.c  ****  */
 398:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 399:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 400:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 401:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 402:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 403:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 404:stk500boot.c  **** #else
 405:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 406:stk500boot.c  **** #endif
 407:stk500boot.c  **** 
 408:stk500boot.c  **** /*
 409:stk500boot.c  ****  * States used in the receive state machine
 410:stk500boot.c  ****  */
 411:stk500boot.c  **** #define	ST_START		0
 412:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 413:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 414:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 415:stk500boot.c  **** #define ST_GET_TOKEN	4
 416:stk500boot.c  **** #define ST_GET_DATA		5
 417:stk500boot.c  **** #define	ST_GET_CHECK	6
 418:stk500boot.c  **** #define	ST_PROCESS		7
 419:stk500boot.c  **** 
 420:stk500boot.c  **** /*
 421:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 422:stk500boot.c  ****  */
 423:stk500boot.c  **** #if defined(RAMPZ)
 424:stk500boot.c  **** typedef uint32_t address_t;
 425:stk500boot.c  **** #else
 426:stk500boot.c  **** typedef uint16_t address_t;
 427:stk500boot.c  **** #endif
 428:stk500boot.c  **** 
 429:stk500boot.c  **** /*
 430:stk500boot.c  ****  * function prototypes
 431:stk500boot.c  ****  */
 432:stk500boot.c  **** static void sendchar(char c);
 433:stk500boot.c  **** 
 434:stk500boot.c  **** // SDCARD BOOTLOADER
 435:stk500boot.c  **** 
 436:stk500boot.c  **** unsigned char Buff[SPM_PAGESIZE]; /* Page data buffer */
 437:stk500boot.c  **** 
 438:stk500boot.c  **** // SDCARD BOOTLOADER
 439:stk500boot.c  **** 
 440:stk500boot.c  **** /*
 441:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 442:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 443:stk500boot.c  ****  */
 444:stk500boot.c  **** void __jumpMain(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 445:stk500boot.c  **** #include <avr/sfr_defs.h>
 446:stk500boot.c  **** 
 447:stk500boot.c  **** //#define	SPH_REG	0x3E
 448:stk500boot.c  **** //#define	SPL_REG	0x3D
 449:stk500boot.c  **** 
 450:stk500boot.c  **** //*****************************************************************************
 451:stk500boot.c  **** void __jumpMain(void) {
 452:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 453:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 454:stk500boot.c  **** 
 455:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 456:stk500boot.c  **** 
 457:stk500boot.c  **** //*	set stack pointer to top of RAM
 458:stk500boot.c  **** 
 459:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 460:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 461:stk500boot.c  **** 
 462:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 463:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 464:stk500boot.c  **** 
 465:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 466:stk500boot.c  **** 	// GCC depends on register r1 set to 0
 467:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 468:stk500boot.c  **** 	// set SREG to 0
 469:stk500boot.c  **** 	asm volatile ( "jmp main");
 470:stk500boot.c  **** 	// jump to main()
 471:stk500boot.c  **** }
 472:stk500boot.c  **** 
 473:stk500boot.c  **** //*****************************************************************************
 474:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 475:stk500boot.c  **** 	unsigned int i;
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 477:stk500boot.c  **** 		_delay_ms(0.5);
 478:stk500boot.c  **** 	}
 479:stk500boot.c  **** }
 480:stk500boot.c  **** 
 481:stk500boot.c  **** //*****************************************************************************
 482:stk500boot.c  **** /*
 483:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 484:stk500boot.c  ****  */
 485:stk500boot.c  **** static void sendchar(char c) {
  15               		.loc 1 485 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 486:stk500boot.c  **** 	UART_DATA_REG = c; // prepare transmission
  22               		.loc 1 486 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L3:
 487:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)))
  26               		.loc 1 487 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L3
 488:stk500boot.c  **** 		; // wait until byte sent
 489:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE); // delete TXCflag
  30               		.loc 1 489 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE21:
  39               	.global	transfer
  41               	transfer:
  42               	.LFB11:
 337:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
  43               		.loc 1 337 0
  44               		.cfi_startproc
  45               	.LVL3:
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 0 */
  49               	.L__stack_usage = 0
 338:stk500boot.c  **** 	SPDR = _data;
  50               		.loc 1 338 0
  51 0018 8EBD      		out 0x2e,r24
  52               	.L7:
 339:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
  53               		.loc 1 339 0 discriminator 1
  54 001a 0DB4      		in __tmp_reg__,0x2d
  55 001c 07FE      		sbrs __tmp_reg__,7
  56 001e 00C0      		rjmp .L7
 341:stk500boot.c  **** 	return SPDR;
  57               		.loc 1 341 0
  58 0020 8EB5      		in r24,0x2e
  59               	.LVL4:
 342:stk500boot.c  **** }
  60               		.loc 1 342 0
  61 0022 0895      		ret
  62               		.cfi_endproc
  63               	.LFE11:
  65               	.global	setDataMode
  67               	setDataMode:
  68               	.LFB12:
 343:stk500boot.c  **** void setDataMode(uint8_t mode) {
  69               		.loc 1 343 0
  70               		.cfi_startproc
  71               	.LVL5:
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 0 */
  75               	.L__stack_usage = 0
 344:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
  76               		.loc 1 344 0
  77 0024 9CB5      		in r25,0x2c
  78 0026 937F      		andi r25,lo8(-13)
  79 0028 982B      		or r25,r24
  80 002a 9CBD      		out 0x2c,r25
  81 002c 0895      		ret
  82               		.cfi_endproc
  83               	.LFE12:
  85               	.global	setBitOrder
  87               	setBitOrder:
  88               	.LFB13:
 347:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
  89               		.loc 1 347 0
  90               		.cfi_startproc
  91               	.LVL6:
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
 348:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
  96               		.loc 1 348 0
  97 002e 8111      		cpse r24,__zero_reg__
  98 0030 00C0      		rjmp .L10
 349:stk500boot.c  **** 		SPCR |= _BV(DORD);
  99               		.loc 1 349 0
 100 0032 8CB5      		in r24,0x2c
 101               	.LVL7:
 102 0034 8062      		ori r24,lo8(32)
 103 0036 00C0      		rjmp .L12
 104               	.LVL8:
 105               	.L10:
 351:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 106               		.loc 1 351 0
 107 0038 8CB5      		in r24,0x2c
 108               	.LVL9:
 109 003a 8F7D      		andi r24,lo8(-33)
 110               	.L12:
 111 003c 8CBD      		out 0x2c,r24
 112 003e 0895      		ret
 113               		.cfi_endproc
 114               	.LFE13:
 116               	.global	setClockDivider
 118               	setClockDivider:
 119               	.LFB14:
 355:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 120               		.loc 1 355 0
 121               		.cfi_startproc
 122               	.LVL10:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 0 */
 126               	.L__stack_usage = 0
 356:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 127               		.loc 1 356 0
 128 0040 2CB5      		in r18,0x2c
 129 0042 982F      		mov r25,r24
 130 0044 9370      		andi r25,lo8(3)
 131 0046 2C7F      		andi r18,lo8(-4)
 132 0048 922B      		or r25,r18
 133 004a 9CBD      		out 0x2c,r25
 357:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 134               		.loc 1 357 0
 135 004c 9DB5      		in r25,0x2d
 136 004e 82FB      		bst r24,2
 137 0050 8827      		clr r24
 138 0052 80F9      		bld r24,0
 139               	.LVL11:
 140 0054 9E7F      		andi r25,lo8(-2)
 141 0056 892B      		or r24,r25
 142 0058 8DBD      		out 0x2d,r24
 143 005a 0895      		ret
 144               		.cfi_endproc
 145               	.LFE14:
 147               	.global	readStatus
 149               	readStatus:
 150               	.LFB15:
 362:stk500boot.c  **** uint8_t readStatus() {
 151               		.loc 1 362 0
 152               		.cfi_startproc
 153               	/* prologue: function */
 154               	/* frame size = 0 */
 155               	/* stack size = 0 */
 156               	.L__stack_usage = 0
 363:stk500boot.c  **** 	SS_LOW();
 157               		.loc 1 363 0
 158 005c 2C98      		cbi 0x5,4
 364:stk500boot.c  **** 	SS_MASTER_HIGH();
 159               		.loc 1 364 0
 160 005e 289A      		sbi 0x5,0
 365:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 161               		.loc 1 365 0
 162 0060 85E0      		ldi r24,lo8(5)
 163 0062 0E94 0000 		call transfer
 164               	.LVL12:
 366:stk500boot.c  **** 	uint8_t status = transfer(0);
 165               		.loc 1 366 0
 166 0066 80E0      		ldi r24,0
 167 0068 0E94 0000 		call transfer
 168               	.LVL13:
 367:stk500boot.c  **** 	SS_HIGH();
 169               		.loc 1 367 0
 170 006c 2C9A      		sbi 0x5,4
 368:stk500boot.c  **** 	SS_MASTER_LOW();
 171               		.loc 1 368 0
 172 006e 2898      		cbi 0x5,0
 370:stk500boot.c  **** }
 173               		.loc 1 370 0
 174 0070 0895      		ret
 175               		.cfi_endproc
 176               	.LFE15:
 178               	.global	busy
 180               	busy:
 181               	.LFB16:
 371:stk500boot.c  **** uint8_t busy() {
 182               		.loc 1 371 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 372:stk500boot.c  **** 	return readStatus() & 1;
 188               		.loc 1 372 0
 189 0072 0E94 0000 		call readStatus
 190               	.LVL14:
 373:stk500boot.c  **** }
 191               		.loc 1 373 0
 192 0076 8170      		andi r24,lo8(1)
 193 0078 0895      		ret
 194               		.cfi_endproc
 195               	.LFE16:
 197               	.global	command
 199               	command:
 200               	.LFB17:
 375:stk500boot.c  **** void command(uint8_t cmd) {
 201               		.loc 1 375 0
 202               		.cfi_startproc
 203               	.LVL15:
 204 007a CF93      		push r28
 205               	.LCFI0:
 206               		.cfi_def_cfa_offset 4
 207               		.cfi_offset 28, -3
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 1 */
 211               	.L__stack_usage = 1
 212 007c C82F      		mov r28,r24
 213               	.LVL16:
 214               	.L18:
 377:stk500boot.c  **** 	while (busy())
 215               		.loc 1 377 0 discriminator 1
 216 007e 0E94 0000 		call busy
 217               	.LVL17:
 218 0082 8111      		cpse r24,__zero_reg__
 219 0084 00C0      		rjmp .L18
 379:stk500boot.c  **** 	SS_LOW();
 220               		.loc 1 379 0
 221 0086 2C98      		cbi 0x5,4
 380:stk500boot.c  **** 	transfer(cmd);
 222               		.loc 1 380 0
 223 0088 8C2F      		mov r24,r28
 224               	/* epilogue start */
 381:stk500boot.c  **** }
 225               		.loc 1 381 0
 226 008a CF91      		pop r28
 227               	.LVL18:
 380:stk500boot.c  **** 	transfer(cmd);
 228               		.loc 1 380 0
 229 008c 0C94 0000 		jmp transfer
 230               	.LVL19:
 231               		.cfi_endproc
 232               	.LFE17:
 234               	.global	spiReadReg
 236               	spiReadReg:
 237               	.LFB18:
 384:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 238               		.loc 1 384 0
 239               		.cfi_startproc
 240               	.LVL20:
 241 0090 1F93      		push r17
 242               	.LCFI1:
 243               		.cfi_def_cfa_offset 4
 244               		.cfi_offset 17, -3
 245 0092 CF93      		push r28
 246               	.LCFI2:
 247               		.cfi_def_cfa_offset 5
 248               		.cfi_offset 28, -4
 249 0094 DF93      		push r29
 250               	.LCFI3:
 251               		.cfi_def_cfa_offset 6
 252               		.cfi_offset 29, -5
 253 0096 1F92      		push __zero_reg__
 254 0098 1F92      		push __zero_reg__
 255               	.LCFI4:
 256               		.cfi_def_cfa_offset 8
 257 009a CDB7      		in r28,__SP_L__
 258 009c DEB7      		in r29,__SP_H__
 259               	.LCFI5:
 260               		.cfi_def_cfa_register 28
 261               	/* prologue: function */
 262               	/* frame size = 2 */
 263               	/* stack size = 5 */
 264               	.L__stack_usage = 5
 265 009e 182F      		mov r17,r24
 385:stk500boot.c  **** 	SS_LOW();
 266               		.loc 1 385 0
 267 00a0 2C98      		cbi 0x5,4
 386:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 268               		.loc 1 386 0
 269 00a2 83E0      		ldi r24,lo8(3)
 270 00a4 6A83      		std Y+2,r22
 271 00a6 7983      		std Y+1,r23
 272 00a8 0E94 0000 		call command
 273               	.LVL21:
 387:stk500boot.c  **** 	transfer(address >> 16);
 274               		.loc 1 387 0
 275 00ac 812F      		mov r24,r17
 276 00ae 0E94 0000 		call transfer
 277               	.LVL22:
 388:stk500boot.c  **** 	transfer(address >> 8);
 278               		.loc 1 388 0
 279 00b2 7981      		ldd r23,Y+1
 280 00b4 872F      		mov r24,r23
 281 00b6 0E94 0000 		call transfer
 282               	.LVL23:
 389:stk500boot.c  **** 	transfer(address);
 283               		.loc 1 389 0
 284 00ba 6A81      		ldd r22,Y+2
 285 00bc 862F      		mov r24,r22
 286 00be 0E94 0000 		call transfer
 287               	.LVL24:
 390:stk500boot.c  **** 	uint8_t result = transfer(0);
 288               		.loc 1 390 0
 289 00c2 80E0      		ldi r24,0
 290 00c4 0E94 0000 		call transfer
 291               	.LVL25:
 391:stk500boot.c  **** 	SS_HIGH();
 292               		.loc 1 391 0
 293 00c8 2C9A      		sbi 0x5,4
 294               	/* epilogue start */
 393:stk500boot.c  **** }
 295               		.loc 1 393 0
 296 00ca 0F90      		pop __tmp_reg__
 297 00cc 0F90      		pop __tmp_reg__
 298 00ce DF91      		pop r29
 299 00d0 CF91      		pop r28
 300 00d2 1F91      		pop r17
 301 00d4 0895      		ret
 302               		.cfi_endproc
 303               	.LFE18:
 305               		.section	.init9,"ax",@progbits
 306               	.global	__jumpMain
 308               	__jumpMain:
 309               	.LFB19:
 451:stk500boot.c  **** void __jumpMain(void) {
 310               		.loc 1 451 0
 311               		.cfi_startproc
 312               	/* prologue: naked */
 313               	/* frame size = 0 */
 314               	/* stack size = 0 */
 315               	.L__stack_usage = 0
 455:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 316               		.loc 1 455 0
 317               	/* #APP */
 318               	 ;  455 "stk500boot.c" 1
 319               		.set __stack, 8703
 320               	 ;  0 "" 2
 459:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 321               		.loc 1 459 0
 322               	 ;  459 "stk500boot.c" 1
 323 0000 01E2      		ldi	16, 33
 324               	 ;  0 "" 2
 460:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 325               		.loc 1 460 0
 326               	 ;  460 "stk500boot.c" 1
 327 0002 0EBF      		out 62,16
 328               	 ;  0 "" 2
 462:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 329               		.loc 1 462 0
 330               	 ;  462 "stk500boot.c" 1
 331 0004 0FEF      		ldi	16, 255
 332               	 ;  0 "" 2
 463:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 333               		.loc 1 463 0
 334               	 ;  463 "stk500boot.c" 1
 335 0006 0DBF      		out 61,16
 336               	 ;  0 "" 2
 465:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 337               		.loc 1 465 0
 338               	 ;  465 "stk500boot.c" 1
 339 0008 1124      		clr __zero_reg__
 340               	 ;  0 "" 2
 467:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 341               		.loc 1 467 0
 342               	 ;  467 "stk500boot.c" 1
 343 000a 1FBE      		out 63, __zero_reg__
 344               	 ;  0 "" 2
 469:stk500boot.c  **** 	asm volatile ( "jmp main");
 345               		.loc 1 469 0
 346               	 ;  469 "stk500boot.c" 1
 347 000c 0C94 0000 		jmp main
 348               	 ;  0 "" 2
 349               	/* epilogue start */
 471:stk500boot.c  **** }
 350               		.loc 1 471 0
 351               	/* #NOAPP */
 352               		.cfi_endproc
 353               	.LFE19:
 355               		.text
 356               	.global	delay_ms
 358               	delay_ms:
 359               	.LFB20:
 474:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 360               		.loc 1 474 0
 361               		.cfi_startproc
 362               	.LVL26:
 363               	/* prologue: function */
 364               	/* frame size = 0 */
 365               	/* stack size = 0 */
 366               	.L__stack_usage = 0
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 367               		.loc 1 476 0
 368 00d6 20E0      		ldi r18,0
 369 00d8 30E0      		ldi r19,0
 370               	.LVL27:
 371               	.L22:
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 372               		.loc 1 476 0 is_stmt 0 discriminator 1
 373 00da 2817      		cp r18,r24
 374 00dc 3907      		cpc r19,r25
 375 00de 01F0      		breq .L24
 376               	.LVL28:
 377               	.LBB28:
 378               	.LBB29:
 379               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 380               		.loc 2 163 0 is_stmt 1
 381 00e0 EFEC      		ldi r30,lo8(1999)
 382 00e2 F7E0      		ldi r31,hi8(1999)
 383 00e4 3197      		1: sbiw r30,1
 384 00e6 01F4      		brne 1b
 385 00e8 00C0      		rjmp .
 386 00ea 0000      		nop
 387               	.LBE29:
 388               	.LBE28:
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 389               		.loc 1 476 0
 390 00ec 2F5F      		subi r18,-1
 391 00ee 3F4F      		sbci r19,-1
 392               	.LVL29:
 393 00f0 00C0      		rjmp .L22
 394               	.LVL30:
 395               	.L24:
 396               	/* epilogue start */
 479:stk500boot.c  **** }
 397               		.loc 1 479 0
 398 00f2 0895      		ret
 399               		.cfi_endproc
 400               	.LFE20:
 402               	.global	dec_hex
 404               	dec_hex:
 405               	.LFB24:
 490:stk500boot.c  **** }
 491:stk500boot.c  **** 
 492:stk500boot.c  **** //************************************************************************
 493:stk500boot.c  **** static int Serial_Available(void) {
 494:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 495:stk500boot.c  **** }
 496:stk500boot.c  **** 
 497:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 498:stk500boot.c  **** //*****************************************************************************
 499:stk500boot.c  **** static unsigned char recchar_timeout(void) {
 500:stk500boot.c  **** 	uint32_t count = 0;
 501:stk500boot.c  **** 
 502:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 503:stk500boot.c  **** 		// wait for data
 504:stk500boot.c  **** 		count++;
 505:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 506:stk500boot.c  **** 			unsigned int data;
 507:stk500boot.c  **** #if (FLASHEND > 0x10000)
 508:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 509:stk500boot.c  **** #else
 510:stk500boot.c  **** 			data = pgm_read_word_near(0); //*	get the first word of the user program
 511:stk500boot.c  **** #endif
 512:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 513:stk500boot.c  **** 					{
 514:stk500boot.c  **** 				asm volatile(
 515:stk500boot.c  **** 						"clr	r30		\n\t"
 516:stk500boot.c  **** 						"clr	r31		\n\t"
 517:stk500boot.c  **** 						"ijmp	\n\t"
 518:stk500boot.c  **** 				);
 519:stk500boot.c  **** 			}
 520:stk500boot.c  **** 			count = 0;
 521:stk500boot.c  **** 		}
 522:stk500boot.c  **** 	}
 523:stk500boot.c  **** 	return UART_DATA_REG;
 524:stk500boot.c  **** }
 525:stk500boot.c  **** 
 526:stk500boot.c  **** 
 527:stk500boot.c  **** void dec_hex(long int num)   // Function Definition
 528:stk500boot.c  **** {
 406               		.loc 1 528 0
 407               		.cfi_startproc
 408               	.LVL31:
 409 00f4 CF92      		push r12
 410               	.LCFI6:
 411               		.cfi_def_cfa_offset 4
 412               		.cfi_offset 12, -3
 413 00f6 DF92      		push r13
 414               	.LCFI7:
 415               		.cfi_def_cfa_offset 5
 416               		.cfi_offset 13, -4
 417 00f8 EF92      		push r14
 418               	.LCFI8:
 419               		.cfi_def_cfa_offset 6
 420               		.cfi_offset 14, -5
 421 00fa FF92      		push r15
 422               	.LCFI9:
 423               		.cfi_def_cfa_offset 7
 424               		.cfi_offset 15, -6
 425 00fc 0F93      		push r16
 426               	.LCFI10:
 427               		.cfi_def_cfa_offset 8
 428               		.cfi_offset 16, -7
 429 00fe 1F93      		push r17
 430               	.LCFI11:
 431               		.cfi_def_cfa_offset 9
 432               		.cfi_offset 17, -8
 433 0100 CF93      		push r28
 434               	.LCFI12:
 435               		.cfi_def_cfa_offset 10
 436               		.cfi_offset 28, -9
 437 0102 DF93      		push r29
 438               	.LCFI13:
 439               		.cfi_def_cfa_offset 11
 440               		.cfi_offset 29, -10
 441 0104 CDB7      		in r28,__SP_L__
 442 0106 DEB7      		in r29,__SP_H__
 443               	.LCFI14:
 444               		.cfi_def_cfa_register 28
 445 0108 C85C      		subi r28,-56
 446 010a D109      		sbc r29,__zero_reg__
 447               	.LCFI15:
 448               		.cfi_def_cfa_offset 211
 449 010c 0FB6      		in __tmp_reg__,__SREG__
 450 010e F894      		cli
 451 0110 DEBF      		out __SP_H__,r29
 452 0112 0FBE      		out __SREG__,__tmp_reg__
 453 0114 CDBF      		out __SP_L__,r28
 454               	/* prologue: function */
 455               	/* frame size = 200 */
 456               	/* stack size = 208 */
 457               	.L__stack_usage = 208
 458 0116 6B01      		movw r12,r22
 459 0118 7C01      		movw r14,r24
 460               	.LVL32:
 529:stk500boot.c  **** long int rem[50],i=0,length=0;
 530:stk500boot.c  **** if(num == 0){
 461               		.loc 1 530 0
 462 011a 6115      		cp r22,__zero_reg__
 463 011c 7105      		cpc r23,__zero_reg__
 464 011e 8105      		cpc r24,__zero_reg__
 465 0120 9105      		cpc r25,__zero_reg__
 466 0122 01F4      		brne .L26
 531:stk500boot.c  **** 	sendchar('0');
 467               		.loc 1 531 0
 468 0124 80E3      		ldi r24,lo8(48)
 469 0126 0E94 0000 		call sendchar
 470               	.LVL33:
 532:stk500boot.c  **** 	sendchar('0');
 471               		.loc 1 532 0
 472 012a 80E3      		ldi r24,lo8(48)
 473 012c 0E94 0000 		call sendchar
 474               	.LVL34:
 475               	.L26:
 476 0130 FE01      		movw r30,r28
 477 0132 3196      		adiw r30,1
 528:stk500boot.c  **** {
 478               		.loc 1 528 0 discriminator 1
 479 0134 80E0      		ldi r24,0
 480 0136 90E0      		ldi r25,0
 481 0138 DC01      		movw r26,r24
 482 013a 8F01      		movw r16,r30
 483               	.LVL35:
 484               	.L27:
 533:stk500boot.c  **** }
 534:stk500boot.c  **** while(num>0)
 485               		.loc 1 534 0 discriminator 1
 486 013c 1C14      		cp __zero_reg__,r12
 487 013e 1D04      		cpc __zero_reg__,r13
 488 0140 1E04      		cpc __zero_reg__,r14
 489 0142 1F04      		cpc __zero_reg__,r15
 490 0144 04F4      		brge .L55
 535:stk500boot.c  ****    {
 536:stk500boot.c  ****       rem[i]=num%16;
 491               		.loc 1 536 0
 492 0146 B701      		movw r22,r14
 493 0148 A601      		movw r20,r12
 494 014a 4F70      		andi r20,15
 495 014c 5527      		clr r21
 496 014e 6627      		clr r22
 497 0150 7727      		clr r23
 498 0152 4193      		st Z+,r20
 499 0154 5193      		st Z+,r21
 500 0156 6193      		st Z+,r22
 501 0158 7193      		st Z+,r23
 537:stk500boot.c  ****       num=num/16;
 502               		.loc 1 537 0
 503 015a 24E0      		ldi r18,4
 504               		1:
 505 015c F594      		asr r15
 506 015e E794      		ror r14
 507 0160 D794      		ror r13
 508 0162 C794      		ror r12
 509 0164 2A95      		dec r18
 510 0166 01F4      		brne 1b
 511               	.LVL36:
 538:stk500boot.c  ****       i++;
 512               		.loc 1 538 0
 513 0168 0196      		adiw r24,1
 514 016a A11D      		adc r26,__zero_reg__
 515 016c B11D      		adc r27,__zero_reg__
 516               	.LVL37:
 517 016e 00C0      		rjmp .L27
 518               	.L55:
 539:stk500boot.c  ****       length++;
 540:stk500boot.c  ****    }
 541:stk500boot.c  **** 
 542:stk500boot.c  **** for(i=length-1;i>=0;i--)
 519               		.loc 1 542 0
 520 0170 6C01      		movw r12,r24
 521 0172 7D01      		movw r14,r26
 522               	.LVL38:
 523 0174 21E0      		ldi r18,1
 524 0176 C21A      		sub r12,r18
 525 0178 D108      		sbc r13,__zero_reg__
 526 017a E108      		sbc r14,__zero_reg__
 527 017c F108      		sbc r15,__zero_reg__
 528               	.LVL39:
 529               	.L29:
 530               		.loc 1 542 0 is_stmt 0 discriminator 1
 531 017e 2FEF      		ldi r18,-1
 532 0180 C216      		cp r12,r18
 533 0182 D206      		cpc r13,r18
 534 0184 E206      		cpc r14,r18
 535 0186 F206      		cpc r15,r18
 536 0188 01F4      		brne .+2
 537 018a 00C0      		rjmp .L56
 538 018c F601      		movw r30,r12
 539 018e EE0F      		lsl r30
 540 0190 FF1F      		rol r31
 541 0192 EE0F      		lsl r30
 542 0194 FF1F      		rol r31
 543 0196 E00F      		add r30,r16
 544 0198 F11F      		adc r31,r17
 543:stk500boot.c  ****   {
 544:stk500boot.c  ****     switch(rem[i])
 545               		.loc 1 544 0 is_stmt 1
 546 019a 8081      		ld r24,Z
 547 019c 9181      		ldd r25,Z+1
 548 019e A281      		ldd r26,Z+2
 549 01a0 B381      		ldd r27,Z+3
 550 01a2 8730      		cpi r24,7
 551 01a4 9105      		cpc r25,__zero_reg__
 552 01a6 A105      		cpc r26,__zero_reg__
 553 01a8 B105      		cpc r27,__zero_reg__
 554 01aa 01F4      		brne .+2
 555 01ac 00C0      		rjmp .L31
 556 01ae 04F4      		brge .L32
 557 01b0 8330      		cpi r24,3
 558 01b2 9105      		cpc r25,__zero_reg__
 559 01b4 A105      		cpc r26,__zero_reg__
 560 01b6 B105      		cpc r27,__zero_reg__
 561 01b8 01F0      		breq .L33
 562 01ba 04F4      		brge .L34
 563 01bc 8130      		cpi r24,1
 564 01be 9105      		cpc r25,__zero_reg__
 565 01c0 A105      		cpc r26,__zero_reg__
 566 01c2 B105      		cpc r27,__zero_reg__
 567 01c4 01F0      		breq .L35
 568 01c6 04F4      		brge .L36
 569 01c8 892B      		or r24,r25
 570 01ca 8A2B      		or r24,r26
 571 01cc 8B2B      		or r24,r27
 572 01ce 01F0      		breq .+2
 573 01d0 00C0      		rjmp .L30
 545:stk500boot.c  ****     {
 546:stk500boot.c  ****     case 0:
 547:stk500boot.c  ****         sendchar('0');
 574               		.loc 1 547 0
 575 01d2 80E3      		ldi r24,lo8(48)
 576 01d4 00C0      		rjmp .L54
 577               	.L34:
 544:stk500boot.c  ****     switch(rem[i])
 578               		.loc 1 544 0
 579 01d6 8530      		cpi r24,5
 580 01d8 9105      		cpc r25,__zero_reg__
 581 01da A105      		cpc r26,__zero_reg__
 582 01dc B105      		cpc r27,__zero_reg__
 583 01de 01F0      		breq .L38
 584 01e0 04F4      		brge .L57
 548:stk500boot.c  ****         break;
 549:stk500boot.c  ****     case 1:
 550:stk500boot.c  ****         sendchar('1');
 551:stk500boot.c  ****         break;
 552:stk500boot.c  ****     case 2:
 553:stk500boot.c  ****         sendchar('2');
 554:stk500boot.c  ****         break;
 555:stk500boot.c  ****     case 3:
 556:stk500boot.c  ****         sendchar('3');
 557:stk500boot.c  ****         break;
 558:stk500boot.c  ****     case 4:
 559:stk500boot.c  ****         sendchar('4');
 585               		.loc 1 559 0
 586 01e2 84E3      		ldi r24,lo8(52)
 587 01e4 00C0      		rjmp .L54
 588               	.L32:
 544:stk500boot.c  ****     switch(rem[i])
 589               		.loc 1 544 0
 590 01e6 8B30      		cpi r24,11
 591 01e8 9105      		cpc r25,__zero_reg__
 592 01ea A105      		cpc r26,__zero_reg__
 593 01ec B105      		cpc r27,__zero_reg__
 594 01ee 01F0      		breq .L41
 595 01f0 04F4      		brge .L42
 596 01f2 8930      		cpi r24,9
 597 01f4 9105      		cpc r25,__zero_reg__
 598 01f6 A105      		cpc r26,__zero_reg__
 599 01f8 B105      		cpc r27,__zero_reg__
 600 01fa 01F0      		breq .L43
 601 01fc 04F4      		brge .L58
 560:stk500boot.c  ****         break;
 561:stk500boot.c  ****     case 5:
 562:stk500boot.c  ****         sendchar('5');
 563:stk500boot.c  ****         break;
 564:stk500boot.c  ****     case 6:
 565:stk500boot.c  ****         sendchar('6');
 566:stk500boot.c  ****         break;
 567:stk500boot.c  ****     case 7:
 568:stk500boot.c  ****         sendchar('7');
 569:stk500boot.c  ****         break;
 570:stk500boot.c  ****     case 8:
 571:stk500boot.c  ****         sendchar('8');
 602               		.loc 1 571 0
 603 01fe 88E3      		ldi r24,lo8(56)
 604 0200 00C0      		rjmp .L54
 605               	.L42:
 544:stk500boot.c  ****     switch(rem[i])
 606               		.loc 1 544 0
 607 0202 8D30      		cpi r24,13
 608 0204 9105      		cpc r25,__zero_reg__
 609 0206 A105      		cpc r26,__zero_reg__
 610 0208 B105      		cpc r27,__zero_reg__
 611 020a 01F0      		breq .L46
 612 020c 04F0      		brlt .L47
 613 020e 8E30      		cpi r24,14
 614 0210 9105      		cpc r25,__zero_reg__
 615 0212 A105      		cpc r26,__zero_reg__
 616 0214 B105      		cpc r27,__zero_reg__
 617 0216 01F0      		breq .L48
 618 0218 0F97      		sbiw r24,15
 619 021a A105      		cpc r26,__zero_reg__
 620 021c B105      		cpc r27,__zero_reg__
 621 021e 01F4      		brne .L30
 572:stk500boot.c  ****         break;
 573:stk500boot.c  ****     case 9:
 574:stk500boot.c  ****         sendchar('9');
 575:stk500boot.c  ****         break;
 576:stk500boot.c  ****       case 10:
 577:stk500boot.c  ****           sendchar('A');
 578:stk500boot.c  ****           break;
 579:stk500boot.c  ****       case 11:
 580:stk500boot.c  ****     	  sendchar('B');
 581:stk500boot.c  ****           break;
 582:stk500boot.c  ****       case 12:
 583:stk500boot.c  ****     	  sendchar('C');
 584:stk500boot.c  ****           break;
 585:stk500boot.c  ****       case 13:
 586:stk500boot.c  ****     	  sendchar('D');
 587:stk500boot.c  ****           break;
 588:stk500boot.c  ****       case 14:
 589:stk500boot.c  ****     	  sendchar('E');
 590:stk500boot.c  ****           break;
 591:stk500boot.c  ****       case 15:
 592:stk500boot.c  ****     	  sendchar('F');
 622               		.loc 1 592 0
 623 0220 86E4      		ldi r24,lo8(70)
 624 0222 00C0      		rjmp .L54
 625               	.L35:
 550:stk500boot.c  ****         sendchar('1');
 626               		.loc 1 550 0
 627 0224 81E3      		ldi r24,lo8(49)
 628 0226 00C0      		rjmp .L54
 629               	.L36:
 553:stk500boot.c  ****         sendchar('2');
 630               		.loc 1 553 0
 631 0228 82E3      		ldi r24,lo8(50)
 632 022a 00C0      		rjmp .L54
 633               	.L33:
 556:stk500boot.c  ****         sendchar('3');
 634               		.loc 1 556 0
 635 022c 83E3      		ldi r24,lo8(51)
 636 022e 00C0      		rjmp .L54
 637               	.L38:
 562:stk500boot.c  ****         sendchar('5');
 638               		.loc 1 562 0
 639 0230 85E3      		ldi r24,lo8(53)
 640 0232 00C0      		rjmp .L54
 641               	.L57:
 565:stk500boot.c  ****         sendchar('6');
 642               		.loc 1 565 0
 643 0234 86E3      		ldi r24,lo8(54)
 644 0236 00C0      		rjmp .L54
 645               	.L31:
 568:stk500boot.c  ****         sendchar('7');
 646               		.loc 1 568 0
 647 0238 87E3      		ldi r24,lo8(55)
 648 023a 00C0      		rjmp .L54
 649               	.L43:
 574:stk500boot.c  ****         sendchar('9');
 650               		.loc 1 574 0
 651 023c 89E3      		ldi r24,lo8(57)
 652 023e 00C0      		rjmp .L54
 653               	.L58:
 577:stk500boot.c  ****           sendchar('A');
 654               		.loc 1 577 0
 655 0240 81E4      		ldi r24,lo8(65)
 656 0242 00C0      		rjmp .L54
 657               	.L41:
 580:stk500boot.c  ****     	  sendchar('B');
 658               		.loc 1 580 0
 659 0244 82E4      		ldi r24,lo8(66)
 660 0246 00C0      		rjmp .L54
 661               	.L47:
 583:stk500boot.c  ****     	  sendchar('C');
 662               		.loc 1 583 0
 663 0248 83E4      		ldi r24,lo8(67)
 664 024a 00C0      		rjmp .L54
 665               	.L46:
 586:stk500boot.c  ****     	  sendchar('D');
 666               		.loc 1 586 0
 667 024c 84E4      		ldi r24,lo8(68)
 668 024e 00C0      		rjmp .L54
 669               	.L48:
 589:stk500boot.c  ****     	  sendchar('E');
 670               		.loc 1 589 0
 671 0250 85E4      		ldi r24,lo8(69)
 672 0252 00C0      		rjmp .L54
 673               	.L30:
 593:stk500boot.c  ****           break;
 594:stk500boot.c  ****       default :
 595:stk500boot.c  ****          sendchar('X');
 674               		.loc 1 595 0
 675 0254 88E5      		ldi r24,lo8(88)
 676               	.L54:
 677 0256 0E94 0000 		call sendchar
 678               	.LVL40:
 542:stk500boot.c  **** for(i=length-1;i>=0;i--)
 679               		.loc 1 542 0
 680 025a 81E0      		ldi r24,1
 681 025c C81A      		sub r12,r24
 682 025e D108      		sbc r13,__zero_reg__
 683 0260 E108      		sbc r14,__zero_reg__
 684 0262 F108      		sbc r15,__zero_reg__
 685               	.LVL41:
 686 0264 00C0      		rjmp .L29
 687               	.L56:
 688               	/* epilogue start */
 596:stk500boot.c  ****          break;
 597:stk500boot.c  ****     }
 598:stk500boot.c  ****   }
 599:stk500boot.c  **** }
 689               		.loc 1 599 0
 690 0266 C853      		subi r28,56
 691 0268 DF4F      		sbci r29,-1
 692 026a 0FB6      		in __tmp_reg__,__SREG__
 693 026c F894      		cli
 694 026e DEBF      		out __SP_H__,r29
 695 0270 0FBE      		out __SREG__,__tmp_reg__
 696 0272 CDBF      		out __SP_L__,r28
 697 0274 DF91      		pop r29
 698 0276 CF91      		pop r28
 699 0278 1F91      		pop r17
 700 027a 0F91      		pop r16
 701 027c FF90      		pop r15
 702 027e EF90      		pop r14
 703 0280 DF90      		pop r13
 704 0282 CF90      		pop r12
 705               	.LVL42:
 706 0284 0895      		ret
 707               		.cfi_endproc
 708               	.LFE24:
 710               		.section	.text.startup,"ax",@progbits
 711               	.global	main
 713               	main:
 714               	.LFB25:
 600:stk500boot.c  **** 
 601:stk500boot.c  **** 
 602:stk500boot.c  **** //*	for watch dog timer startup
 603:stk500boot.c  **** void (*app_start)(void) = 0;
 604:stk500boot.c  **** uint8_t check = 1;
 605:stk500boot.c  **** 
 606:stk500boot.c  **** //*****************************************************************************
 607:stk500boot.c  **** int main(void) {
 715               		.loc 1 607 0
 716               		.cfi_startproc
 717 0000 CF93      		push r28
 718               	.LCFI16:
 719               		.cfi_def_cfa_offset 4
 720               		.cfi_offset 28, -3
 721 0002 DF93      		push r29
 722               	.LCFI17:
 723               		.cfi_def_cfa_offset 5
 724               		.cfi_offset 29, -4
 725 0004 CDB7      		in r28,__SP_L__
 726 0006 DEB7      		in r29,__SP_H__
 727               	.LCFI18:
 728               		.cfi_def_cfa_register 28
 729 0008 C952      		subi r28,41
 730 000a D140      		sbci r29,1
 731               	.LCFI19:
 732               		.cfi_def_cfa_offset 302
 733 000c 0FB6      		in __tmp_reg__,__SREG__
 734 000e F894      		cli
 735 0010 DEBF      		out __SP_H__,r29
 736 0012 0FBE      		out __SREG__,__tmp_reg__
 737 0014 CDBF      		out __SP_L__,r28
 738               	/* prologue: function */
 739               	/* frame size = 297 */
 740               	/* stack size = 299 */
 741               	.L__stack_usage = 299
 608:stk500boot.c  **** 
 609:stk500boot.c  **** 	setDataMode(0x00);
 742               		.loc 1 609 0
 743 0016 80E0      		ldi r24,0
 744 0018 0E94 0000 		call setDataMode
 745               	.LVL43:
 610:stk500boot.c  **** 	setBitOrder(1);
 746               		.loc 1 610 0
 747 001c 81E0      		ldi r24,lo8(1)
 748 001e 0E94 0000 		call setBitOrder
 749               	.LVL44:
 611:stk500boot.c  **** 	setClockDivider(0x04);
 750               		.loc 1 611 0
 751 0022 84E0      		ldi r24,lo8(4)
 752 0024 0E94 0000 		call setClockDivider
 753               	.LVL45:
 612:stk500boot.c  **** 
 613:stk500boot.c  **** 	SPI_PORTB = _BV(SCK) | _BV(MISO) | _BV(MOSI) | _BV(SS) | _BV(LED1) | _BV(LED2) | _BV(LED3);
 754               		.loc 1 613 0
 755 0028 8EEF      		ldi r24,lo8(-2)
 756 002a 85B9      		out 0x5,r24
 614:stk500boot.c  **** 	SPI_DDRB = _BV(SCK) | _BV(MOSI) |_BV(SS) | _BV(LED1) | _BV(LED2) | _BV(LED3);
 757               		.loc 1 614 0
 758 002c 86EF      		ldi r24,lo8(-10)
 759 002e 84B9      		out 0x4,r24
 615:stk500boot.c  **** 	
 616:stk500boot.c  **** 	LED1_LOW();
 760               		.loc 1 616 0
 761 0030 2D98      		cbi 0x5,5
 617:stk500boot.c  **** 	LED2_LOW();
 762               		.loc 1 617 0
 763 0032 2E98      		cbi 0x5,6
 618:stk500boot.c  **** 	LED3_LOW();
 764               		.loc 1 618 0
 765 0034 2F98      		cbi 0x5,7
 619:stk500boot.c  **** 	
 620:stk500boot.c  **** 	SS_HIGH();
 766               		.loc 1 620 0
 767 0036 2C9A      		sbi 0x5,4
 621:stk500boot.c  **** 	SS_MASTER_HIGH();
 768               		.loc 1 621 0
 769 0038 289A      		sbi 0x5,0
 622:stk500boot.c  **** 
 623:stk500boot.c  **** 	SPCR |= _BV(MSTR);
 770               		.loc 1 623 0
 771 003a 8CB5      		in r24,0x2c
 772 003c 8061      		ori r24,lo8(16)
 773 003e 8CBD      		out 0x2c,r24
 624:stk500boot.c  **** 	SPCR |= _BV(SPE);
 774               		.loc 1 624 0
 775 0040 8CB5      		in r24,0x2c
 776 0042 8064      		ori r24,lo8(64)
 777 0044 8CBD      		out 0x2c,r24
 778               	.LVL46:
 625:stk500boot.c  **** 
 626:stk500boot.c  **** 	address_t address = 0;
 627:stk500boot.c  **** 	address_t eraseAddress = 0;
 628:stk500boot.c  **** 	unsigned char msgParseState;
 629:stk500boot.c  **** 	unsigned int ii = 0;
 630:stk500boot.c  **** 	unsigned char checksum = 0;
 631:stk500boot.c  **** 	unsigned char seqNum = 0;
 632:stk500boot.c  **** 	unsigned int msgLength = 0;
 633:stk500boot.c  **** 	unsigned char msgBuffer[285];
 634:stk500boot.c  **** 	unsigned char c, *p;
 635:stk500boot.c  **** 	unsigned char isLeave = 0;
 636:stk500boot.c  **** 
 637:stk500boot.c  **** 	unsigned long boot_timeout;
 638:stk500boot.c  **** 	unsigned long boot_timer;
 639:stk500boot.c  **** 	unsigned int boot_state;
 640:stk500boot.c  **** #ifdef ENABLE_MONITOR
 641:stk500boot.c  **** 	unsigned int exPointCntr = 0;
 642:stk500boot.c  **** 	unsigned int rcvdCharCntr = 0;
 643:stk500boot.c  **** #endif
 644:stk500boot.c  **** 
 645:stk500boot.c  **** 	//*	some chips dont set the stack properly
 646:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 779               		.loc 1 646 0
 780               	/* #APP */
 781               	 ;  646 "stk500boot.c" 1
 782               		.set __stack, 8703
 783               	 ;  0 "" 2
 647:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 784               		.loc 1 647 0
 785               	 ;  647 "stk500boot.c" 1
 786 0046 01E2      		ldi	16, 33
 787               	 ;  0 "" 2
 648:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 788               		.loc 1 648 0
 789               	 ;  648 "stk500boot.c" 1
 790 0048 0EBF      		out 62,16
 791               	 ;  0 "" 2
 649:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 792               		.loc 1 649 0
 793               	 ;  649 "stk500boot.c" 1
 794 004a 0FEF      		ldi	16, 255
 795               	 ;  0 "" 2
 650:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 796               		.loc 1 650 0
 797               	 ;  650 "stk500boot.c" 1
 798 004c 0DBF      		out 61,16
 799               	 ;  0 "" 2
 651:stk500boot.c  **** 
 652:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 653:stk500boot.c  **** 	//************************************************************************
 654:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 655:stk500boot.c  **** 	//*	handle the watch dog timer
 656:stk500boot.c  **** 	uint8_t mcuStatusReg;
 657:stk500boot.c  **** 	mcuStatusReg = MCUSR;
 800               		.loc 1 657 0
 801               	/* #NOAPP */
 802 004e 94B7      		in r25,0x34
 803               	.LVL47:
 658:stk500boot.c  **** 
 659:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 804               		.loc 1 659 0
 805               	/* #APP */
 806               	 ;  659 "stk500boot.c" 1
 807 0050 F894      		cli
 808               	 ;  0 "" 2
 660:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 809               		.loc 1 660 0
 810               	 ;  660 "stk500boot.c" 1
 811 0052 A895      		wdr
 812               	 ;  0 "" 2
 661:stk500boot.c  **** 	MCUSR = 0;
 813               		.loc 1 661 0
 814               	/* #NOAPP */
 815 0054 14BE      		out 0x34,__zero_reg__
 662:stk500boot.c  **** 	WDTCSR |= _BV(WDCE) | _BV(WDE);
 816               		.loc 1 662 0
 817 0056 8091 6000 		lds r24,96
 818 005a 8861      		ori r24,lo8(24)
 819 005c 8093 6000 		sts 96,r24
 663:stk500boot.c  **** 	WDTCSR = 0;
 820               		.loc 1 663 0
 821 0060 1092 6000 		sts 96,__zero_reg__
 664:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 822               		.loc 1 664 0
 823               	/* #APP */
 824               	 ;  664 "stk500boot.c" 1
 825 0064 7894      		sei
 826               	 ;  0 "" 2
 665:stk500boot.c  **** 
 666:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 667:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF)) {
 827               		.loc 1 667 0
 828               	/* #NOAPP */
 829 0066 93FF      		sbrs r25,3
 830 0068 00C0      		rjmp .L60
 668:stk500boot.c  **** 		app_start();
 831               		.loc 1 668 0
 832 006a E091 0000 		lds r30,app_start
 833 006e F091 0000 		lds r31,app_start+1
 834 0072 1995      		eicall
 835               	.LVL48:
 836               	.L60:
 669:stk500boot.c  **** 	}
 670:stk500boot.c  **** 	//************************************************************************
 671:stk500boot.c  **** #endif
 672:stk500boot.c  **** 
 673:stk500boot.c  **** 	boot_timer = 0;
 674:stk500boot.c  **** 	boot_state = 0;
 675:stk500boot.c  **** 
 676:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 677:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 678:stk500boot.c  **** //	boot_timeout	=	170000;
 679:stk500boot.c  **** 	boot_timeout = 100000; //*	should be about 1 second
 680:stk500boot.c  **** #else
 681:stk500boot.c  **** 			boot_timeout = 3500000; // 7 seconds , approx 2us per step when optimize "s"
 682:stk500boot.c  **** #endif
 683:stk500boot.c  **** 	/*
 684:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 685:stk500boot.c  **** 	 */
 686:stk500boot.c  **** 
 687:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 688:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 689:stk500boot.c  **** 			//PROGLED_DDR |= (1 << PROGLED_PIN);
 690:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 691:stk500boot.c  **** //	PROGLED_PORT |= (1 << PROGLED_PIN); // active high LED ON
 692:stk500boot.c  **** 
 693:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 694:stk500boot.c  **** //	for (ii=0; ii<3; ii++)
 695:stk500boot.c  **** //	{
 696:stk500boot.c  **** //		PROGLED_PORT &= ~(1<<PROGLED_PIN); // turn LED off
 697:stk500boot.c  **** //		delay_ms(100);
 698:stk500boot.c  **** //		PROGLED_PORT |= (1<<PROGLED_PIN);// turn LED on
 699:stk500boot.c  **** //		delay_ms(100);
 700:stk500boot.c  **** //	}
 701:stk500boot.c  **** #endif
 702:stk500boot.c  **** 
 703:stk500boot.c  **** #endif
 704:stk500boot.c  **** 
 705:stk500boot.c  **** 	/*
 706:stk500boot.c  **** 	 * Init UART
 707:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 708:stk500boot.c  **** 	 */
 709:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 710:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_DOUBLE_SPEED);
 837               		.loc 1 710 0
 838 0074 8091 C000 		lds r24,192
 839 0078 8260      		ori r24,lo8(2)
 840 007a 8093 C000 		sts 192,r24
 711:stk500boot.c  **** #endif
 712:stk500boot.c  **** 	UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
 841               		.loc 1 712 0
 842 007e 80E1      		ldi r24,lo8(16)
 843 0080 8093 C400 		sts 196,r24
 713:stk500boot.c  **** 	UART_CONTROL_REG = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 844               		.loc 1 713 0
 845 0084 88E1      		ldi r24,lo8(24)
 846 0086 8093 C100 		sts 193,r24
 714:stk500boot.c  **** 
 715:stk500boot.c  **** 	asm volatile ("nop");
 847               		.loc 1 715 0
 848               	/* #APP */
 849               	 ;  715 "stk500boot.c" 1
 850 008a 0000      		nop
 851               	 ;  0 "" 2
 673:stk500boot.c  **** 	boot_timer = 0;
 852               		.loc 1 673 0
 853               	/* #NOAPP */
 854 008c 80E0      		ldi r24,0
 855 008e 90E0      		ldi r25,0
 856 0090 DC01      		movw r26,r24
 857               	.LVL49:
 858               	.L61:
 607:stk500boot.c  **** int main(void) {
 859               		.loc 1 607 0 discriminator 1
 860 0092 40E0      		ldi r20,0
 861 0094 50E0      		ldi r21,0
 862               	.LVL50:
 863               	.L68:
 864               	.LBB58:
 865               	.LBB59:
 494:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 866               		.loc 1 494 0 discriminator 1
 867 0096 2091 C000 		lds r18,192
 868               	.LBE59:
 869               	.LBE58:
 716:stk500boot.c  **** 	// wait until port has changed
 717:stk500boot.c  **** 
 718:stk500boot.c  **** //	sendchar('b');
 719:stk500boot.c  **** //    sendchar('o');
 720:stk500boot.c  **** //    sendchar('o');
 721:stk500boot.c  **** //    sendchar('t');
 722:stk500boot.c  **** //    sendchar('i');
 723:stk500boot.c  **** //    sendchar('n');
 724:stk500boot.c  **** //    sendchar('g');
 725:stk500boot.c  **** //    sendchar('.');
 726:stk500boot.c  **** //    sendchar('.');
 727:stk500boot.c  **** //    sendchar('.');
 728:stk500boot.c  **** //    sendchar(0x0d);
 729:stk500boot.c  **** //    sendchar(0x0a);
 730:stk500boot.c  **** //    delay_ms(100);
 731:stk500boot.c  **** 
 732:stk500boot.c  **** 	while (boot_state == 0) {
 733:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 870               		.loc 1 733 0 discriminator 1
 871 009a 27FF      		sbrs r18,7
 872 009c 00C0      		rjmp .L63
 873               	.L67:
 734:stk500boot.c  **** 		{
 735:stk500boot.c  **** 			_delay_ms(0.001);
 736:stk500boot.c  **** 			boot_timer++;
 737:stk500boot.c  **** 			if (boot_timer > boot_timeout) {
 738:stk500boot.c  **** 				boot_state = 1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 739:stk500boot.c  **** 			}
 740:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 741:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0) {
 742:stk500boot.c  **** 				//*	toggle the LED
 743:stk500boot.c  **** 				//PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
 744:stk500boot.c  **** 			}
 745:stk500boot.c  **** #endif
 746:stk500boot.c  **** 		}
 747:stk500boot.c  **** 		/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 748:stk500boot.c  **** 		//	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 749:stk500boot.c  **** 		// SDCARD BOOTLOADER
 750:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 874               		.loc 1 750 0
 875 009e 4F5F      		subi r20,-1
 876 00a0 5F4F      		sbci r21,-1
 877               	.LVL51:
 732:stk500boot.c  **** 	while (boot_state == 0) {
 878               		.loc 1 732 0
 879 00a2 4115      		cp r20,__zero_reg__
 880 00a4 5105      		cpc r21,__zero_reg__
 881 00a6 01F0      		breq .L61
 882 00a8 00C0      		rjmp .L198
 883               	.L63:
 733:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 884               		.loc 1 733 0 discriminator 2
 885 00aa 4115      		cp r20,__zero_reg__
 886 00ac 5105      		cpc r21,__zero_reg__
 887 00ae 01F4      		brne .L67
 888               	.LVL52:
 889               	.LBB60:
 890               	.LBB61:
 891               		.loc 2 163 0
 892 00b0 25E0      		ldi r18,lo8(5)
 893 00b2 2A95      		1: dec r18
 894 00b4 01F4      		brne 1b
 895 00b6 0000      		nop
 896               	.LBE61:
 897               	.LBE60:
 736:stk500boot.c  **** 			boot_timer++;
 898               		.loc 1 736 0
 899 00b8 0196      		adiw r24,1
 900 00ba A11D      		adc r26,__zero_reg__
 901 00bc B11D      		adc r27,__zero_reg__
 902               	.LVL53:
 737:stk500boot.c  **** 			if (boot_timer > boot_timeout) {
 903               		.loc 1 737 0
 904 00be 31E0      		ldi r19,lo8(1)
 905 00c0 20E0      		ldi r18,0
 906 00c2 813A      		cpi r24,-95
 907 00c4 46E8      		ldi r20,-122
 908 00c6 9407      		cpc r25,r20
 909 00c8 41E0      		ldi r20,1
 910 00ca A407      		cpc r26,r20
 911 00cc B105      		cpc r27,__zero_reg__
 912               	.LVL54:
 913 00ce 00F4      		brsh .L62
 914 00d0 30E0      		ldi r19,0
 915               	.L62:
 738:stk500boot.c  **** 				boot_state = 1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 916               		.loc 1 738 0
 917 00d2 432F      		mov r20,r19
 918 00d4 522F      		mov r21,r18
 919 00d6 00C0      		rjmp .L68
 920               	.LVL55:
 921               	.L198:
 751:stk500boot.c  **** 	}
 752:stk500boot.c  **** 
 753:stk500boot.c  **** 	if (boot_state == 1) {
 922               		.loc 1 753 0
 923 00d8 4130      		cpi r20,1
 924 00da 5105      		cpc r21,__zero_reg__
 925 00dc 01F0      		breq .+2
 926 00de 00C0      		rjmp .L69
 927 00e0 CE5D      		subi r28,lo8(-290)
 928 00e2 DE4F      		sbci r29,hi8(-290)
 929 00e4 1982      		std Y+1,__zero_reg__
 930 00e6 1882      		st Y,__zero_reg__
 931 00e8 C252      		subi r28,lo8(290)
 932 00ea D140      		sbci r29,hi8(290)
 933 00ec C85D      		subi r28,lo8(-296)
 934 00ee DE4F      		sbci r29,hi8(-296)
 935 00f0 1982      		std Y+1,__zero_reg__
 936 00f2 1882      		st Y,__zero_reg__
 937 00f4 C852      		subi r28,lo8(296)
 938 00f6 D140      		sbci r29,hi8(296)
 939 00f8 C05E      		subi r28,lo8(-288)
 940 00fa DE4F      		sbci r29,hi8(-288)
 941 00fc 1882      		st Y,__zero_reg__
 942 00fe C052      		subi r28,lo8(288)
 943 0100 D140      		sbci r29,hi8(288)
 944 0102 312C      		mov r3,__zero_reg__
 945 0104 C25E      		subi r28,lo8(-286)
 946 0106 DE4F      		sbci r29,hi8(-286)
 947 0108 1982      		std Y+1,__zero_reg__
 948 010a 1882      		st Y,__zero_reg__
 949 010c CE51      		subi r28,lo8(286)
 950 010e D140      		sbci r29,hi8(286)
 951 0110 C12C      		mov r12,__zero_reg__
 952 0112 D12C      		mov r13,__zero_reg__
 953 0114 7601      		movw r14,r12
 954 0116 412C      		mov r4,__zero_reg__
 955 0118 512C      		mov r5,__zero_reg__
 956 011a 3201      		movw r6,r4
 957               	.LVL56:
 958               	.L70:
 673:stk500boot.c  **** 	boot_timer = 0;
 959               		.loc 1 673 0 discriminator 1
 960 011c 20E0      		ldi r18,0
 961 011e 30E0      		ldi r19,0
 962 0120 80E0      		ldi r24,0
 963               	.LVL57:
 964               	.L137:
 754:stk500boot.c  **** 		//*	main loop
 755:stk500boot.c  **** 		while (!isLeave) {
 756:stk500boot.c  **** 			/*
 757:stk500boot.c  **** 			 * Collect received bytes to a complete message
 758:stk500boot.c  **** 			 */
 759:stk500boot.c  **** 			msgParseState = ST_START;
 760:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 761:stk500boot.c  **** 				if (boot_state == 1) {
 965               		.loc 1 761 0
 966 0122 4130      		cpi r20,1
 967 0124 5105      		cpc r21,__zero_reg__
 968 0126 01F0      		breq .L188
 969               	.L147:
 970               	.LBB62:
 971               	.LBB63:
 972               	.LBB64:
 512:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 973               		.loc 1 512 0
 974 0128 40E0      		ldi r20,0
 975 012a 50E0      		ldi r21,0
 976 012c BA01      		movw r22,r20
 977               	.L72:
 978               	.LVL58:
 979               	.LBE64:
 502:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 980               		.loc 1 502 0
 981 012e 9091 C000 		lds r25,192
 982 0132 97FD      		sbrc r25,7
 983 0134 00C0      		rjmp .L188
 504:stk500boot.c  **** 		count++;
 984               		.loc 1 504 0
 985 0136 4F5F      		subi r20,-1
 986 0138 5F4F      		sbci r21,-1
 987 013a 6F4F      		sbci r22,-1
 988 013c 7F4F      		sbci r23,-1
 989               	.LVL59:
 505:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 990               		.loc 1 505 0
 991 013e 4130      		cpi r20,1
 992 0140 92E1      		ldi r25,18
 993 0142 5907      		cpc r21,r25
 994 0144 9AE7      		ldi r25,122
 995 0146 6907      		cpc r22,r25
 996 0148 7105      		cpc r23,__zero_reg__
 997 014a 00F0      		brlo .L72
 998               	.LVL60:
 999               	.LBB66:
 1000               	.LBB65:
 508:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 1001               		.loc 1 508 0
 1002 014c 812C      		mov r8,__zero_reg__
 1003 014e 912C      		mov r9,__zero_reg__
 1004 0150 5401      		movw r10,r8
 1005               	/* #APP */
 1006               	 ;  508 "stk500boot.c" 1
 1007 0152 ABBE      		out 59, r10
 1008 0154 F401      		movw r30, r8
 1009 0156 A791      		elpm r26, Z+
 1010 0158 B691      		elpm r27, Z
 1011               		
 1012               	 ;  0 "" 2
 1013               	.LVL61:
 1014               	/* #NOAPP */
 1015               	.LBE65:
 512:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 1016               		.loc 1 512 0
 1017 015a 1196      		adiw r26,1
 1018               	.LVL62:
 1019 015c 01F0      		breq .L147
 514:stk500boot.c  **** 				asm volatile(
 1020               		.loc 1 514 0
 1021               	/* #APP */
 1022               	 ;  514 "stk500boot.c" 1
 1023 015e EE27      		clr	r30		
 1024 0160 FF27      		clr	r31		
 1025 0162 0994      		ijmp	
 1026               		
 1027               	 ;  0 "" 2
 1028               	/* #NOAPP */
 1029 0164 00C0      		rjmp .L147
 1030               	.LVL63:
 1031               	.L188:
 1032               	.LBE66:
 523:stk500boot.c  **** 	return UART_DATA_REG;
 1033               		.loc 1 523 0
 1034 0166 9091 C600 		lds r25,198
 1035               	.LVL64:
 1036               	.LBE63:
 1037               	.LBE62:
 762:stk500boot.c  **** 					boot_state = 0;
 763:stk500boot.c  **** 					c = UART_DATA_REG;
 764:stk500boot.c  **** 				} else {
 765:stk500boot.c  **** 					//	c	=	recchar();
 766:stk500boot.c  **** 					c = recchar_timeout();
 767:stk500boot.c  **** 
 768:stk500boot.c  **** 				}
 769:stk500boot.c  **** 
 770:stk500boot.c  **** #ifdef ENABLE_MONITOR
 771:stk500boot.c  **** 				rcvdCharCntr++;
 1038               		.loc 1 771 0
 1039 016a CE5D      		subi r28,lo8(-290)
 1040 016c DE4F      		sbci r29,hi8(-290)
 1041 016e 4881      		ld r20,Y
 1042 0170 5981      		ldd r21,Y+1
 1043 0172 C252      		subi r28,lo8(290)
 1044 0174 D140      		sbci r29,hi8(290)
 1045 0176 4F5F      		subi r20,-1
 1046 0178 5F4F      		sbci r21,-1
 1047 017a CE5D      		subi r28,lo8(-290)
 1048 017c DE4F      		sbci r29,hi8(-290)
 1049 017e 5983      		std Y+1,r21
 1050 0180 4883      		st Y,r20
 1051 0182 C252      		subi r28,lo8(290)
 1052 0184 D140      		sbci r29,hi8(290)
 1053               	.LVL65:
 772:stk500boot.c  **** 
 773:stk500boot.c  **** 				if ((c == '!') && (rcvdCharCntr < 10))
 1054               		.loc 1 773 0
 1055 0186 9132      		cpi r25,lo8(33)
 1056 0188 01F4      		brne .L149
 1057               		.loc 1 773 0 is_stmt 0 discriminator 1
 1058 018a 4A30      		cpi r20,10
 1059 018c 5105      		cpc r21,__zero_reg__
 1060 018e 00F4      		brsh .L149
 774:stk500boot.c  **** 				{
 775:stk500boot.c  **** 					exPointCntr++;
 1061               		.loc 1 775 0 is_stmt 1
 1062 0190 C85D      		subi r28,lo8(-296)
 1063 0192 DE4F      		sbci r29,hi8(-296)
 1064 0194 4881      		ld r20,Y
 1065 0196 5981      		ldd r21,Y+1
 1066 0198 C852      		subi r28,lo8(296)
 1067 019a D140      		sbci r29,hi8(296)
 1068               	.LVL66:
 1069 019c 4F5F      		subi r20,-1
 1070 019e 5F4F      		sbci r21,-1
 1071 01a0 C85D      		subi r28,lo8(-296)
 1072 01a2 DE4F      		sbci r29,hi8(-296)
 1073 01a4 5983      		std Y+1,r21
 1074 01a6 4883      		st Y,r20
 1075 01a8 C852      		subi r28,lo8(296)
 1076 01aa D140      		sbci r29,hi8(296)
 1077               	.LVL67:
 776:stk500boot.c  **** 					if (exPointCntr == 3)
 1078               		.loc 1 776 0
 1079 01ac 4330      		cpi r20,3
 1080 01ae 5105      		cpc r21,__zero_reg__
 1081 01b0 01F4      		brne .L76
 1082 01b2 00C0      		rjmp .L199
 1083               	.LVL68:
 1084               	.L149:
 777:stk500boot.c  **** 					{
 778:stk500boot.c  **** 						exPointCntr = 0; //	reset back to zero so we dont get in an endless loop
 779:stk500boot.c  **** 						isLeave = 1;
 780:stk500boot.c  **** 						msgParseState = 99;//*	we dont want it do anything
 781:stk500boot.c  **** 						break;
 782:stk500boot.c  **** 					}
 783:stk500boot.c  **** 				}
 784:stk500boot.c  **** 				else
 785:stk500boot.c  **** 				{
 786:stk500boot.c  **** 					exPointCntr = 0;
 1085               		.loc 1 786 0
 1086 01b4 C85D      		subi r28,lo8(-296)
 1087 01b6 DE4F      		sbci r29,hi8(-296)
 1088 01b8 1982      		std Y+1,__zero_reg__
 1089 01ba 1882      		st Y,__zero_reg__
 1090 01bc C852      		subi r28,lo8(296)
 1091 01be D140      		sbci r29,hi8(296)
 1092               	.LVL69:
 1093               	.L76:
 787:stk500boot.c  **** 				}
 788:stk500boot.c  **** #endif
 789:stk500boot.c  **** 
 790:stk500boot.c  **** 				switch (msgParseState) {
 1094               		.loc 1 790 0
 1095 01c0 8330      		cpi r24,lo8(3)
 1096 01c2 01F0      		breq .L79
 1097 01c4 00F4      		brsh .L80
 1098 01c6 8130      		cpi r24,lo8(1)
 1099 01c8 01F0      		breq .L81
 1100 01ca 00F0      		brlo .L186
 1101 01cc 00C0      		rjmp .L200
 1102               	.L80:
 1103 01ce 8530      		cpi r24,lo8(5)
 1104 01d0 01F0      		breq .L84
 1105 01d2 00F0      		brlo .L85
 1106 01d4 8630      		cpi r24,lo8(6)
 1107 01d6 01F4      		brne .+2
 1108 01d8 00C0      		rjmp .L86
 1109 01da 00C0      		rjmp .L201
 1110               	.L186:
 791:stk500boot.c  **** 				case ST_START:
 792:stk500boot.c  **** 					if (c == MESSAGE_START) {
 1111               		.loc 1 792 0
 1112 01dc 9B31      		cpi r25,lo8(27)
 1113 01de 01F4      		brne .+2
 1114 01e0 00C0      		rjmp .L202
 1115               	.LVL70:
 1116               	.L88:
 1117 01e2 40E0      		ldi r20,0
 1118 01e4 50E0      		ldi r21,0
 1119 01e6 00C0      		rjmp .L137
 1120               	.LVL71:
 1121               	.L81:
 793:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 794:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 795:stk500boot.c  **** 					}
 796:stk500boot.c  **** 					break;
 797:stk500boot.c  **** 
 798:stk500boot.c  **** 				case ST_GET_SEQ_NUM:
 799:stk500boot.c  **** #ifdef _FIX_ISSUE_505_
 800:stk500boot.c  **** 					seqNum = c;
 801:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 802:stk500boot.c  **** 					checksum ^= c;
 1122               		.loc 1 802 0
 1123 01e8 3926      		eor r3,r25
 1124               	.LVL72:
 803:stk500boot.c  **** #else
 804:stk500boot.c  **** 					if ( (c == 1) || (c == seqNum) )
 805:stk500boot.c  **** 					{
 806:stk500boot.c  **** 						seqNum = c;
 807:stk500boot.c  **** 						msgParseState = ST_MSG_SIZE_1;
 808:stk500boot.c  **** 						checksum ^= c;
 809:stk500boot.c  **** 					}
 810:stk500boot.c  **** 					else
 811:stk500boot.c  **** 					{
 812:stk500boot.c  **** 						msgParseState = ST_START;
 813:stk500boot.c  **** 					}
 814:stk500boot.c  **** #endif
 815:stk500boot.c  **** 					break;
 1125               		.loc 1 815 0
 1126 01ea C05E      		subi r28,lo8(-288)
 1127 01ec DE4F      		sbci r29,hi8(-288)
 1128 01ee 9883      		st Y,r25
 1129 01f0 C052      		subi r28,lo8(288)
 1130 01f2 D140      		sbci r29,hi8(288)
 801:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 1131               		.loc 1 801 0
 1132 01f4 82E0      		ldi r24,lo8(2)
 1133               		.loc 1 815 0
 1134 01f6 00C0      		rjmp .L88
 1135               	.LVL73:
 1136               	.L200:
 816:stk500boot.c  **** 
 817:stk500boot.c  **** 				case ST_MSG_SIZE_1:
 818:stk500boot.c  **** 					msgLength = c << 8;
 1137               		.loc 1 818 0
 1138 01f8 292F      		mov r18,r25
 1139               	.LVL74:
 1140 01fa 30E0      		ldi r19,0
 1141 01fc 322F      		mov r19,r18
 1142 01fe 2227      		clr r18
 1143               	.LVL75:
 819:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 820:stk500boot.c  **** 					checksum ^= c;
 1144               		.loc 1 820 0
 1145 0200 3926      		eor r3,r25
 1146               	.LVL76:
 819:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 1147               		.loc 1 819 0
 1148 0202 83E0      		ldi r24,lo8(3)
 821:stk500boot.c  **** 					break;
 1149               		.loc 1 821 0
 1150 0204 00C0      		rjmp .L88
 1151               	.LVL77:
 1152               	.L79:
 822:stk500boot.c  **** 
 823:stk500boot.c  **** 				case ST_MSG_SIZE_2:
 824:stk500boot.c  **** 					msgLength |= c;
 1153               		.loc 1 824 0
 1154 0206 292B      		or r18,r25
 1155               	.LVL78:
 825:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 826:stk500boot.c  **** 					checksum ^= c;
 1156               		.loc 1 826 0
 1157 0208 3926      		eor r3,r25
 1158               	.LVL79:
 825:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 1159               		.loc 1 825 0
 1160 020a 84E0      		ldi r24,lo8(4)
 827:stk500boot.c  **** 					break;
 1161               		.loc 1 827 0
 1162 020c 00C0      		rjmp .L88
 1163               	.LVL80:
 1164               	.L85:
 828:stk500boot.c  **** 
 829:stk500boot.c  **** 				case ST_GET_TOKEN:
 830:stk500boot.c  **** 					if (c == TOKEN) {
 1165               		.loc 1 830 0
 1166 020e 9E30      		cpi r25,lo8(14)
 1167 0210 01F0      		breq .+2
 1168 0212 00C0      		rjmp .L152
 1169               	.LVL81:
 831:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 832:stk500boot.c  **** 						checksum ^= c;
 1170               		.loc 1 832 0
 1171 0214 3926      		eor r3,r25
 1172               	.LVL82:
 833:stk500boot.c  **** 						ii = 0;
 1173               		.loc 1 833 0
 1174 0216 C25E      		subi r28,lo8(-286)
 1175 0218 DE4F      		sbci r29,hi8(-286)
 1176 021a 1982      		std Y+1,__zero_reg__
 1177 021c 1882      		st Y,__zero_reg__
 1178 021e CE51      		subi r28,lo8(286)
 1179 0220 D140      		sbci r29,hi8(286)
 831:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 1180               		.loc 1 831 0
 1181 0222 85E0      		ldi r24,lo8(5)
 1182 0224 00C0      		rjmp .L88
 1183               	.LVL83:
 1184               	.L84:
 834:stk500boot.c  **** 					} else {
 835:stk500boot.c  **** 						msgParseState = ST_START;
 836:stk500boot.c  **** 					}
 837:stk500boot.c  **** 					break;
 838:stk500boot.c  **** 
 839:stk500boot.c  **** 				case ST_GET_DATA:
 840:stk500boot.c  **** 					msgBuffer[ii++] = c;
 1185               		.loc 1 840 0
 1186 0226 C25E      		subi r28,lo8(-286)
 1187 0228 DE4F      		sbci r29,hi8(-286)
 1188 022a 4881      		ld r20,Y
 1189 022c 5981      		ldd r21,Y+1
 1190 022e CE51      		subi r28,lo8(286)
 1191 0230 D140      		sbci r29,hi8(286)
 1192 0232 4F5F      		subi r20,-1
 1193 0234 5F4F      		sbci r21,-1
 1194               	.LVL84:
 1195 0236 E1E0      		ldi r30,lo8(1)
 1196 0238 F0E0      		ldi r31,0
 1197 023a EC0F      		add r30,r28
 1198 023c FD1F      		adc r31,r29
 1199 023e C25E      		subi r28,lo8(-286)
 1200 0240 DE4F      		sbci r29,hi8(-286)
 1201 0242 8880      		ld r8,Y
 1202 0244 9980      		ldd r9,Y+1
 1203 0246 CE51      		subi r28,lo8(286)
 1204 0248 D140      		sbci r29,hi8(286)
 1205 024a E80D      		add r30,r8
 1206 024c F91D      		adc r31,r9
 1207 024e 9083      		st Z,r25
 841:stk500boot.c  **** 					checksum ^= c;
 1208               		.loc 1 841 0
 1209 0250 3926      		eor r3,r25
 1210               	.LVL85:
 842:stk500boot.c  **** 					if (ii == msgLength) {
 1211               		.loc 1 842 0
 1212 0252 4217      		cp r20,r18
 1213 0254 5307      		cpc r21,r19
 1214 0256 01F4      		brne .+2
 1215 0258 00C0      		rjmp .L153
 1216 025a C25E      		subi r28,lo8(-286)
 1217 025c DE4F      		sbci r29,hi8(-286)
 1218 025e 5983      		std Y+1,r21
 1219 0260 4883      		st Y,r20
 1220 0262 CE51      		subi r28,lo8(286)
 1221 0264 D140      		sbci r29,hi8(286)
 1222 0266 00C0      		rjmp .L88
 1223               	.LVL86:
 1224               	.L86:
 843:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 844:stk500boot.c  **** 					}
 845:stk500boot.c  **** 					break;
 846:stk500boot.c  **** 
 847:stk500boot.c  **** 				case ST_GET_CHECK:
 848:stk500boot.c  **** 					if (c == checksum) {
 1225               		.loc 1 848 0
 1226 0268 9311      		cpse r25,r3
 1227 026a 00C0      		rjmp .L152
 1228 026c 00C0      		rjmp .L154
 1229               	.L201:
 1230               	.LVL87:
 760:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 1231               		.loc 1 760 0 discriminator 1
 1232 026e 8730      		cpi r24,lo8(7)
 1233 0270 01F0      		breq .+2
 1234 0272 00C0      		rjmp .L88
 1235 0274 00C0      		rjmp .L154
 1236               	.LVL88:
 1237               	.L199:
 778:stk500boot.c  **** 						exPointCntr = 0; //	reset back to zero so we dont get in an endless loop
 1238               		.loc 1 778 0
 1239 0276 C85D      		subi r28,lo8(-296)
 1240 0278 DE4F      		sbci r29,hi8(-296)
 1241 027a 1982      		std Y+1,__zero_reg__
 1242 027c 1882      		st Y,__zero_reg__
 1243 027e C852      		subi r28,lo8(296)
 1244 0280 D140      		sbci r29,hi8(296)
 779:stk500boot.c  **** 						isLeave = 1;
 1245               		.loc 1 779 0
 1246 0282 21E0      		ldi r18,lo8(1)
 1247               	.LVL89:
 1248 0284 CF5D      		subi r28,lo8(-289)
 1249 0286 DE4F      		sbci r29,hi8(-289)
 1250 0288 2883      		st Y,r18
 1251 028a C152      		subi r28,lo8(289)
 1252 028c D140      		sbci r29,hi8(289)
 1253 028e 00C0      		rjmp .L77
 1254               	.LVL90:
 1255               	.L154:
 1256 0290 CF5D      		subi r28,lo8(-289)
 1257 0292 DE4F      		sbci r29,hi8(-289)
 1258 0294 1882      		st Y,__zero_reg__
 1259 0296 C152      		subi r28,lo8(289)
 1260 0298 D140      		sbci r29,hi8(289)
 1261               	.LVL91:
 1262               	.L77:
 849:stk500boot.c  **** 						msgParseState = ST_PROCESS;
 850:stk500boot.c  **** 					} else {
 851:stk500boot.c  **** 						msgParseState = ST_START;
 852:stk500boot.c  **** 					}
 853:stk500boot.c  **** 					break;
 854:stk500boot.c  **** 				} //	switch
 855:stk500boot.c  **** 			} //	while(msgParseState)
 856:stk500boot.c  **** 
 857:stk500boot.c  **** 			/*
 858:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 859:stk500boot.c  **** 			 */
 860:stk500boot.c  **** 
 861:stk500boot.c  **** 			switch (msgBuffer[0]) {
 1263               		.loc 1 861 0
 1264 029a 2981      		ldd r18,Y+1
 1265 029c 2331      		cpi r18,lo8(19)
 1266 029e 01F4      		brne .+2
 1267 02a0 00C0      		rjmp .L90
 1268 02a2 00F4      		brsh .L91
 1269 02a4 2630      		cpi r18,lo8(6)
 1270 02a6 01F4      		brne .+2
 1271 02a8 00C0      		rjmp .L92
 1272 02aa 00F4      		brsh .L93
 1273 02ac 2230      		cpi r18,lo8(2)
 1274 02ae 01F4      		brne .+2
 1275 02b0 00C0      		rjmp .L197
 1276 02b2 2330      		cpi r18,lo8(3)
 1277 02b4 01F4      		brne .+2
 1278 02b6 00C0      		rjmp .L95
 1279 02b8 2130      		cpi r18,lo8(1)
 1280 02ba 01F0      		breq .+2
 1281 02bc 00C0      		rjmp .L89
 1282               	.LVL92:
 862:stk500boot.c  **** #ifndef REMOVE_CMD_SPI_MULTI
 863:stk500boot.c  **** 			case CMD_SPI_MULTI: {
 864:stk500boot.c  **** 				unsigned char answerByte;
 865:stk500boot.c  **** 				unsigned char flag = 0;
 866:stk500boot.c  **** 
 867:stk500boot.c  **** 				if (msgBuffer[4] == 0x30) {
 868:stk500boot.c  **** 					unsigned char signatureIndex = msgBuffer[6];
 869:stk500boot.c  **** 
 870:stk500boot.c  **** 					if (signatureIndex == 0) {
 871:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 872:stk500boot.c  **** 					} else if (signatureIndex == 1) {
 873:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 874:stk500boot.c  **** 					} else {
 875:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 876:stk500boot.c  **** 					}
 877:stk500boot.c  **** 				} else if (msgBuffer[4] & 0x50) {
 878:stk500boot.c  **** 					//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 879:stk500boot.c  **** 					//*	I cant find the docs that say what these are supposed to be but this was figured out by tr
 880:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 881:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 882:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 883:stk500boot.c  **** 					if (msgBuffer[4] == 0x50) {
 884:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 885:stk500boot.c  **** 					} else if (msgBuffer[4] == 0x58) {
 886:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 887:stk500boot.c  **** 					} else {
 888:stk500boot.c  **** 						answerByte = 0;
 889:stk500boot.c  **** 					}
 890:stk500boot.c  **** 				} else {
 891:stk500boot.c  **** 					answerByte = 0; // for all others command are not implemented, return dummy value for AVRDUDE 
 892:stk500boot.c  **** 				}
 893:stk500boot.c  **** 				if (!flag) {
 894:stk500boot.c  **** 					msgLength = 7;
 895:stk500boot.c  **** 					msgBuffer[1] = STATUS_CMD_OK;
 896:stk500boot.c  **** 					msgBuffer[2] = 0;
 897:stk500boot.c  **** 					msgBuffer[3] = msgBuffer[4];
 898:stk500boot.c  **** 					msgBuffer[4] = 0;
 899:stk500boot.c  **** 					msgBuffer[5] = answerByte;
 900:stk500boot.c  **** 					msgBuffer[6] = STATUS_CMD_OK;
 901:stk500boot.c  **** 				}
 902:stk500boot.c  **** 			}
 903:stk500boot.c  **** 				break;
 904:stk500boot.c  **** #endif
 905:stk500boot.c  **** 			case CMD_SIGN_ON:
 906:stk500boot.c  **** 				msgLength = 11;
 907:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1283               		.loc 1 907 0
 1284 02be 1A82      		std Y+2,__zero_reg__
 908:stk500boot.c  **** 				msgBuffer[2] = 8;
 1285               		.loc 1 908 0
 1286 02c0 88E0      		ldi r24,lo8(8)
 1287               	.LVL93:
 1288 02c2 8B83      		std Y+3,r24
 909:stk500boot.c  **** 				msgBuffer[3] = 'A';
 1289               		.loc 1 909 0
 1290 02c4 81E4      		ldi r24,lo8(65)
 1291 02c6 8C83      		std Y+4,r24
 910:stk500boot.c  **** 				msgBuffer[4] = 'V';
 1292               		.loc 1 910 0
 1293 02c8 86E5      		ldi r24,lo8(86)
 1294 02ca 8D83      		std Y+5,r24
 911:stk500boot.c  **** 				msgBuffer[5] = 'R';
 1295               		.loc 1 911 0
 1296 02cc 82E5      		ldi r24,lo8(82)
 1297 02ce 8E83      		std Y+6,r24
 912:stk500boot.c  **** 				msgBuffer[6] = 'I';
 1298               		.loc 1 912 0
 1299 02d0 89E4      		ldi r24,lo8(73)
 1300 02d2 8F83      		std Y+7,r24
 913:stk500boot.c  **** 				msgBuffer[7] = 'S';
 1301               		.loc 1 913 0
 1302 02d4 83E5      		ldi r24,lo8(83)
 1303 02d6 8887      		std Y+8,r24
 914:stk500boot.c  **** 				msgBuffer[8] = 'P';
 1304               		.loc 1 914 0
 1305 02d8 80E5      		ldi r24,lo8(80)
 1306 02da 8987      		std Y+9,r24
 915:stk500boot.c  **** 				msgBuffer[9] = '_';
 1307               		.loc 1 915 0
 1308 02dc 8FE5      		ldi r24,lo8(95)
 1309 02de 8A87      		std Y+10,r24
 916:stk500boot.c  **** 				msgBuffer[10] = '2';
 1310               		.loc 1 916 0
 1311 02e0 82E3      		ldi r24,lo8(50)
 1312 02e2 8B87      		std Y+11,r24
 906:stk500boot.c  **** 				msgLength = 11;
 1313               		.loc 1 906 0
 1314 02e4 0BE0      		ldi r16,lo8(11)
 1315 02e6 10E0      		ldi r17,0
 917:stk500boot.c  **** 				break;
 1316               		.loc 1 917 0
 1317 02e8 00C0      		rjmp .L109
 1318               	.LVL94:
 1319               	.L93:
 861:stk500boot.c  **** 			switch (msgBuffer[0]) {
 1320               		.loc 1 861 0
 1321 02ea 2131      		cpi r18,lo8(17)
 1322 02ec 01F4      		brne .+2
 1323 02ee 00C0      		rjmp .L155
 1324 02f0 00F0      		brlo .+2
 1325 02f2 00C0      		rjmp .L98
 1326 02f4 2031      		cpi r18,lo8(16)
 1327 02f6 01F4      		brne .+2
 1328 02f8 00C0      		rjmp .L197
 1329 02fa 00C0      		rjmp .L89
 1330               	.L91:
 1331 02fc 2831      		cpi r18,lo8(24)
 1332 02fe 01F4      		brne .+2
 1333 0300 00C0      		rjmp .L99
 1334 0302 00F4      		brsh .L100
 1335 0304 2531      		cpi r18,lo8(21)
 1336 0306 01F4      		brne .+2
 1337 0308 00C0      		rjmp .L90
 1338 030a 00F4      		brsh .+2
 1339 030c 00C0      		rjmp .L101
 1340 030e 2631      		cpi r18,lo8(22)
 1341 0310 01F4      		brne .+2
 1342 0312 00C0      		rjmp .L101
 1343 0314 00C0      		rjmp .L89
 1344               	.L100:
 1345 0316 2A31      		cpi r18,lo8(26)
 1346 0318 01F4      		brne .+2
 1347 031a 00C0      		rjmp .L102
 1348 031c 00F4      		brsh .+2
 1349 031e 00C0      		rjmp .L103
 1350 0320 2B31      		cpi r18,lo8(27)
 1351 0322 01F4      		brne .+2
 1352 0324 00C0      		rjmp .L104
 1353 0326 2D31      		cpi r18,lo8(29)
 1354 0328 01F0      		breq .+2
 1355 032a 00C0      		rjmp .L89
 1356               	.LVL95:
 1357               	.LBB67:
 867:stk500boot.c  **** 				if (msgBuffer[4] == 0x30) {
 1358               		.loc 1 867 0
 1359 032c 8D81      		ldd r24,Y+5
 1360               	.LVL96:
 1361 032e 8033      		cpi r24,lo8(48)
 1362 0330 01F4      		brne .L106
 1363               	.LBB68:
 868:stk500boot.c  **** 					unsigned char signatureIndex = msgBuffer[6];
 1364               		.loc 1 868 0
 1365 0332 9F81      		ldd r25,Y+7
 1366               	.LVL97:
 870:stk500boot.c  **** 					if (signatureIndex == 0) {
 1367               		.loc 1 870 0
 1368 0334 9923      		tst r25
 1369 0336 01F0      		breq .L156
 872:stk500boot.c  **** 					} else if (signatureIndex == 1) {
 1370               		.loc 1 872 0
 1371 0338 9130      		cpi r25,lo8(1)
 1372 033a 01F4      		brne .L157
 873:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1373               		.loc 1 873 0
 1374 033c 98E9      		ldi r25,lo8(-104)
 1375               	.LVL98:
 1376 033e 00C0      		rjmp .L107
 1377               	.LVL99:
 1378               	.L106:
 1379               	.LBE68:
 877:stk500boot.c  **** 				} else if (msgBuffer[4] & 0x50) {
 1380               		.loc 1 877 0
 1381 0340 982F      		mov r25,r24
 1382               	.LVL100:
 1383 0342 9075      		andi r25,lo8(80)
 1384 0344 01F0      		breq .L159
 883:stk500boot.c  **** 					if (msgBuffer[4] == 0x50) {
 1385               		.loc 1 883 0
 1386 0346 8035      		cpi r24,lo8(80)
 1387 0348 01F4      		brne .L108
 1388               	.LBB69:
 884:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1389               		.loc 1 884 0
 1390 034a 99E0      		ldi r25,lo8(9)
 1391 034c E0E0      		ldi r30,0
 1392 034e F0E0      		ldi r31,0
 1393 0350 00C0      		rjmp .L189
 1394               	.L108:
 1395               	.LBE69:
 885:stk500boot.c  **** 					} else if (msgBuffer[4] == 0x58) {
 1396               		.loc 1 885 0
 1397 0352 8835      		cpi r24,lo8(88)
 1398 0354 01F4      		brne .L159
 1399               	.LBB70:
 886:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1400               		.loc 1 886 0
 1401 0356 E3E0      		ldi r30,lo8(3)
 1402 0358 F0E0      		ldi r31,0
 1403 035a 99E0      		ldi r25,lo8(9)
 1404               	.L189:
 1405               	/* #APP */
 1406               	 ;  886 "stk500boot.c" 1
 1407 035c 9093 5700 		sts 87, r25
 1408 0360 9491      		lpm r25, Z
 1409               		
 1410               	 ;  0 "" 2
 1411               	.LVL101:
 1412               	/* #NOAPP */
 1413               	.LBE70:
 1414 0362 00C0      		rjmp .L107
 1415               	.LVL102:
 1416               	.L156:
 1417               	.LBB71:
 871:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1418               		.loc 1 871 0
 1419 0364 9EE1      		ldi r25,lo8(30)
 1420               	.LVL103:
 1421 0366 00C0      		rjmp .L107
 1422               	.LVL104:
 1423               	.L157:
 875:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 1424               		.loc 1 875 0
 1425 0368 91E0      		ldi r25,lo8(1)
 1426               	.LVL105:
 1427 036a 00C0      		rjmp .L107
 1428               	.LVL106:
 1429               	.L159:
 1430               	.LBE71:
 891:stk500boot.c  **** 					answerByte = 0; // for all others command are not implemented, return dummy value for AVRDUDE 
 1431               		.loc 1 891 0
 1432 036c 90E0      		ldi r25,0
 1433               	.L107:
 1434               	.LVL107:
 895:stk500boot.c  **** 					msgBuffer[1] = STATUS_CMD_OK;
 1435               		.loc 1 895 0
 1436 036e 1A82      		std Y+2,__zero_reg__
 896:stk500boot.c  **** 					msgBuffer[2] = 0;
 1437               		.loc 1 896 0
 1438 0370 1B82      		std Y+3,__zero_reg__
 897:stk500boot.c  **** 					msgBuffer[3] = msgBuffer[4];
 1439               		.loc 1 897 0
 1440 0372 8C83      		std Y+4,r24
 898:stk500boot.c  **** 					msgBuffer[4] = 0;
 1441               		.loc 1 898 0
 1442 0374 1D82      		std Y+5,__zero_reg__
 899:stk500boot.c  **** 					msgBuffer[5] = answerByte;
 1443               		.loc 1 899 0
 1444 0376 9E83      		std Y+6,r25
 900:stk500boot.c  **** 					msgBuffer[6] = STATUS_CMD_OK;
 1445               		.loc 1 900 0
 1446 0378 1F82      		std Y+7,__zero_reg__
 894:stk500boot.c  **** 					msgLength = 7;
 1447               		.loc 1 894 0
 1448 037a 07E0      		ldi r16,lo8(7)
 1449 037c 10E0      		ldi r17,0
 1450 037e 00C0      		rjmp .L109
 1451               	.LVL108:
 1452               	.L95:
 1453 0380 EA81      		ldd r30,Y+2
 1454 0382 E059      		subi r30,lo8(-(112))
 1455 0384 E330      		cpi r30,lo8(3)
 1456 0386 00F4      		brsh .L160
 1457 0388 F0E0      		ldi r31,0
 1458 038a E050      		subi r30,lo8(-(CSWTCH.43))
 1459 038c F040      		sbci r31,hi8(-(CSWTCH.43))
 1460 038e 8081      		ld r24,Z
 1461               	.LVL109:
 1462 0390 00C0      		rjmp .L110
 1463               	.LVL110:
 1464               	.L160:
 1465               	.LBE67:
 1466               	.LBB72:
 918:stk500boot.c  **** 
 919:stk500boot.c  **** 			case CMD_GET_PARAMETER: {
 920:stk500boot.c  **** 				unsigned char value;
 921:stk500boot.c  **** 
 922:stk500boot.c  **** 				switch (msgBuffer[1]) {
 1467               		.loc 1 922 0
 1468 0392 80E0      		ldi r24,0
 1469               	.LVL111:
 1470               	.L110:
 923:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_LOW:
 924:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_LOW;
 925:stk500boot.c  **** 					break;
 926:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_HIGH:
 927:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_HIGH;
 928:stk500boot.c  **** 					break;
 929:stk500boot.c  **** 				case PARAM_HW_VER:
 930:stk500boot.c  **** 					value = CONFIG_PARAM_HW_VER;
 931:stk500boot.c  **** 					break;
 932:stk500boot.c  **** 				case PARAM_SW_MAJOR:
 933:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MAJOR;
 934:stk500boot.c  **** 					break;
 935:stk500boot.c  **** 				case PARAM_SW_MINOR:
 936:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MINOR;
 937:stk500boot.c  **** 					break;
 938:stk500boot.c  **** 				default:
 939:stk500boot.c  **** 					value = 0;
 940:stk500boot.c  **** 					break;
 941:stk500boot.c  **** 				}
 942:stk500boot.c  **** 				msgLength = 3;
 943:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1471               		.loc 1 943 0
 1472 0394 1A82      		std Y+2,__zero_reg__
 944:stk500boot.c  **** 				msgBuffer[2] = value;
 1473               		.loc 1 944 0
 1474 0396 8B83      		std Y+3,r24
 1475 0398 00C0      		rjmp .L192
 1476               	.LVL112:
 1477               	.L155:
 1478               	.LBE72:
 945:stk500boot.c  **** 			}
 946:stk500boot.c  **** 				break;
 947:stk500boot.c  **** 
 948:stk500boot.c  **** 			case CMD_LEAVE_PROGMODE_ISP:
 949:stk500boot.c  **** 				isLeave = 1;
 1479               		.loc 1 949 0
 1480 039a 21E0      		ldi r18,lo8(1)
 1481 039c CF5D      		subi r28,lo8(-289)
 1482 039e DE4F      		sbci r29,hi8(-289)
 1483 03a0 2883      		st Y,r18
 1484 03a2 C152      		subi r28,lo8(289)
 1485 03a4 D140      		sbci r29,hi8(289)
 1486               	.LVL113:
 1487 03a6 00C0      		rjmp .L197
 1488               	.LVL114:
 1489               	.L104:
 1490               	.LBB73:
 950:stk500boot.c  **** 				//*	fall thru
 951:stk500boot.c  **** 
 952:stk500boot.c  **** 			case CMD_SET_PARAMETER:
 953:stk500boot.c  **** 			case CMD_ENTER_PROGMODE_ISP:
 954:stk500boot.c  **** 				msgLength = 2;
 955:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 956:stk500boot.c  **** 				break;
 957:stk500boot.c  **** 
 958:stk500boot.c  **** 			case CMD_READ_SIGNATURE_ISP: {
 959:stk500boot.c  **** 				unsigned char signatureIndex = msgBuffer[4];
 1491               		.loc 1 959 0
 1492 03a8 8D81      		ldd r24,Y+5
 1493               	.LVL115:
 960:stk500boot.c  **** 				unsigned char signature;
 961:stk500boot.c  **** 
 962:stk500boot.c  **** 				if (signatureIndex == 0)
 1494               		.loc 1 962 0
 1495 03aa 8823      		tst r24
 1496 03ac 01F0      		breq .L161
 963:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 964:stk500boot.c  **** 				else if (signatureIndex == 1)
 1497               		.loc 1 964 0
 1498 03ae 8130      		cpi r24,lo8(1)
 1499 03b0 01F4      		brne .L162
 965:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1500               		.loc 1 965 0
 1501 03b2 88E9      		ldi r24,lo8(-104)
 1502               	.LVL116:
 1503 03b4 00C0      		rjmp .L196
 1504               	.LVL117:
 1505               	.L161:
 963:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1506               		.loc 1 963 0
 1507 03b6 8EE1      		ldi r24,lo8(30)
 1508               	.LVL118:
 1509 03b8 00C0      		rjmp .L196
 1510               	.LVL119:
 1511               	.L162:
 966:stk500boot.c  **** 				else
 967:stk500boot.c  **** 					signature = SIGNATURE_BYTES & 0x000000FF;
 1512               		.loc 1 967 0
 1513 03ba 81E0      		ldi r24,lo8(1)
 1514               	.LVL120:
 1515 03bc 00C0      		rjmp .L196
 1516               	.LVL121:
 1517               	.L102:
 1518               	.LBE73:
 968:stk500boot.c  **** 
 969:stk500boot.c  **** 				msgLength = 4;
 970:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 971:stk500boot.c  **** 				msgBuffer[2] = signature;
 972:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 973:stk500boot.c  **** 			}
 974:stk500boot.c  **** 				break;
 975:stk500boot.c  **** 
 976:stk500boot.c  **** 			case CMD_READ_LOCK_ISP:
 977:stk500boot.c  **** 				msgLength = 4;
 978:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1519               		.loc 1 978 0
 1520 03be 1A82      		std Y+2,__zero_reg__
 1521               	.LBB74:
 979:stk500boot.c  **** 				msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
 1522               		.loc 1 979 0
 1523 03c0 E1E0      		ldi r30,lo8(1)
 1524 03c2 F0E0      		ldi r31,0
 1525 03c4 89E0      		ldi r24,lo8(9)
 1526               	.LVL122:
 1527               	/* #APP */
 1528               	 ;  979 "stk500boot.c" 1
 1529 03c6 8093 5700 		sts 87, r24
 1530 03ca E491      		lpm r30, Z
 1531               		
 1532               	 ;  0 "" 2
 1533               	.LVL123:
 1534               	/* #NOAPP */
 1535               	.LBE74:
 1536 03cc EB83      		std Y+3,r30
 1537               	.LVL124:
 1538               	.L194:
 980:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 1539               		.loc 1 980 0
 1540 03ce 1C82      		std Y+4,__zero_reg__
 977:stk500boot.c  **** 				msgLength = 4;
 1541               		.loc 1 977 0
 1542 03d0 04E0      		ldi r16,lo8(4)
 1543 03d2 10E0      		ldi r17,0
 981:stk500boot.c  **** 				break;
 1544               		.loc 1 981 0
 1545 03d4 00C0      		rjmp .L109
 1546               	.LVL125:
 1547               	.L99:
 1548               	.LBB75:
 982:stk500boot.c  **** 
 983:stk500boot.c  **** 			case CMD_READ_FUSE_ISP: {
 984:stk500boot.c  **** 				unsigned char fuseBits;
 985:stk500boot.c  **** 
 986:stk500boot.c  **** 				if (msgBuffer[2] == 0x50) {
 1549               		.loc 1 986 0
 1550 03d6 8B81      		ldd r24,Y+3
 1551               	.LVL126:
 1552 03d8 8035      		cpi r24,lo8(80)
 1553 03da 01F4      		brne .L112
 987:stk500boot.c  **** 					if (msgBuffer[3] == 0x08)
 1554               		.loc 1 987 0
 1555 03dc 8C81      		ldd r24,Y+4
 1556 03de 8830      		cpi r24,lo8(8)
 1557 03e0 01F4      		brne .L113
 1558               	.LBB76:
 988:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1559               		.loc 1 988 0
 1560 03e2 E2E0      		ldi r30,lo8(2)
 1561 03e4 F0E0      		ldi r31,0
 1562 03e6 00C0      		rjmp .L190
 1563               	.L113:
 1564               	.LBE76:
 1565               	.LBB77:
 989:stk500boot.c  **** 					else
 990:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 1566               		.loc 1 990 0
 1567 03e8 89E0      		ldi r24,lo8(9)
 1568 03ea E0E0      		ldi r30,0
 1569 03ec F0E0      		ldi r31,0
 1570 03ee 00C0      		rjmp .L191
 1571               	.L112:
 1572               	.LBE77:
 1573               	.LBB78:
 991:stk500boot.c  **** 				} else {
 992:stk500boot.c  **** 					fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 1574               		.loc 1 992 0
 1575 03f0 E3E0      		ldi r30,lo8(3)
 1576 03f2 F0E0      		ldi r31,0
 1577               	.L190:
 1578 03f4 89E0      		ldi r24,lo8(9)
 1579               	.L191:
 1580               	/* #APP */
 1581               	 ;  992 "stk500boot.c" 1
 1582 03f6 8093 5700 		sts 87, r24
 1583 03fa 8491      		lpm r24, Z
 1584               		
 1585               	 ;  0 "" 2
 1586               	.LVL127:
 1587               	/* #NOAPP */
 1588               	.L196:
 1589               	.LBE78:
 993:stk500boot.c  **** 				}
 994:stk500boot.c  **** 				msgLength = 4;
 995:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1590               		.loc 1 995 0
 1591 03fc 1A82      		std Y+2,__zero_reg__
 996:stk500boot.c  **** 				msgBuffer[2] = fuseBits;
 1592               		.loc 1 996 0
 1593 03fe 8B83      		std Y+3,r24
 1594 0400 00C0      		rjmp .L194
 1595               	.LVL128:
 1596               	.L103:
 1597               	.LBE75:
 1598               	.LBB79:
 997:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 998:stk500boot.c  **** 			}
 999:stk500boot.c  **** 				break;
1000:stk500boot.c  **** 
1001:stk500boot.c  **** #ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1002:stk500boot.c  **** 			case CMD_PROGRAM_LOCK_ISP: {
1003:stk500boot.c  **** 				unsigned char lockBits = msgBuffer[4];
1004:stk500boot.c  **** 
1005:stk500boot.c  **** 				lockBits = (~lockBits) & 0x3C; // mask BLBxx bits
 1599               		.loc 1 1005 0
 1600 0402 8D81      		ldd r24,Y+5
 1601               	.LVL129:
 1602               	.LBB80:
1006:stk500boot.c  **** 				boot_lock_bits_set(lockBits);
 1603               		.loc 1 1006 0
 1604 0404 836C      		ori r24,lo8(-61)
 1605               	.LVL130:
 1606 0406 99E0      		ldi r25,lo8(9)
 1607               	.LVL131:
 1608               	/* #APP */
 1609               	 ;  1006 "stk500boot.c" 1
 1610 0408 E1E0      		ldi r30, 1
 1611 040a F0E0      		ldi r31, 0
 1612 040c 082E      		mov r0, r24
 1613 040e 9093 5700 		sts 87, r25
 1614 0412 E895      		spm
 1615               		
 1616               	 ;  0 "" 2
 1617               	/* #NOAPP */
 1618               	.L116:
 1619               	.LBE80:
1007:stk500boot.c  **** 				// and program it
1008:stk500boot.c  **** 				boot_spm_busy_wait();
 1620               		.loc 1 1008 0 discriminator 1
 1621 0414 07B6      		in __tmp_reg__,0x37
 1622 0416 00FC      		sbrc __tmp_reg__,0
 1623 0418 00C0      		rjmp .L116
 1624               	.LVL132:
1009:stk500boot.c  **** 
1010:stk500boot.c  **** 				msgLength = 3;
1011:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1625               		.loc 1 1011 0
 1626 041a 1A82      		std Y+2,__zero_reg__
1012:stk500boot.c  **** 				msgBuffer[2] = STATUS_CMD_OK;
 1627               		.loc 1 1012 0
 1628 041c 1B82      		std Y+3,__zero_reg__
 1629               	.LVL133:
 1630               	.L192:
1010:stk500boot.c  **** 				msgLength = 3;
 1631               		.loc 1 1010 0
 1632 041e 03E0      		ldi r16,lo8(3)
 1633 0420 10E0      		ldi r17,0
 1634               	.LBE79:
1013:stk500boot.c  **** 			}
1014:stk500boot.c  **** 				break;
 1635               		.loc 1 1014 0
 1636 0422 00C0      		rjmp .L109
 1637               	.LVL134:
 1638               	.L98:
1015:stk500boot.c  **** #endif
1016:stk500boot.c  **** 			case CMD_CHIP_ERASE_ISP:
1017:stk500boot.c  **** 				eraseAddress = 0;
1018:stk500boot.c  **** 				msgLength = 2;
1019:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1020:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED; //*	isue 543, return FAILED instead of OK
 1639               		.loc 1 1020 0
 1640 0424 80EC      		ldi r24,lo8(-64)
 1641               	.LVL135:
 1642 0426 8A83      		std Y+2,r24
1018:stk500boot.c  **** 				msgLength = 2;
 1643               		.loc 1 1018 0
 1644 0428 02E0      		ldi r16,lo8(2)
 1645 042a 10E0      		ldi r17,0
1017:stk500boot.c  **** 				eraseAddress = 0;
 1646               		.loc 1 1017 0
 1647 042c C12C      		mov r12,__zero_reg__
 1648 042e D12C      		mov r13,__zero_reg__
 1649 0430 7601      		movw r14,r12
1021:stk500boot.c  **** 				break;
 1650               		.loc 1 1021 0
 1651 0432 00C0      		rjmp .L109
 1652               	.LVL136:
 1653               	.L92:
1022:stk500boot.c  **** 
1023:stk500boot.c  **** 			case CMD_LOAD_ADDRESS:
1024:stk500boot.c  **** #if defined(RAMPZ)
1025:stk500boot.c  **** 				address = ( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuf
 1654               		.loc 1 1025 0
 1655 0434 8A81      		ldd r24,Y+2
 1656               	.LVL137:
 1657 0436 4B80      		ldd r4,Y+3
 1658               	.LVL138:
 1659 0438 512C      		mov r5,__zero_reg__
 1660 043a 612C      		mov r6,__zero_reg__
 1661 043c 712C      		mov r7,__zero_reg__
 1662 043e 3201      		movw r6,r4
 1663 0440 5524      		clr r5
 1664 0442 4424      		clr r4
 1665 0444 782A      		or r7,r24
 1666 0446 8D81      		ldd r24,Y+5
 1667 0448 482A      		or r4,r24
 1668 044a 8C81      		ldd r24,Y+4
 1669 044c 582A      		or r5,r24
 1670 044e 440C      		lsl r4
 1671 0450 551C      		rol r5
 1672 0452 661C      		rol r6
 1673 0454 771C      		rol r7
 1674               	.L197:
 1675               	.LVL139:
1026:stk500boot.c  **** #else
1027:stk500boot.c  **** 				address = (((msgBuffer[3]) << 8) | (msgBuffer[4])) << 1; //convert word to byte address
1028:stk500boot.c  **** #endif
1029:stk500boot.c  **** 				msgLength = 2;
1030:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1676               		.loc 1 1030 0
 1677 0456 1A82      		std Y+2,__zero_reg__
 1678 0458 00C0      		rjmp .L193
 1679               	.LVL140:
 1680               	.L90:
 1681               	.LBB81:
1031:stk500boot.c  **** 				break;
1032:stk500boot.c  **** 
1033:stk500boot.c  **** 			case CMD_PROGRAM_FLASH_ISP:
1034:stk500boot.c  **** 			case CMD_PROGRAM_EEPROM_ISP: {
1035:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1682               		.loc 1 1035 0
 1683 045a 2A80      		ldd r2,Y+2
 1684 045c 312C      		mov r3,__zero_reg__
 1685               	.LVL141:
 1686 045e 322C      		mov r3,r2
 1687 0460 2224      		clr r2
 1688               	.LVL142:
 1689 0462 8B81      		ldd r24,Y+3
 1690               	.LVL143:
 1691 0464 282A      		or r2,r24
 1692               	.LVL144:
1036:stk500boot.c  **** 				unsigned char *p = msgBuffer + 10;
1037:stk500boot.c  **** 				unsigned int data;
1038:stk500boot.c  **** 				unsigned char highByte, lowByte;
1039:stk500boot.c  **** 				address_t tempaddress = address;
1040:stk500boot.c  **** 
1041:stk500boot.c  **** 				if (msgBuffer[0] == CMD_PROGRAM_FLASH_ISP) {
 1693               		.loc 1 1041 0
 1694 0466 2331      		cpi r18,lo8(19)
 1695 0468 01F0      		breq .+2
 1696 046a 00C0      		rjmp .L117
1042:stk500boot.c  **** 					// erase only main section (bootloader protection)
1043:stk500boot.c  **** 					if (eraseAddress < APP_END) {
 1697               		.loc 1 1043 0
 1698 046c C114      		cp r12,__zero_reg__
 1699 046e F0EC      		ldi r31,-64
 1700 0470 DF06      		cpc r13,r31
 1701 0472 F3E0      		ldi r31,3
 1702 0474 EF06      		cpc r14,r31
 1703 0476 F104      		cpc r15,__zero_reg__
 1704 0478 00F4      		brsh .L118
1044:stk500boot.c  **** 						boot_page_erase(eraseAddress);
 1705               		.loc 1 1044 0
 1706 047a 83E0      		ldi r24,lo8(3)
 1707               	/* #APP */
 1708               	 ;  1044 "stk500boot.c" 1
 1709 047c F601      		movw r30, r12
 1710 047e E092 5B00 		sts  91, r14
 1711 0482 8093 5700 		sts 87, r24
 1712 0486 E895      		spm
 1713               		
 1714               	 ;  0 "" 2
 1715               	/* #NOAPP */
 1716               	.L120:
1045:stk500boot.c  **** 						// Perform page erase
1046:stk500boot.c  **** 						boot_spm_busy_wait(); // Wait until the memory is erased.
 1717               		.loc 1 1046 0 discriminator 1
 1718 0488 07B6      		in __tmp_reg__,0x37
 1719 048a 00FC      		sbrc __tmp_reg__,0
 1720 048c 00C0      		rjmp .L120
1047:stk500boot.c  **** 						eraseAddress += SPM_PAGESIZE; // point to next page to be erase
 1721               		.loc 1 1047 0
 1722 048e 2FEF      		ldi r18,-1
 1723 0490 D21A      		sub r13,r18
 1724 0492 E20A      		sbc r14,r18
 1725 0494 F20A      		sbc r15,r18
 1726               	.LVL145:
 1727               	.L118:
 1728 0496 2B85      		ldd r18,Y+11
 1729               	.LBE81:
 1730               	.LBB83:
 967:stk500boot.c  **** 					signature = SIGNATURE_BYTES & 0x000000FF;
 1731               		.loc 1 967 0 discriminator 1
 1732 0498 B301      		movw r22,r6
 1733 049a A201      		movw r20,r4
 1734 049c CE01      		movw r24,r28
 1735 049e 0B96      		adiw r24,11
 1736               	.LBE83:
 1737               	.LBB84:
1048:stk500boot.c  **** 					}
1049:stk500boot.c  **** 
1050:stk500boot.c  **** 					/* Write FLASH */
1051:stk500boot.c  **** 					do {
1052:stk500boot.c  **** 						lowByte = *p++;
1053:stk500boot.c  **** 						highByte = *p++;
1054:stk500boot.c  **** 
1055:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
1056:stk500boot.c  **** 						boot_page_fill(address, data);
 1738               		.loc 1 1056 0 discriminator 1
 1739 04a0 11E0      		ldi r17,lo8(1)
 1740               	.LVL146:
 1741               	.L122:
 1742 04a2 DC01      		movw r26,r24
 1743 04a4 1296      		adiw r26,2
 1744 04a6 CD01      		movw r24,r26
 1745               	.LVL147:
 1746 04a8 FD01      		movw r30,r26
 1747 04aa 3197      		sbiw r30,1
 1748               	.LVL148:
1055:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
 1749               		.loc 1 1055 0 discriminator 1
 1750 04ac E081      		ld r30,Z
 1751               	.LVL149:
 1752 04ae 30E0      		ldi r19,0
 1753 04b0 3E2B      		or r19,r30
 1754               		.loc 1 1056 0 discriminator 1
 1755               	/* #APP */
 1756               	 ;  1056 "stk500boot.c" 1
 1757 04b2 0901      		movw  r0, r18
 1758 04b4 FA01      		movw r30, r20
 1759 04b6 6093 5B00 		sts 91, r22
 1760 04ba 1093 5700 		sts 87, r17
 1761 04be E895      		spm
 1762 04c0 1124      		clr  r1
 1763               		
 1764               	 ;  0 "" 2
 1765               	.LVL150:
1057:stk500boot.c  **** 
1058:stk500boot.c  **** 						address = address + 2; // Select next word in memory
 1766               		.loc 1 1058 0 discriminator 1
 1767               	/* #NOAPP */
 1768 04c2 4E5F      		subi r20,-2
 1769 04c4 5F4F      		sbci r21,-1
 1770 04c6 6F4F      		sbci r22,-1
 1771 04c8 7F4F      		sbci r23,-1
 1772               	.LVL151:
1059:stk500boot.c  **** 						size -= 2; // Reduce number of bytes to write by two
 1773               		.loc 1 1059 0 discriminator 1
 1774 04ca E2E0      		ldi r30,2
 1775 04cc 2E1A      		sub r2,r30
 1776 04ce 3108      		sbc r3,__zero_reg__
 1777               	.LVL152:
1060:stk500boot.c  **** 					} while (size); // Loop until all bytes written
 1778               		.loc 1 1060 0 discriminator 1
 1779 04d0 2114      		cp r2,__zero_reg__
 1780 04d2 3104      		cpc r3,__zero_reg__
 1781 04d4 01F0      		breq .L121
1053:stk500boot.c  **** 						highByte = *p++;
 1782               		.loc 1 1053 0
 1783 04d6 2C91      		ld r18,X
 1784               	.LVL153:
 1785 04d8 00C0      		rjmp .L122
 1786               	.LVL154:
 1787               	.L121:
1061:stk500boot.c  **** 
1062:stk500boot.c  **** 					boot_page_write(tempaddress);
 1788               		.loc 1 1062 0
 1789 04da 85E0      		ldi r24,lo8(5)
 1790 04dc 882E      		mov r8,r24
 1791               	.LVL155:
 1792               	/* #APP */
 1793               	 ;  1062 "stk500boot.c" 1
 1794 04de F201      		movw r30, r4
 1795 04e0 6092 5B00 		sts 91, r6
 1796 04e4 8092 5700 		sts 87, r8
 1797 04e8 E895      		spm
 1798               		
 1799               	 ;  0 "" 2
 1800               	/* #NOAPP */
 1801               	.L124:
1063:stk500boot.c  **** 					boot_spm_busy_wait();
 1802               		.loc 1 1063 0 discriminator 1
 1803 04ea 07B6      		in __tmp_reg__,0x37
 1804 04ec 00FC      		sbrc __tmp_reg__,0
 1805 04ee 00C0      		rjmp .L124
1064:stk500boot.c  **** 					boot_rww_enable(); // Re-enable the RWW section
 1806               		.loc 1 1064 0
 1807 04f0 81E1      		ldi r24,lo8(17)
 1808               	/* #APP */
 1809               	 ;  1064 "stk500boot.c" 1
 1810 04f2 8093 5700 		sts 87, r24
 1811 04f6 E895      		spm
 1812               		
 1813               	 ;  0 "" 2
 1814               	/* #NOAPP */
 1815 04f8 00C0      		rjmp .L125
 1816               	.LVL156:
 1817               	.L117:
 1818               	.LBB82:
1065:stk500boot.c  **** 				} else {
1066:stk500boot.c  **** 					//*	issue 543, this should work, It has not been tested.
1067:stk500boot.c  **** 					uint16_t ii = address >> 1;
 1819               		.loc 1 1067 0
 1820 04fa B301      		movw r22,r6
 1821 04fc A201      		movw r20,r4
 1822 04fe 7695      		lsr r23
 1823 0500 6795      		ror r22
 1824 0502 5795      		ror r21
 1825 0504 4795      		ror r20
 1826 0506 CC5D      		subi r28,lo8(-292)
 1827 0508 DE4F      		sbci r29,hi8(-292)
 1828 050a 4883      		st Y,r20
 1829 050c 5983      		std Y+1,r21
 1830 050e 6A83      		std Y+2,r22
 1831 0510 7B83      		std Y+3,r23
 1832 0512 C452      		subi r28,lo8(292)
 1833 0514 D140      		sbci r29,hi8(292)
 1834               	.LVL157:
 1835 0516 8E01      		movw r16,r28
 1836 0518 055F      		subi r16,-11
 1837 051a 1F4F      		sbci r17,-1
1068:stk500boot.c  **** 					/* write EEPROM */
1069:stk500boot.c  **** 					while (size) {
 1838               		.loc 1 1069 0
 1839 051c A12C      		mov r10,__zero_reg__
 1840 051e B12C      		mov r11,__zero_reg__
 1841               	.LVL158:
 1842               	.L126:
 1843               		.loc 1 1069 0 is_stmt 0 discriminator 1
 1844 0520 A214      		cp r10,r2
 1845 0522 B304      		cpc r11,r3
 1846 0524 01F0      		breq .L203
1070:stk500boot.c  **** 						eeprom_write_byte((uint8_t*) ii, *p++);
 1847               		.loc 1 1070 0 is_stmt 1
 1848 0526 D801      		movw r26,r16
 1849 0528 6D91      		ld r22,X+
 1850 052a 8D01      		movw r16,r26
 1851 052c CC5D      		subi r28,lo8(-292)
 1852 052e DE4F      		sbci r29,hi8(-292)
 1853 0530 8881      		ld r24,Y
 1854 0532 9981      		ldd r25,Y+1
 1855 0534 C452      		subi r28,lo8(292)
 1856 0536 D140      		sbci r29,hi8(292)
 1857 0538 8A0D      		add r24,r10
 1858 053a 9B1D      		adc r25,r11
 1859               	.LVL159:
 1860 053c 0E94 0000 		call __eewr_byte_m2560
 1861               	.LVL160:
 1862 0540 BFEF      		ldi r27,-1
 1863 0542 AB1A      		sub r10,r27
 1864 0544 BB0A      		sbc r11,r27
 1865               	.LVL161:
 1866 0546 00C0      		rjmp .L126
 1867               	.L203:
 1868 0548 A501      		movw r20,r10
 1869 054a 60E0      		ldi r22,0
 1870 054c 70E0      		ldi r23,0
 1871 054e 440F      		lsl r20
 1872 0550 551F      		rol r21
 1873 0552 661F      		rol r22
 1874 0554 771F      		rol r23
 1875 0556 440D      		add r20,r4
 1876 0558 551D      		adc r21,r5
 1877 055a 661D      		adc r22,r6
 1878 055c 771D      		adc r23,r7
 1879               	.LVL162:
 1880               	.L125:
 1881               	.LBE82:
1071:stk500boot.c  **** 						address += 2; // Select next EEPROM byte
1072:stk500boot.c  **** 						ii++;
1073:stk500boot.c  **** 						size--;
1074:stk500boot.c  **** 					}
1075:stk500boot.c  **** 				}
1076:stk500boot.c  **** 				msgLength = 2;
1077:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1882               		.loc 1 1077 0
 1883 055e 1A82      		std Y+2,__zero_reg__
 1884               	.LBE84:
1078:stk500boot.c  **** 			}
1079:stk500boot.c  **** 				break;
 1885               		.loc 1 1079 0
 1886 0560 2A01      		movw r4,r20
 1887 0562 3B01      		movw r6,r22
 1888               	.LVL163:
 1889 0564 00C0      		rjmp .L193
 1890               	.LVL164:
 1891               	.L101:
 1892               	.LBB85:
1080:stk500boot.c  **** 
1081:stk500boot.c  **** 			case CMD_READ_FLASH_ISP:
1082:stk500boot.c  **** 			case CMD_READ_EEPROM_ISP: {
1083:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1893               		.loc 1 1083 0
 1894 0566 8A81      		ldd r24,Y+2
 1895               	.LVL165:
 1896 0568 90E0      		ldi r25,0
 1897               	.LVL166:
 1898 056a 982F      		mov r25,r24
 1899 056c 8827      		clr r24
 1900 056e 3B81      		ldd r19,Y+3
 1901 0570 832B      		or r24,r19
 1902               	.LVL167:
1084:stk500boot.c  **** 				unsigned char *p = msgBuffer + 1;
1085:stk500boot.c  **** 				msgLength = size + 3;
 1903               		.loc 1 1085 0
 1904 0572 8C01      		movw r16,r24
 1905 0574 0D5F      		subi r16,-3
 1906 0576 1F4F      		sbci r17,-1
 1907               	.LVL168:
1086:stk500boot.c  **** 
1087:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 1908               		.loc 1 1087 0
 1909 0578 1A82      		std Y+2,__zero_reg__
1088:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1910               		.loc 1 1088 0
 1911 057a 2431      		cpi r18,lo8(20)
 1912 057c 01F4      		brne .L128
 1913 057e DE01      		movw r26,r28
 1914 0580 1396      		adiw r26,3
 1915               	.LVL169:
 1916               	.L130:
 1917               	.LBB86:
 1918               	.LBB87:
1089:stk500boot.c  **** 					unsigned int data;
1090:stk500boot.c  **** 
1091:stk500boot.c  **** 					// Read FLASH
1092:stk500boot.c  **** 					do {
1093:stk500boot.c  **** 						//#if defined(RAMPZ)
1094:stk500boot.c  **** #if (FLASHEND > 0x10000)
1095:stk500boot.c  **** 						data = pgm_read_word_far(address);
 1919               		.loc 1 1095 0 discriminator 1
 1920               	/* #APP */
 1921               	 ;  1095 "stk500boot.c" 1
 1922 0582 6BBE      		out 59, r6
 1923 0584 F201      		movw r30, r4
 1924 0586 2791      		elpm r18, Z+
 1925 0588 3691      		elpm r19, Z
 1926               		
 1927               	 ;  0 "" 2
 1928               	.LVL170:
 1929               	/* #NOAPP */
 1930               	.LBE87:
1096:stk500boot.c  **** #else
1097:stk500boot.c  **** 						data = pgm_read_word_near(address);
1098:stk500boot.c  **** #endif
1099:stk500boot.c  **** 						*p++ = (unsigned char) data; //LSB
 1931               		.loc 1 1099 0 discriminator 1
 1932 058a 2C93      		st X,r18
 1933 058c 1296      		adiw r26,2
 1934               	.LVL171:
 1935 058e FD01      		movw r30,r26
 1936 0590 3197      		sbiw r30,1
1100:stk500boot.c  **** 						*p++ = (unsigned char) (data >> 8); //MSB
 1937               		.loc 1 1100 0 discriminator 1
 1938 0592 3083      		st Z,r19
1101:stk500boot.c  **** 						address += 2; // Select next word in memory
 1939               		.loc 1 1101 0 discriminator 1
 1940 0594 E2E0      		ldi r30,2
 1941 0596 4E0E      		add r4,r30
 1942 0598 511C      		adc r5,__zero_reg__
 1943 059a 611C      		adc r6,__zero_reg__
 1944 059c 711C      		adc r7,__zero_reg__
 1945               	.LVL172:
1102:stk500boot.c  **** 						size -= 2;
 1946               		.loc 1 1102 0 discriminator 1
 1947 059e 0297      		sbiw r24,2
 1948               	.LVL173:
1103:stk500boot.c  **** 					} while (size);
 1949               		.loc 1 1103 0 discriminator 1
 1950 05a0 0097      		sbiw r24,0
 1951 05a2 01F4      		brne .L130
 1952 05a4 00C0      		rjmp .L129
 1953               	.LVL174:
 1954               	.L128:
 1955 05a6 FE01      		movw r30,r28
 1956 05a8 3396      		adiw r30,3
 1957               	.LBE86:
1088:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1958               		.loc 1 1088 0
 1959 05aa 9C01      		movw r18,r24
 1960 05ac B301      		movw r22,r6
 1961 05ae A201      		movw r20,r4
 1962               	.LVL175:
 1963               	.L132:
1104:stk500boot.c  **** 				} else {
1105:stk500boot.c  **** 					/* Read EEPROM */
1106:stk500boot.c  **** 					do {
1107:stk500boot.c  **** 						EEARL = address; // Setup EEPROM address
 1964               		.loc 1 1107 0 discriminator 1
 1965 05b0 41BD      		out 0x21,r20
1108:stk500boot.c  **** 						EEARH = ((address >> 8));
 1966               		.loc 1 1108 0 discriminator 1
 1967 05b2 852E      		mov r8,r21
 1968 05b4 962E      		mov r9,r22
 1969 05b6 A72E      		mov r10,r23
 1970 05b8 BB24      		clr r11
 1971 05ba CC5D      		subi r28,lo8(-292)
 1972 05bc DE4F      		sbci r29,hi8(-292)
 1973 05be 8882      		st Y,r8
 1974 05c0 9982      		std Y+1,r9
 1975 05c2 AA82      		std Y+2,r10
 1976 05c4 BB82      		std Y+3,r11
 1977 05c6 C452      		subi r28,lo8(292)
 1978 05c8 D140      		sbci r29,hi8(292)
 1979 05ca 82BC      		out 0x22,r8
1109:stk500boot.c  **** 						address++; // Select next EEPROM byte
 1980               		.loc 1 1109 0 discriminator 1
 1981 05cc 4F5F      		subi r20,-1
 1982 05ce 5F4F      		sbci r21,-1
 1983 05d0 6F4F      		sbci r22,-1
 1984 05d2 7F4F      		sbci r23,-1
 1985               	.LVL176:
1110:stk500boot.c  **** 						EECR |= (1 << EERE); // Read EEPROM
 1986               		.loc 1 1110 0 discriminator 1
 1987 05d4 F89A      		sbi 0x1f,0
 1988               	.LVL177:
1111:stk500boot.c  **** 						*p++ = EEDR; // Send EEPROM data
 1989               		.loc 1 1111 0 discriminator 1
 1990 05d6 A0B5      		in r26,0x20
 1991 05d8 A193      		st Z+,r26
 1992               	.LVL178:
1112:stk500boot.c  **** 						size--;
 1993               		.loc 1 1112 0 discriminator 1
 1994 05da 2150      		subi r18,1
 1995 05dc 3109      		sbc r19,__zero_reg__
 1996               	.LVL179:
1113:stk500boot.c  **** 					} while (size);
 1997               		.loc 1 1113 0 discriminator 1
 1998 05de 2115      		cp r18,__zero_reg__
 1999 05e0 3105      		cpc r19,__zero_reg__
 2000 05e2 01F4      		brne .L132
 2001 05e4 AC01      		movw r20,r24
 2002               	.LVL180:
 2003 05e6 4150      		subi r20,1
 2004 05e8 5109      		sbc r21,__zero_reg__
 2005 05ea 60E0      		ldi r22,0
 2006 05ec 70E0      		ldi r23,0
 2007 05ee 4F5F      		subi r20,-1
 2008 05f0 5F4F      		sbci r21,-1
 2009 05f2 6F4F      		sbci r22,-1
 2010 05f4 7F4F      		sbci r23,-1
 2011 05f6 440E      		add r4,r20
 2012 05f8 551E      		adc r5,r21
 2013 05fa 661E      		adc r6,r22
 2014 05fc 771E      		adc r7,r23
 2015 05fe A3E0      		ldi r26,lo8(3)
 2016 0600 B0E0      		ldi r27,0
 2017 0602 AC0F      		add r26,r28
 2018 0604 BD1F      		adc r27,r29
 2019 0606 A80F      		add r26,r24
 2020 0608 B91F      		adc r27,r25
 2021               	.LVL181:
 2022               	.L129:
1114:stk500boot.c  **** 				}
1115:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 2023               		.loc 1 1115 0
 2024 060a 1C92      		st X,__zero_reg__
 2025               	.LBE85:
1116:stk500boot.c  **** 			}
1117:stk500boot.c  **** 				break;
 2026               		.loc 1 1117 0
 2027 060c 00C0      		rjmp .L109
 2028               	.LVL182:
 2029               	.L89:
1118:stk500boot.c  **** 
1119:stk500boot.c  **** 			default:
1120:stk500boot.c  **** 				msgLength = 2;
1121:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED;
 2030               		.loc 1 1121 0
 2031 060e 80EC      		ldi r24,lo8(-64)
 2032               	.LVL183:
 2033 0610 8A83      		std Y+2,r24
 2034               	.LVL184:
 2035               	.L193:
1120:stk500boot.c  **** 				msgLength = 2;
 2036               		.loc 1 1120 0
 2037 0612 02E0      		ldi r16,lo8(2)
 2038 0614 10E0      		ldi r17,0
 2039               	.LVL185:
 2040               	.L109:
1122:stk500boot.c  **** 				break;
1123:stk500boot.c  **** 			}
1124:stk500boot.c  **** 
1125:stk500boot.c  **** 			/*
1126:stk500boot.c  **** 			 * Now send answer message back
1127:stk500boot.c  **** 			 */
1128:stk500boot.c  **** 			sendchar(MESSAGE_START);
 2041               		.loc 1 1128 0
 2042 0616 8BE1      		ldi r24,lo8(27)
 2043 0618 0E94 0000 		call sendchar
 2044               	.LVL186:
1129:stk500boot.c  **** 			checksum = MESSAGE_START ^ 0;
1130:stk500boot.c  **** 
1131:stk500boot.c  **** 			sendchar(seqNum);
 2045               		.loc 1 1131 0
 2046 061c C05E      		subi r28,lo8(-288)
 2047 061e DE4F      		sbci r29,hi8(-288)
 2048 0620 8881      		ld r24,Y
 2049 0622 C052      		subi r28,lo8(288)
 2050 0624 D140      		sbci r29,hi8(288)
 2051 0626 0E94 0000 		call sendchar
 2052               	.LVL187:
1132:stk500boot.c  **** 			checksum ^= seqNum;
1133:stk500boot.c  **** 
1134:stk500boot.c  **** 			c = ((msgLength >> 8) & 0xFF);
1135:stk500boot.c  **** 			sendchar(c);
 2053               		.loc 1 1135 0
 2054 062a 812F      		mov r24,r17
 2055 062c 0E94 0000 		call sendchar
 2056               	.LVL188:
1136:stk500boot.c  **** 			checksum ^= c;
1137:stk500boot.c  **** 
1138:stk500boot.c  **** 			c = msgLength & 0x00FF;
1139:stk500boot.c  **** 			sendchar(c);
 2057               		.loc 1 1139 0
 2058 0630 802F      		mov r24,r16
 2059 0632 0E94 0000 		call sendchar
 2060               	.LVL189:
1140:stk500boot.c  **** 			checksum ^= c;
1141:stk500boot.c  **** 
1142:stk500boot.c  **** 			sendchar(TOKEN);
 2061               		.loc 1 1142 0
 2062 0636 8EE0      		ldi r24,lo8(14)
 2063 0638 0E94 0000 		call sendchar
 2064               	.LVL190:
1136:stk500boot.c  **** 			checksum ^= c;
 2065               		.loc 1 1136 0
 2066 063c 65E1      		ldi r22,lo8(21)
 2067 063e 362E      		mov r3,r22
 2068 0640 C05E      		subi r28,lo8(-288)
 2069 0642 DE4F      		sbci r29,hi8(-288)
 2070 0644 9880      		ld r9,Y
 2071 0646 C052      		subi r28,lo8(288)
 2072 0648 D140      		sbci r29,hi8(288)
 2073 064a 3924      		eor r3,r9
1140:stk500boot.c  **** 			checksum ^= c;
 2074               		.loc 1 1140 0
 2075 064c 3026      		eor r3,r16
1143:stk500boot.c  **** 			checksum ^= TOKEN;
 2076               		.loc 1 1143 0
 2077 064e 3126      		eor r3,r17
 2078               	.LVL191:
 2079 0650 AE01      		movw r20,r28
 2080 0652 4F5F      		subi r20,-1
 2081 0654 5F4F      		sbci r21,-1
 2082 0656 5A01      		movw r10,r20
 2083 0658 040F      		add r16,r20
 2084 065a 151F      		adc r17,r21
 2085               	.LVL192:
 2086               	.L133:
1144:stk500boot.c  **** 
1145:stk500boot.c  **** 			p = msgBuffer;
1146:stk500boot.c  **** 			while (msgLength) {
 2087               		.loc 1 1146 0 discriminator 1
 2088 065c A016      		cp r10,r16
 2089 065e B106      		cpc r11,r17
 2090 0660 01F0      		breq .L204
 2091               	.LVL193:
1147:stk500boot.c  **** 				c = *p++;
 2092               		.loc 1 1147 0
 2093 0662 D501      		movw r26,r10
 2094 0664 2D90      		ld r2,X+
 2095               	.LVL194:
 2096 0666 5D01      		movw r10,r26
 2097               	.LVL195:
1148:stk500boot.c  **** 				sendchar(c);
 2098               		.loc 1 1148 0
 2099 0668 822D      		mov r24,r2
 2100 066a 0E94 0000 		call sendchar
 2101               	.LVL196:
1149:stk500boot.c  **** 				checksum ^= c;
 2102               		.loc 1 1149 0
 2103 066e 3224      		eor r3,r2
 2104               	.LVL197:
 2105 0670 00C0      		rjmp .L133
 2106               	.LVL198:
 2107               	.L204:
1150:stk500boot.c  **** 				msgLength--;
1151:stk500boot.c  **** 			}
1152:stk500boot.c  **** 			sendchar(checksum);
 2108               		.loc 1 1152 0
 2109 0672 832D      		mov r24,r3
 2110 0674 0E94 0000 		call sendchar
 2111               	.LVL199:
1153:stk500boot.c  **** 			seqNum++;
 2112               		.loc 1 1153 0
 2113 0678 C05E      		subi r28,lo8(-288)
 2114 067a DE4F      		sbci r29,hi8(-288)
 2115 067c 2881      		ld r18,Y
 2116 067e C052      		subi r28,lo8(288)
 2117 0680 D140      		sbci r29,hi8(288)
 2118 0682 2F5F      		subi r18,lo8(-(1))
 2119 0684 C05E      		subi r28,lo8(-288)
 2120 0686 DE4F      		sbci r29,hi8(-288)
 2121 0688 2883      		st Y,r18
 2122 068a C052      		subi r28,lo8(288)
 2123 068c D140      		sbci r29,hi8(288)
 2124               	.LVL200:
 755:stk500boot.c  **** 		while (!isLeave) {
 2125               		.loc 1 755 0
 2126 068e CF5D      		subi r28,lo8(-289)
 2127 0690 DE4F      		sbci r29,hi8(-289)
 2128 0692 4881      		ld r20,Y
 2129 0694 C152      		subi r28,lo8(289)
 2130 0696 D140      		sbci r29,hi8(289)
 2131 0698 4111      		cpse r20,__zero_reg__
 2132 069a 00C0      		rjmp .L136
 2133 069c 40E0      		ldi r20,0
 2134 069e 50E0      		ldi r21,0
 2135 06a0 00C0      		rjmp .L70
 2136               	.LVL201:
 2137               	.L69:
1154:stk500boot.c  **** 
1155:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1156:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1157:stk500boot.c  **** 		//	PROGLED_PORT ^= (1 << PROGLED_PIN); // active high LED ON
1158:stk500boot.c  **** #endif
1159:stk500boot.c  **** 
1160:stk500boot.c  **** 		}
1161:stk500boot.c  **** 	}
1162:stk500boot.c  **** 
1163:stk500boot.c  **** 	if (boot_state == 2) {
 2138               		.loc 1 1163 0
 2139 06a2 4230      		cpi r20,2
 2140 06a4 5105      		cpc r21,__zero_reg__
 2141 06a6 01F0      		breq .+2
 2142 06a8 00C0      		rjmp .L136
1164:stk500boot.c  **** 		if (eeprom_read_byte(4095) == 0xF0) {
 2143               		.loc 1 1164 0
 2144 06aa 8FEF      		ldi r24,lo8(-1)
 2145 06ac 9FE0      		ldi r25,lo8(15)
 2146               	.LVL202:
 2147 06ae 0E94 0000 		call __eerd_byte_m2560
 2148               	.LVL203:
 2149 06b2 803F      		cpi r24,lo8(-16)
 2150 06b4 01F0      		breq .+2
 2151 06b6 00C0      		rjmp .L136
 2152               	.LBB88:
1165:stk500boot.c  **** 			sendchar('u');
 2153               		.loc 1 1165 0
 2154 06b8 85E7      		ldi r24,lo8(117)
 2155 06ba 0E94 0000 		call sendchar
 2156               	.LVL204:
1166:stk500boot.c  **** 			sendchar('p');
 2157               		.loc 1 1166 0
 2158 06be 80E7      		ldi r24,lo8(112)
 2159 06c0 0E94 0000 		call sendchar
 2160               	.LVL205:
1167:stk500boot.c  **** 			sendchar('g');
 2161               		.loc 1 1167 0
 2162 06c4 87E6      		ldi r24,lo8(103)
 2163 06c6 0E94 0000 		call sendchar
 2164               	.LVL206:
1168:stk500boot.c  **** 			sendchar('r');
 2165               		.loc 1 1168 0
 2166 06ca 82E7      		ldi r24,lo8(114)
 2167 06cc 0E94 0000 		call sendchar
 2168               	.LVL207:
1169:stk500boot.c  **** 			sendchar('a');
 2169               		.loc 1 1169 0
 2170 06d0 81E6      		ldi r24,lo8(97)
 2171 06d2 0E94 0000 		call sendchar
 2172               	.LVL208:
1170:stk500boot.c  **** 			sendchar('d');
 2173               		.loc 1 1170 0
 2174 06d6 84E6      		ldi r24,lo8(100)
 2175 06d8 0E94 0000 		call sendchar
 2176               	.LVL209:
1171:stk500boot.c  **** 			sendchar('i');
 2177               		.loc 1 1171 0
 2178 06dc 89E6      		ldi r24,lo8(105)
 2179 06de 0E94 0000 		call sendchar
 2180               	.LVL210:
1172:stk500boot.c  **** 			sendchar('n');
 2181               		.loc 1 1172 0
 2182 06e2 8EE6      		ldi r24,lo8(110)
 2183 06e4 0E94 0000 		call sendchar
 2184               	.LVL211:
1173:stk500boot.c  **** 			sendchar('g');
 2185               		.loc 1 1173 0
 2186 06e8 87E6      		ldi r24,lo8(103)
 2187 06ea 0E94 0000 		call sendchar
 2188               	.LVL212:
1174:stk500boot.c  **** 			sendchar(0x0d);
 2189               		.loc 1 1174 0
 2190 06ee 8DE0      		ldi r24,lo8(13)
 2191 06f0 0E94 0000 		call sendchar
 2192               	.LVL213:
1175:stk500boot.c  **** 			sendchar(0x0a);
 2193               		.loc 1 1175 0
 2194 06f4 8AE0      		ldi r24,lo8(10)
 2195 06f6 0E94 0000 		call sendchar
 2196               	.LVL214:
1176:stk500boot.c  **** 			delay_ms(100);
 2197               		.loc 1 1176 0
 2198 06fa 84E6      		ldi r24,lo8(100)
 2199 06fc 90E0      		ldi r25,0
 2200 06fe 0E94 0000 		call delay_ms
 2201               	.LVL215:
1177:stk500boot.c  **** 
1178:stk500boot.c  **** 			DWORD fa; /* Flash address */
1179:stk500boot.c  **** 			sendchar(0x0d);
 2202               		.loc 1 1179 0
 2203 0702 8DE0      		ldi r24,lo8(13)
 2204 0704 0E94 0000 		call sendchar
 2205               	.LVL216:
1180:stk500boot.c  **** 			sendchar(0x0a);
 2206               		.loc 1 1180 0
 2207 0708 8AE0      		ldi r24,lo8(10)
 2208 070a 0E94 0000 		call sendchar
 2209               	.LVL217:
1181:stk500boot.c  **** 			long address = 16;
1182:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2210               		.loc 1 1182 0
 2211 070e C12C      		mov r12,__zero_reg__
 2212 0710 D12C      		mov r13,__zero_reg__
 2213 0712 7601      		movw r14,r12
 2214               	.LBB89:
1183:stk500boot.c  **** 		//		PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
1184:stk500boot.c  **** 				delay_ms(50);
1185:stk500boot.c  **** 				flash_erase(fa); /* Erase a page */
1186:stk500boot.c  **** 				memset(Buff, 0xFF, SPM_PAGESIZE); /* Clear buffer */
1187:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
1188:stk500boot.c  **** 					Buff[i] = spiReadReg(address);
1189:stk500boot.c  **** 					address++;
1190:stk500boot.c  **** 					// sendchar('[');
1191:stk500boot.c  **** 					// dec_hex(Buff[i]);
1192:stk500boot.c  **** 					// sendchar(']');
1193:stk500boot.c  **** 					// if(address % 16 == 0 && address != 0){
1194:stk500boot.c  **** 					// 	sendchar(0x0d);
1195:stk500boot.c  **** 					// 	sendchar(0x0a);
1196:stk500boot.c  **** 					// }
1197:stk500boot.c  **** 					// 
1198:stk500boot.c  **** 					// 
1199:stk500boot.c  **** 					if(((address +1)%1200) <= 300 && ((address +1)%1200) >= 0){
 2215               		.loc 1 1199 0
 2216 0714 50EB      		ldi r21,lo8(-80)
 2217 0716 452E      		mov r4,r21
 2218 0718 54E0      		ldi r21,lo8(4)
 2219 071a 552E      		mov r5,r21
 2220 071c 612C      		mov r6,__zero_reg__
 2221 071e 712C      		mov r7,__zero_reg__
 2222               	.LVL218:
 2223               	.L145:
 2224 0720 4601      		movw r8,r12
 2225 0722 5701      		movw r10,r14
 2226 0724 50E1      		ldi r21,16
 2227 0726 850E      		add r8,r21
 2228 0728 911C      		adc r9,__zero_reg__
 2229 072a A11C      		adc r10,__zero_reg__
 2230 072c B11C      		adc r11,__zero_reg__
 2231               	.LVL219:
 2232               	.LBE89:
1184:stk500boot.c  **** 				delay_ms(50);
 2233               		.loc 1 1184 0
 2234 072e 82E3      		ldi r24,lo8(50)
 2235 0730 90E0      		ldi r25,0
 2236 0732 0E94 0000 		call delay_ms
 2237               	.LVL220:
1185:stk500boot.c  **** 				flash_erase(fa); /* Erase a page */
 2238               		.loc 1 1185 0
 2239 0736 C701      		movw r24,r14
 2240 0738 B601      		movw r22,r12
 2241 073a 0E94 0000 		call flash_erase
 2242               	.LVL221:
1186:stk500boot.c  **** 				memset(Buff, 0xFF, SPM_PAGESIZE); /* Clear buffer */
 2243               		.loc 1 1186 0
 2244 073e 40E0      		ldi r20,0
 2245 0740 51E0      		ldi r21,lo8(1)
 2246 0742 6FEF      		ldi r22,lo8(-1)
 2247 0744 70E0      		ldi r23,0
 2248 0746 80E0      		ldi r24,lo8(Buff)
 2249 0748 90E0      		ldi r25,hi8(Buff)
 2250 074a 0E94 0000 		call memset
 2251               	.LVL222:
 2252 074e 00E0      		ldi r16,lo8(Buff)
 2253 0750 10E0      		ldi r17,hi8(Buff)
 2254               	.LVL223:
 2255               	.L143:
 2256               	.LBB90:
1188:stk500boot.c  **** 					Buff[i] = spiReadReg(address);
 2257               		.loc 1 1188 0
 2258 0752 C501      		movw r24,r10
 2259 0754 B401      		movw r22,r8
 2260 0756 0E94 0000 		call spiReadReg
 2261               	.LVL224:
 2262 075a D801      		movw r26,r16
 2263 075c 8D93      		st X+,r24
 2264 075e 8D01      		movw r16,r26
 2265               	.LVL225:
1189:stk500boot.c  **** 					address++;
 2266               		.loc 1 1189 0
 2267 0760 BFEF      		ldi r27,-1
 2268 0762 8B1A      		sub r8,r27
 2269 0764 9B0A      		sbc r9,r27
 2270 0766 AB0A      		sbc r10,r27
 2271 0768 BB0A      		sbc r11,r27
 2272               	.LVL226:
 2273 076a C501      		movw r24,r10
 2274 076c B401      		movw r22,r8
 2275 076e 6F5F      		subi r22,-1
 2276 0770 7F4F      		sbci r23,-1
 2277 0772 8F4F      		sbci r24,-1
 2278 0774 9F4F      		sbci r25,-1
 2279               		.loc 1 1199 0
 2280 0776 A301      		movw r20,r6
 2281 0778 9201      		movw r18,r4
 2282 077a 0E94 0000 		call __divmodsi4
 2283 077e 6D32      		cpi r22,45
 2284 0780 E1E0      		ldi r30,1
 2285 0782 7E07      		cpc r23,r30
 2286 0784 8105      		cpc r24,__zero_reg__
 2287 0786 9105      		cpc r25,__zero_reg__
 2288 0788 00F4      		brsh .L139
1200:stk500boot.c  **** 						LED1_HIGH();
 2289               		.loc 1 1200 0
 2290 078a 2D9A      		sbi 0x5,5
1201:stk500boot.c  **** 						LED2_LOW();
 2291               		.loc 1 1201 0
 2292 078c 2E98      		cbi 0x5,6
 2293 078e 00C0      		rjmp .L195
 2294               	.L139:
1202:stk500boot.c  **** 						LED3_LOW();
1203:stk500boot.c  **** 					}else if(((address +1)%1200) <= 700 && ((address +1)%1200) >= 400){
 2295               		.loc 1 1203 0
 2296 0790 9B01      		movw r18,r22
 2297 0792 AC01      		movw r20,r24
 2298 0794 2059      		subi r18,-112
 2299 0796 3140      		sbci r19,1
 2300 0798 4109      		sbc r20,__zero_reg__
 2301 079a 5109      		sbc r21,__zero_reg__
 2302 079c 2D32      		cpi r18,45
 2303 079e 3140      		sbci r19,1
 2304 07a0 4105      		cpc r20,__zero_reg__
 2305 07a2 5105      		cpc r21,__zero_reg__
 2306 07a4 00F4      		brsh .L141
1204:stk500boot.c  **** 						LED1_LOW();
 2307               		.loc 1 1204 0
 2308 07a6 2D98      		cbi 0x5,5
1205:stk500boot.c  **** 						LED2_HIGH();
 2309               		.loc 1 1205 0
 2310 07a8 2E9A      		sbi 0x5,6
 2311               	.L195:
1206:stk500boot.c  **** 						LED3_LOW();
 2312               		.loc 1 1206 0
 2313 07aa 2F98      		cbi 0x5,7
 2314 07ac 00C0      		rjmp .L140
 2315               	.L141:
1207:stk500boot.c  **** 					}else if( ((address +1) %1200) <= 1100  && ((address +1) %1200) >= 8){
 2316               		.loc 1 1207 0
 2317 07ae DC01      		movw r26,r24
 2318 07b0 CB01      		movw r24,r22
 2319 07b2 0897      		sbiw r24,8
 2320 07b4 A109      		sbc r26,__zero_reg__
 2321 07b6 B109      		sbc r27,__zero_reg__
 2322 07b8 8534      		cpi r24,69
 2323 07ba 9440      		sbci r25,4
 2324 07bc A105      		cpc r26,__zero_reg__
 2325 07be B105      		cpc r27,__zero_reg__
 2326 07c0 00F4      		brsh .L140
1208:stk500boot.c  **** 						LED1_LOW();
 2327               		.loc 1 1208 0
 2328 07c2 2D98      		cbi 0x5,5
1209:stk500boot.c  **** 						LED2_LOW();
 2329               		.loc 1 1209 0
 2330 07c4 2E98      		cbi 0x5,6
1210:stk500boot.c  **** 						LED3_HIGH();
 2331               		.loc 1 1210 0
 2332 07c6 2F9A      		sbi 0x5,7
 2333               	.L140:
 2334               	.LVL227:
1187:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
 2335               		.loc 1 1187 0
 2336 07c8 40E0      		ldi r20,hi8(Buff+256)
 2337 07ca 0030      		cpi r16,lo8(Buff+256)
 2338 07cc 1407      		cpc r17,r20
 2339 07ce 01F4      		brne .L143
 2340               	.LBE90:
1211:stk500boot.c  **** 					}
1212:stk500boot.c  **** 				}
1213:stk500boot.c  **** 				flash_write(fa, Buff); /* Write it if the data is available */
 2341               		.loc 1 1213 0
 2342 07d0 40E0      		ldi r20,lo8(Buff)
 2343 07d2 50E0      		ldi r21,hi8(Buff)
 2344 07d4 C701      		movw r24,r14
 2345 07d6 B601      		movw r22,r12
 2346 07d8 0E94 0000 		call flash_write
 2347               	.LVL228:
1182:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2348               		.loc 1 1182 0
 2349 07dc 5FEF      		ldi r21,-1
 2350 07de D51A      		sub r13,r21
 2351 07e0 E50A      		sbc r14,r21
 2352 07e2 F50A      		sbc r15,r21
 2353               	.LVL229:
 2354 07e4 C114      		cp r12,__zero_reg__
 2355 07e6 60EE      		ldi r22,-32
 2356 07e8 D606      		cpc r13,r22
 2357 07ea 63E0      		ldi r22,3
 2358 07ec E606      		cpc r14,r22
 2359 07ee F104      		cpc r15,__zero_reg__
 2360 07f0 01F0      		breq .+2
 2361 07f2 00C0      		rjmp .L145
1214:stk500boot.c  **** 			}
1215:stk500boot.c  **** 			sendchar('d');
 2362               		.loc 1 1215 0
 2363 07f4 84E6      		ldi r24,lo8(100)
 2364 07f6 0E94 0000 		call sendchar
 2365               	.LVL230:
1216:stk500boot.c  **** 			sendchar(0x0d);
 2366               		.loc 1 1216 0
 2367 07fa 8DE0      		ldi r24,lo8(13)
 2368 07fc 0E94 0000 		call sendchar
 2369               	.LVL231:
1217:stk500boot.c  **** 			sendchar(0x0a);
 2370               		.loc 1 1217 0
 2371 0800 8AE0      		ldi r24,lo8(10)
 2372 0802 0E94 0000 		call sendchar
 2373               	.LVL232:
1218:stk500boot.c  **** 			check = 0;
 2374               		.loc 1 1218 0
 2375 0806 1092 0000 		sts check,__zero_reg__
1219:stk500boot.c  **** 			eeprom_write_byte(4095, 0x00);
 2376               		.loc 1 1219 0
 2377 080a 60E0      		ldi r22,0
 2378 080c 8FEF      		ldi r24,lo8(-1)
 2379 080e 9FE0      		ldi r25,lo8(15)
 2380 0810 0E94 0000 		call __eewr_byte_m2560
 2381               	.LVL233:
 2382               	.L136:
 2383               	.LBE88:
1220:stk500boot.c  **** 		}
1221:stk500boot.c  **** 
1222:stk500boot.c  **** 		boot_state = 0;
1223:stk500boot.c  **** 	}
1224:stk500boot.c  **** 
1225:stk500boot.c  **** 	asm volatile ("nop");
 2384               		.loc 1 1225 0
 2385               	/* #APP */
 2386               	 ;  1225 "stk500boot.c" 1
 2387 0814 0000      		nop
 2388               	 ;  0 "" 2
1226:stk500boot.c  **** 	// wait until port has changed
1227:stk500boot.c  **** 
1228:stk500boot.c  **** //    // SDCARD BOOTLOADER
1229:stk500boot.c  **** //
1230:stk500boot.c  **** //    WORD fa;	/* Flash address */
1231:stk500boot.c  **** //    WORD br;	/* Bytes read */
1232:stk500boot.c  **** //	uint8_t i = 0;
1233:stk500boot.c  **** //
1234:stk500boot.c  **** //
1235:stk500boot.c  **** //	pf_mount(&Fatfs);	/* Initialize file system */
1236:stk500boot.c  **** //
1237:stk500boot.c  **** //
1238:stk500boot.c  **** //	if (pf_open("app.bin") == FR_OK) {	/* Open application file */
1239:stk500boot.c  **** //        PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1240:stk500boot.c  **** //		
1241:stk500boot.c  **** //        for (fa = 0; fa < 0x1000; fa += SPM_PAGESIZE) {	/* Update all application pages */
1242:stk500boot.c  **** //            memset(Buff, 0xFF, SPM_PAGESIZE);		/* Clear buffer */
1243:stk500boot.c  **** //            pf_read(Buff, SPM_PAGESIZE, &br);		/* Load a page data */
1244:stk500boot.c  **** //            
1245:stk500boot.c  **** //			if (br) {					/* Bytes Read > 0? */
1246:stk500boot.c  **** //            	for (i = br; i < SPM_PAGESIZE; i++)     /* Pad the remaining last page with 0xFF so 
1247:stk500boot.c  **** //                    Buff[i] = 0xFF;
1248:stk500boot.c  **** //                if (pagecmp(fa, Buff)) {
1249:stk500boot.c  **** //                    flash_erase(fa);		/* Erase a page */
1250:stk500boot.c  **** //                    flash_write(fa, Buff);		/* Write it if the data is available */
1251:stk500boot.c  **** //                }
1252:stk500boot.c  **** //            }
1253:stk500boot.c  **** //    	}
1254:stk500boot.c  **** //        PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1255:stk500boot.c  **** //        
1256:stk500boot.c  **** //    }
1257:stk500boot.c  **** //    
1258:stk500boot.c  **** //    if (pgm_read_word(0) != 0xFFFF)		/* Start application if exist */
1259:stk500boot.c  **** //        asm volatile("jmp 0000");
1260:stk500boot.c  **** //    // SD CARD BOOTLOADER
1261:stk500boot.c  **** 
1262:stk500boot.c  **** 	/*
1263:stk500boot.c  **** 	 * Now leave bootloader
1264:stk500boot.c  **** 	 */
1265:stk500boot.c  **** 
1266:stk500boot.c  **** 	UART_STATUS_REG &= 0xfd;
 2389               		.loc 1 1266 0
 2390               	/* #NOAPP */
 2391 0816 8091 C000 		lds r24,192
 2392 081a 8D7F      		andi r24,lo8(-3)
 2393 081c 8093 C000 		sts 192,r24
1267:stk500boot.c  **** 	boot_rww_enable(); // enable application section
 2394               		.loc 1 1267 0
 2395 0820 81E1      		ldi r24,lo8(17)
 2396               	/* #APP */
 2397               	 ;  1267 "stk500boot.c" 1
 2398 0822 8093 5700 		sts 87, r24
 2399 0826 E895      		spm
 2400               		
 2401               	 ;  0 "" 2
1268:stk500boot.c  **** 
1269:stk500boot.c  **** 	asm volatile(
 2402               		.loc 1 1269 0
 2403               	 ;  1269 "stk500boot.c" 1
 2404 0828 EE27      		clr	r30		
 2405 082a FF27      		clr	r31		
 2406 082c 0994      		ijmp	
 2407               		
 2408               	 ;  0 "" 2
 2409               	/* #NOAPP */
 2410               	.L146:
 2411 082e 00C0      		rjmp .L146
 2412               	.LVL234:
 2413               	.L202:
 794:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 2414               		.loc 1 794 0
 2415 0830 4BE1      		ldi r20,lo8(27)
 2416 0832 342E      		mov r3,r20
 2417               	.LVL235:
 793:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 2418               		.loc 1 793 0
 2419 0834 81E0      		ldi r24,lo8(1)
 2420               	.LVL236:
 2421 0836 00C0      		rjmp .L88
 2422               	.LVL237:
 2423               	.L152:
 835:stk500boot.c  **** 						msgParseState = ST_START;
 2424               		.loc 1 835 0
 2425 0838 80E0      		ldi r24,0
 2426               	.LVL238:
 2427 083a 00C0      		rjmp .L88
 2428               	.LVL239:
 2429               	.L153:
 2430 083c C25E      		subi r28,lo8(-286)
 2431 083e DE4F      		sbci r29,hi8(-286)
 2432 0840 3983      		std Y+1,r19
 2433 0842 2883      		st Y,r18
 2434 0844 CE51      		subi r28,lo8(286)
 2435 0846 D140      		sbci r29,hi8(286)
 843:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 2436               		.loc 1 843 0
 2437 0848 86E0      		ldi r24,lo8(6)
 2438               	.LVL240:
 2439 084a 00C0      		rjmp .L88
 2440               		.cfi_endproc
 2441               	.LFE25:
 2443               		.text
 2444               	.global	PrintFromPROGMEM
 2446               	PrintFromPROGMEM:
 2447               	.LFB26:
1270:stk500boot.c  **** 			"clr	r30		\n\t"
1271:stk500boot.c  **** 			"clr	r31		\n\t"
1272:stk500boot.c  **** 			"ijmp	\n\t"
1273:stk500boot.c  **** 	);
1274:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1275:stk500boot.c  **** //					"push r1" "\n\t"
1276:stk500boot.c  **** //					"ret"	 "\n\t"
1277:stk500boot.c  **** //					::);
1278:stk500boot.c  **** 
1279:stk500boot.c  **** 	/*
1280:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1281:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1282:stk500boot.c  **** 	 * understand this
1283:stk500boot.c  **** 	 */
1284:stk500boot.c  **** 	for (;;)
1285:stk500boot.c  **** 		;
1286:stk500boot.c  **** }
1287:stk500boot.c  **** 
1288:stk500boot.c  **** /*
1289:stk500boot.c  ****  base address = f800
1290:stk500boot.c  **** 
1291:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1292:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1293:stk500boot.c  ****  avrdude: safemode: hfuse reads as DA
1294:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1295:stk500boot.c  ****  avrdude>
1296:stk500boot.c  **** 
1297:stk500boot.c  **** 
1298:stk500boot.c  ****  base address = f000
1299:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1300:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1301:stk500boot.c  ****  avrdude: safemode: hfuse reads as D8
1302:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1303:stk500boot.c  ****  avrdude>
1304:stk500boot.c  ****  */
1305:stk500boot.c  **** 
1306:stk500boot.c  **** //************************************************************************
1307:stk500boot.c  **** #ifdef ENABLE_MONITOR
1308:stk500boot.c  **** #include	<math.h>
1309:stk500boot.c  **** 
1310:stk500boot.c  **** unsigned long gRamIndex;
1311:stk500boot.c  **** unsigned long gFlashIndex;
1312:stk500boot.c  **** unsigned long gEepromIndex;
1313:stk500boot.c  **** 
1314:stk500boot.c  **** #define	true	1
1315:stk500boot.c  **** #define	false	0
1316:stk500boot.c  **** 
1317:stk500boot.c  **** #include	"avr_cpunames.h"
1318:stk500boot.c  **** 
1319:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1320:stk500boot.c  **** #error cpu name not defined
1321:stk500boot.c  **** #endif
1322:stk500boot.c  **** 
1323:stk500boot.c  **** #ifdef _VECTORS_SIZE
1324:stk500boot.c  **** #define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1325:stk500boot.c  **** #else
1326:stk500boot.c  **** #define	kInterruptVectorCount 23
1327:stk500boot.c  **** #endif
1328:stk500boot.c  **** 
1329:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt);
1330:stk500boot.c  **** 
1331:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1332:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = _AVR_CPU_NAME_;
1333:stk500boot.c  **** #else
1334:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = "UNKNOWN";
1335:stk500boot.c  **** #endif
1336:stk500boot.c  **** 
1337:stk500boot.c  **** //************************************************************************
1338:stk500boot.c  **** void PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1339:stk500boot.c  **** {
 2448               		.loc 1 1339 0
 2449               		.cfi_startproc
 2450               	.LVL241:
 2451 0286 CF93      		push r28
 2452               	.LCFI20:
 2453               		.cfi_def_cfa_offset 4
 2454               		.cfi_offset 28, -3
 2455 0288 DF93      		push r29
 2456               	.LCFI21:
 2457               		.cfi_def_cfa_offset 5
 2458               		.cfi_offset 29, -4
 2459               	/* prologue: function */
 2460               	/* frame size = 0 */
 2461               	/* stack size = 2 */
 2462               	.L__stack_usage = 2
1340:stk500boot.c  **** 	char theChar;
1341:stk500boot.c  **** 
1342:stk500boot.c  **** 	dataPtr += offset;
 2463               		.loc 1 1342 0
 2464 028a EC01      		movw r28,r24
 2465 028c C60F      		add r28,r22
 2466 028e D11D      		adc r29,__zero_reg__
 2467               	.LVL242:
 2468               	.L207:
 2469               	.LBB91:
1343:stk500boot.c  **** 
1344:stk500boot.c  **** 	do {
1345:stk500boot.c  **** #if (FLASHEND > 0x10000)
1346:stk500boot.c  **** 		theChar = pgm_read_byte_far((uint16_t)dataPtr++);
 2470               		.loc 1 1346 0
 2471 0290 AE01      		movw r20,r28
 2472 0292 60E0      		ldi r22,0
 2473 0294 70E0      		ldi r23,0
 2474               	/* #APP */
 2475               	 ;  1346 "stk500boot.c" 1
 2476 0296 6BBF      		out 59, r22
 2477 0298 FA01      		movw r30, r20
 2478 029a 8791      		elpm r24, Z+
 2479               		
 2480               	 ;  0 "" 2
 2481               	.LVL243:
 2482               	/* #NOAPP */
 2483               	.LBE91:
1347:stk500boot.c  **** #else
1348:stk500boot.c  **** 		theChar = pgm_read_byte_near((uint16_t)dataPtr++);
1349:stk500boot.c  **** #endif
1350:stk500boot.c  **** 		if (theChar != 0)
 2484               		.loc 1 1350 0
 2485 029c 8823      		tst r24
 2486 029e 01F0      		breq .L205
 2487               	.LVL244:
 2488               	.LBB92:
1346:stk500boot.c  **** 		theChar = pgm_read_byte_far((uint16_t)dataPtr++);
 2489               		.loc 1 1346 0
 2490 02a0 2196      		adiw r28,1
 2491               	.LVL245:
 2492               	.LBE92:
1351:stk500boot.c  **** 		{
1352:stk500boot.c  **** 			sendchar(theChar);
 2493               		.loc 1 1352 0
 2494 02a2 0E94 0000 		call sendchar
 2495               	.LVL246:
 2496 02a6 00C0      		rjmp .L207
 2497               	.LVL247:
 2498               	.L205:
 2499               	/* epilogue start */
1353:stk500boot.c  **** 		}
1354:stk500boot.c  **** 	}while (theChar != 0);
1355:stk500boot.c  **** }
 2500               		.loc 1 1355 0
 2501 02a8 DF91      		pop r29
 2502 02aa CF91      		pop r28
 2503 02ac 0895      		ret
 2504               		.cfi_endproc
 2505               	.LFE26:
 2507               	.global	PrintNewLine
 2509               	PrintNewLine:
 2510               	.LFB27:
1356:stk500boot.c  **** 
1357:stk500boot.c  **** //************************************************************************
1358:stk500boot.c  **** void PrintNewLine(void)
1359:stk500boot.c  **** {
 2511               		.loc 1 1359 0
 2512               		.cfi_startproc
 2513               	/* prologue: function */
 2514               	/* frame size = 0 */
 2515               	/* stack size = 0 */
 2516               	.L__stack_usage = 0
1360:stk500boot.c  **** 	sendchar(0x0d);
 2517               		.loc 1 1360 0
 2518 02ae 8DE0      		ldi r24,lo8(13)
 2519 02b0 0E94 0000 		call sendchar
 2520               	.LVL248:
1361:stk500boot.c  **** 	sendchar(0x0a);
 2521               		.loc 1 1361 0
 2522 02b4 8AE0      		ldi r24,lo8(10)
 2523 02b6 0C94 0000 		jmp sendchar
 2524               	.LVL249:
 2525               		.cfi_endproc
 2526               	.LFE27:
 2528               	.global	PrintFromPROGMEMln
 2530               	PrintFromPROGMEMln:
 2531               	.LFB28:
1362:stk500boot.c  **** }
1363:stk500boot.c  **** 
1364:stk500boot.c  **** //************************************************************************
1365:stk500boot.c  **** void PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1366:stk500boot.c  **** {
 2532               		.loc 1 1366 0
 2533               		.cfi_startproc
 2534               	.LVL250:
 2535               	/* prologue: function */
 2536               	/* frame size = 0 */
 2537               	/* stack size = 0 */
 2538               	.L__stack_usage = 0
1367:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 2539               		.loc 1 1367 0
 2540 02ba 0E94 0000 		call PrintFromPROGMEM
 2541               	.LVL251:
1368:stk500boot.c  **** 
1369:stk500boot.c  **** 	PrintNewLine();
 2542               		.loc 1 1369 0
 2543 02be 0C94 0000 		jmp PrintNewLine
 2544               	.LVL252:
 2545               		.cfi_endproc
 2546               	.LFE28:
 2548               	.global	PrintString
 2550               	PrintString:
 2551               	.LFB29:
1370:stk500boot.c  **** }
1371:stk500boot.c  **** 
1372:stk500boot.c  **** //************************************************************************
1373:stk500boot.c  **** void PrintString(char *textString)
1374:stk500boot.c  **** {
 2552               		.loc 1 1374 0
 2553               		.cfi_startproc
 2554               	.LVL253:
 2555 02c2 CF93      		push r28
 2556               	.LCFI22:
 2557               		.cfi_def_cfa_offset 4
 2558               		.cfi_offset 28, -3
 2559 02c4 DF93      		push r29
 2560               	.LCFI23:
 2561               		.cfi_def_cfa_offset 5
 2562               		.cfi_offset 29, -4
 2563               	/* prologue: function */
 2564               	/* frame size = 0 */
 2565               	/* stack size = 2 */
 2566               	.L__stack_usage = 2
 2567 02c6 EC01      		movw r28,r24
 2568               	.LVL254:
 2569               	.L212:
1375:stk500boot.c  **** 	char theChar;
1376:stk500boot.c  **** 	int ii;
1377:stk500boot.c  **** 
1378:stk500boot.c  **** 	theChar = 1;
1379:stk500boot.c  **** 	ii = 0;
1380:stk500boot.c  **** 	while (theChar != 0)
1381:stk500boot.c  **** 	{
1382:stk500boot.c  **** 		theChar = textString[ii];
 2570               		.loc 1 1382 0
 2571 02c8 8991      		ld r24,Y+
 2572               	.LVL255:
1383:stk500boot.c  **** 		if (theChar != 0)
 2573               		.loc 1 1383 0
 2574 02ca 8823      		tst r24
 2575 02cc 01F0      		breq .L210
1384:stk500boot.c  **** 		{
1385:stk500boot.c  **** 			sendchar(theChar);
 2576               		.loc 1 1385 0
 2577 02ce 0E94 0000 		call sendchar
 2578               	.LVL256:
 2579 02d2 00C0      		rjmp .L212
 2580               	.LVL257:
 2581               	.L210:
 2582               	/* epilogue start */
1386:stk500boot.c  **** 		}
1387:stk500boot.c  **** 		ii++;
1388:stk500boot.c  **** 	}
1389:stk500boot.c  **** }
 2583               		.loc 1 1389 0
 2584 02d4 DF91      		pop r29
 2585 02d6 CF91      		pop r28
 2586               	.LVL258:
 2587 02d8 0895      		ret
 2588               		.cfi_endproc
 2589               	.LFE29:
 2591               	.global	PrintHexByte
 2593               	PrintHexByte:
 2594               	.LFB30:
1390:stk500boot.c  **** 
1391:stk500boot.c  **** //************************************************************************
1392:stk500boot.c  **** void PrintHexByte(unsigned char theByte)
1393:stk500boot.c  **** {
 2595               		.loc 1 1393 0
 2596               		.cfi_startproc
 2597               	.LVL259:
 2598 02da CF93      		push r28
 2599               	.LCFI24:
 2600               		.cfi_def_cfa_offset 4
 2601               		.cfi_offset 28, -3
 2602               	/* prologue: function */
 2603               	/* frame size = 0 */
 2604               	/* stack size = 1 */
 2605               	.L__stack_usage = 1
 2606 02dc C82F      		mov r28,r24
1394:stk500boot.c  **** 	char theChar;
1395:stk500boot.c  **** 
1396:stk500boot.c  **** 	theChar = 0x30 + ((theByte >> 4) & 0x0f);
 2607               		.loc 1 1396 0
 2608 02de 8295      		swap r24
 2609               	.LVL260:
 2610 02e0 8F70      		andi r24,lo8(15)
 2611 02e2 90E3      		ldi r25,lo8(48)
 2612 02e4 980F      		add r25,r24
 2613               	.LVL261:
1397:stk500boot.c  **** 	if (theChar > 0x39)
 2614               		.loc 1 1397 0
 2615 02e6 9A33      		cpi r25,lo8(58)
 2616 02e8 00F0      		brlo .L214
1398:stk500boot.c  **** 	{
1399:stk500boot.c  **** 		theChar += 7;
 2617               		.loc 1 1399 0
 2618 02ea 97E3      		ldi r25,lo8(55)
 2619               	.LVL262:
 2620 02ec 980F      		add r25,r24
 2621               	.LVL263:
 2622               	.L214:
1400:stk500boot.c  **** 	}
1401:stk500boot.c  **** 	sendchar(theChar );
 2623               		.loc 1 1401 0
 2624 02ee 892F      		mov r24,r25
 2625 02f0 0E94 0000 		call sendchar
 2626               	.LVL264:
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 	theChar = 0x30 + (theByte & 0x0f);
 2627               		.loc 1 1403 0
 2628 02f4 CF70      		andi r28,lo8(15)
 2629               	.LVL265:
 2630 02f6 80E3      		ldi r24,lo8(48)
 2631 02f8 8C0F      		add r24,r28
 2632               	.LVL266:
1404:stk500boot.c  **** 	if (theChar > 0x39)
 2633               		.loc 1 1404 0
 2634 02fa 8A33      		cpi r24,lo8(58)
 2635 02fc 00F0      		brlo .L215
1405:stk500boot.c  **** 	{
1406:stk500boot.c  **** 		theChar += 7;
 2636               		.loc 1 1406 0
 2637 02fe 87E3      		ldi r24,lo8(55)
 2638               	.LVL267:
 2639 0300 8C0F      		add r24,r28
 2640               	.LVL268:
 2641               	.L215:
 2642               	/* epilogue start */
1407:stk500boot.c  **** 	}
1408:stk500boot.c  **** 	sendchar(theChar );
1409:stk500boot.c  **** }
 2643               		.loc 1 1409 0
 2644 0302 CF91      		pop r28
1408:stk500boot.c  **** 	sendchar(theChar );
 2645               		.loc 1 1408 0
 2646 0304 0C94 0000 		jmp sendchar
 2647               	.LVL269:
 2648               		.cfi_endproc
 2649               	.LFE30:
 2651               	.global	PrintDecInt
 2653               	PrintDecInt:
 2654               	.LFB31:
1410:stk500boot.c  **** 
1411:stk500boot.c  **** //************************************************************************
1412:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt)
1413:stk500boot.c  **** {
 2655               		.loc 1 1413 0
 2656               		.cfi_startproc
 2657               	.LVL270:
 2658 0308 0F93      		push r16
 2659               	.LCFI25:
 2660               		.cfi_def_cfa_offset 4
 2661               		.cfi_offset 16, -3
 2662 030a 1F93      		push r17
 2663               	.LCFI26:
 2664               		.cfi_def_cfa_offset 5
 2665               		.cfi_offset 17, -4
 2666 030c CF93      		push r28
 2667               	.LCFI27:
 2668               		.cfi_def_cfa_offset 6
 2669               		.cfi_offset 28, -5
 2670 030e DF93      		push r29
 2671               	.LCFI28:
 2672               		.cfi_def_cfa_offset 7
 2673               		.cfi_offset 29, -6
 2674               	/* prologue: function */
 2675               	/* frame size = 0 */
 2676               	/* stack size = 4 */
 2677               	.L__stack_usage = 4
 2678 0310 EC01      		movw r28,r24
 2679 0312 8B01      		movw r16,r22
 2680               	.LVL271:
1414:stk500boot.c  **** 	int theChar;
1415:stk500boot.c  **** 	int myNumber;
1416:stk500boot.c  **** 
1417:stk500boot.c  **** 	myNumber = theNumber;
1418:stk500boot.c  **** 
1419:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 2681               		.loc 1 1419 0
 2682 0314 8536      		cpi r24,101
 2683 0316 9105      		cpc r25,__zero_reg__
 2684 0318 04F4      		brge .L217
 2685               		.loc 1 1419 0 is_stmt 0 discriminator 1
 2686 031a 6330      		cpi r22,3
 2687 031c 7105      		cpc r23,__zero_reg__
 2688 031e 04F0      		brlt .L218
 2689               	.L217:
 2690               	.LVL272:
1420:stk500boot.c  **** 	{
1421:stk500boot.c  **** 		theChar = 0x30 + myNumber / 100;
 2691               		.loc 1 1421 0 is_stmt 1
 2692 0320 CE01      		movw r24,r28
 2693               	.LVL273:
 2694 0322 64E6      		ldi r22,lo8(100)
 2695 0324 70E0      		ldi r23,0
 2696               	.LVL274:
 2697 0326 0E94 0000 		call __divmodhi4
 2698               	.LVL275:
1422:stk500boot.c  **** 		sendchar(theChar );
 2699               		.loc 1 1422 0
 2700 032a 80E3      		ldi r24,lo8(48)
 2701 032c 860F      		add r24,r22
 2702 032e 0E94 0000 		call sendchar
 2703               	.LVL276:
 2704               	.L218:
1423:stk500boot.c  **** 	}
1424:stk500boot.c  **** 
1425:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 2705               		.loc 1 1425 0
 2706 0332 CB30      		cpi r28,11
 2707 0334 D105      		cpc r29,__zero_reg__
 2708 0336 04F4      		brge .L219
 2709               		.loc 1 1425 0 is_stmt 0 discriminator 1
 2710 0338 0230      		cpi r16,2
 2711 033a 1105      		cpc r17,__zero_reg__
 2712 033c 04F0      		brlt .L220
 2713               	.L219:
 2714               	.LVL277:
1426:stk500boot.c  **** 	{
1427:stk500boot.c  **** 		theChar = 0x30 + ((myNumber % 100) / 10 );
 2715               		.loc 1 1427 0 is_stmt 1
 2716 033e CE01      		movw r24,r28
 2717 0340 64E6      		ldi r22,lo8(100)
 2718 0342 70E0      		ldi r23,0
 2719 0344 0E94 0000 		call __divmodhi4
 2720 0348 6AE0      		ldi r22,lo8(10)
 2721 034a 70E0      		ldi r23,0
 2722 034c 0E94 0000 		call __divmodhi4
1428:stk500boot.c  **** 		sendchar(theChar );
 2723               		.loc 1 1428 0
 2724 0350 80E3      		ldi r24,lo8(48)
 2725 0352 860F      		add r24,r22
 2726 0354 0E94 0000 		call sendchar
 2727               	.LVL278:
 2728               	.L220:
1429:stk500boot.c  **** 	}
1430:stk500boot.c  **** 	theChar = 0x30 + (myNumber % 10);
 2729               		.loc 1 1430 0
 2730 0358 CE01      		movw r24,r28
 2731 035a 6AE0      		ldi r22,lo8(10)
 2732 035c 70E0      		ldi r23,0
 2733 035e 0E94 0000 		call __divmodhi4
1431:stk500boot.c  **** 	sendchar(theChar );
 2734               		.loc 1 1431 0
 2735 0362 805D      		subi r24,lo8(-(48))
 2736               	/* epilogue start */
1432:stk500boot.c  **** }
 2737               		.loc 1 1432 0
 2738 0364 DF91      		pop r29
 2739 0366 CF91      		pop r28
 2740               	.LVL279:
 2741 0368 1F91      		pop r17
 2742 036a 0F91      		pop r16
 2743               	.LVL280:
1431:stk500boot.c  **** 	sendchar(theChar );
 2744               		.loc 1 1431 0
 2745 036c 0C94 0000 		jmp sendchar
 2746               	.LVL281:
 2747               		.cfi_endproc
 2748               	.LFE31:
 2750               		.section	.rodata
 2753               	CSWTCH.43:
 2754 0000 0F        		.byte	15
 2755 0001 02        		.byte	2
 2756 0002 0A        		.byte	10
 2757               	.global	gTextMsg_CPU_Name
 2758               		.section	.progmem.data,"a",@progbits
 2761               	gTextMsg_CPU_Name:
 2762 0000 4154 6D65 		.string	"ATmega2560"
 2762      6761 3235 
 2762      3630 00
 2763               		.comm	gEepromIndex,4,1
 2764               		.comm	gFlashIndex,4,1
 2765               		.comm	gRamIndex,4,1
 2766               	.global	check
 2767               		.data
 2770               	check:
 2771 0000 01        		.byte	1
 2772               	.global	app_start
 2773               		.section .bss
 2776               	app_start:
 2777 0000 0000      		.zero	2
 2778               		.comm	Buff,256,1
 2779               		.text
 2780               	.Letext0:
 2781               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 2782               		.file 4 "/usr/local/CrossPack-AVR-20131216/lib/gcc/avr/4.8.1/include/stddef.h"
 2783               		.file 5 "integer.h"
 2784               		.file 6 "/usr/local/CrossPack-AVR-20131216/avr/include/avr/eeprom.h"
 2785               		.file 7 "/usr/local/CrossPack-AVR-20131216/avr/include/string.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stk500boot.c
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2      *ABS*:0000003e __SP_H__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:3      *ABS*:0000003d __SP_L__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:4      *ABS*:0000003f __SREG__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:5      *ABS*:0000003b __RAMPZ__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:7      *ABS*:00000001 __zero_reg__
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:12     .text:00000000 sendchar
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:41     .text:00000018 transfer
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:67     .text:00000024 setDataMode
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:87     .text:0000002e setBitOrder
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:118    .text:00000040 setClockDivider
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:149    .text:0000005c readStatus
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:180    .text:00000072 busy
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:199    .text:0000007a command
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:236    .text:00000090 spiReadReg
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:308    .init9:00000000 __jumpMain
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:319    *ABS*:000021ff __stack
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:713    .text.startup:00000000 main
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:358    .text:000000d6 delay_ms
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:404    .text:000000f4 dec_hex
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2776   .bss:00000000 app_start
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2753   .rodata:00000000 CSWTCH.43
                            *COM*:00000100 Buff
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2770   .data:00000000 check
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2446   .text:00000286 PrintFromPROGMEM
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2509   .text:000002ae PrintNewLine
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2530   .text:000002ba PrintFromPROGMEMln
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2550   .text:000002c2 PrintString
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2593   .text:000002da PrintHexByte
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2653   .text:00000308 PrintDecInt
/var/folders/_b/yv1gbd2x1mb5wglh7z7my89h0000gn/T//cczgxZ5R.s:2761   .progmem.data:00000000 gTextMsg_CPU_Name
                            *COM*:00000004 gEepromIndex
                            *COM*:00000004 gFlashIndex
                            *COM*:00000004 gRamIndex

UNDEFINED SYMBOLS
__eewr_byte_m2560
__eerd_byte_m2560
flash_erase
memset
__divmodsi4
flash_write
__divmodhi4
__do_copy_data
__do_clear_bss
