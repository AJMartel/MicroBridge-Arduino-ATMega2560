   1               		.file	"stk500boot.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	sendchar:
  15               	.LFB17:
  16               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  ****  Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****  Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  ****  Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  ****  File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  ****  Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  ****  Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  ****  License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  ****  Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  ****  Date:      17 October 2007
  12:stk500boot.c  ****  Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte r
  13:stk500boot.c  ****  Compiler:  WINAVR20060421
  14:stk500boot.c  ****  Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  ****  DESCRIPTION:
  17:stk500boot.c  ****  This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****  read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****  an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****  is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****  "reset" vector in Application area.
  22:stk500boot.c  ****  Size fits into a 1024 word bootloader section
  23:stk500boot.c  ****  when compiled with avr-gcc 4.1
  24:stk500boot.c  ****  (direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  ****  USAGE:
  27:stk500boot.c  ****  - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****  - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****  - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****  - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****  for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****  - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****  - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****  - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****  - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****  - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****  - AVRISP will detect the bootloader
  38:stk500boot.c  ****  - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  ****  Note:
  41:stk500boot.c  ****  Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****  is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****  Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  ****  AVRdude:
  46:stk500boot.c  ****  Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  ****  Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  ****  Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  ****  NOTES:
  51:stk500boot.c  ****  Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****  Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  ****  LICENSE:
  55:stk500boot.c  ****  Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****  This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****  it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****  the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****  any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****  This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****  but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****  GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  ****  *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //************************************************************************
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** #include <string.h>
 115:stk500boot.c  **** #include "pff.h"
 116:stk500boot.c  **** 
 117:stk500boot.c  **** void flash_erase(DWORD); /* Erase a flash page (asmfunc.S) */
 118:stk500boot.c  **** void flash_write(DWORD, const BYTE*); /* Program a flash page (asmfunc.S) */
 119:stk500boot.c  **** 
 120:stk500boot.c  **** #define BLINK_LED_WHILE_WAITING
 121:stk500boot.c  **** //#define _DEBUG_WITH_LEDS_
 122:stk500boot.c  **** //#define _DEBUG_SERIAL_
 123:stk500boot.c  **** 
 124:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 125:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 126:stk500boot.c  **** #undef		ENABLE_MONITOR
 127:stk500boot.c  **** #define		ENABLE_MONITOR
 128:stk500boot.c  **** #endif
 129:stk500boot.c  **** 
 130:stk500boot.c  **** #ifndef EEWE
 131:stk500boot.c  **** #define EEWE    1
 132:stk500boot.c  **** #endif
 133:stk500boot.c  **** #ifndef EEMWE
 134:stk500boot.c  **** #define EEMWE   2
 135:stk500boot.c  **** #endif
 136:stk500boot.c  **** 
 137:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 138:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 139:stk500boot.c  **** 
 140:stk500boot.c  **** /*
 141:stk500boot.c  ****  * Uncomment the following lines to save code space
 142:stk500boot.c  ****  */
 143:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 144:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 145:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 146:stk500boot.c  **** //
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 149:stk500boot.c  **** //*	indicates that bootloader is active
 150:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 151:stk500boot.c  **** //************************************************************************
 152:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 153:stk500boot.c  **** 
 154:stk500boot.c  **** 
 155:stk500boot.c  **** #define SPI_DDRA DDRA
 156:stk500boot.c  **** #define SPI_PORTA PORTA
 157:stk500boot.c  **** #define SPI_DDRB DDRB
 158:stk500boot.c  **** #define SPI_PORTB PORTB
 159:stk500boot.c  **** 
 160:stk500boot.c  **** #define SCK PINB1 //Pin 52
 161:stk500boot.c  **** #define MISO PINB3 //Pin 50
 162:stk500boot.c  **** #define MOSI PINB2 //Pin 51
 163:stk500boot.c  **** #define SS PINA0 //Pin 22
 164:stk500boot.c  **** //#define SS_MASTER PINB0 //Pin 53
 165:stk500boot.c  **** 
 166:stk500boot.c  **** #define SS_LOW() SPI_PORTA &= ~_BV(SS)
 167:stk500boot.c  **** #define SS_HIGH() SPI_PORTA |= _BV(SS)
 168:stk500boot.c  **** //#define SS_MASTER_LOW() SPI_PORTB &= ~_BV(SS_MASTER)
 169:stk500boot.c  **** //#define SS_MASTER_HIGH() SPI_PORTB |= _BV(SS_MASTER)
 170:stk500boot.c  **** 
 171:stk500boot.c  **** /*
 172:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 173:stk500boot.c  ****  */
 174:stk500boot.c  **** #ifndef F_CPU
 175:stk500boot.c  **** #define F_CPU 16000000UL
 176:stk500boot.c  **** #endif
 177:stk500boot.c  **** 
 178:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 179:stk500boot.c  **** /*
 180:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 181:stk500boot.c  ****  */
 182:stk500boot.c  **** 
 183:stk500boot.c  **** #ifndef BAUDRATE
 184:stk500boot.c  **** #define BAUDRATE 115200
 185:stk500boot.c  **** #endif
 186:stk500boot.c  **** 
 187:stk500boot.c  **** /*
 188:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 189:stk500boot.c  ****  */
 190:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 191:stk500boot.c  **** #if defined (__AVR_ATmega32__)
 192:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 0
 193:stk500boot.c  **** #else
 194:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 1
 195:stk500boot.c  **** #endif
 196:stk500boot.c  **** #endif
 197:stk500boot.c  **** 
 198:stk500boot.c  **** /*
 199:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 200:stk500boot.c  ****  */
 201:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 202:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 203:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 204:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 205:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 206:stk500boot.c  **** 
 207:stk500boot.c  **** /*
 208:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 209:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 210:stk500boot.c  ****  */
 211:stk500boot.c  **** //#define BOOTSIZE 1024
 212:stk500boot.c  **** #if FLASHEND > 0x0F000
 213:stk500boot.c  **** #define BOOTSIZE 8192
 214:stk500boot.c  **** #else
 215:stk500boot.c  **** #define BOOTSIZE 2048
 216:stk500boot.c  **** #endif
 217:stk500boot.c  **** 
 218:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 219:stk500boot.c  **** 
 220:stk500boot.c  **** /*
 221:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 222:stk500boot.c  ****  */
 223:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 224:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9307
 225:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 226:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9403
 227:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 228:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9502
 229:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 230:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9306
 231:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 232:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9308
 233:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 234:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9404
 235:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 236:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9702
 237:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 238:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9703
 239:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 240:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9801
 241:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 242:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9802
 243:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 244:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9705
 245:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 246:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9608
 247:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 248:stk500boot.c  **** #define SIGNATURE_BYTES  0x1E9602
 249:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 250:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9405
 251:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 252:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9782
 253:stk500boot.c  **** #else
 254:stk500boot.c  **** #error "no signature definition for MCU available"
 255:stk500boot.c  **** #endif
 256:stk500boot.c  **** 
 257:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 258:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR1L
 259:stk500boot.c  **** #define	UART_STATUS_REG				UCSR1A
 260:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR1B
 261:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN1
 262:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN1
 263:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC1
 264:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC1
 265:stk500boot.c  **** #define	UART_DATA_REG				UDR1
 266:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X1
 267:stk500boot.c  **** 
 268:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 269:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 270:stk500boot.c  **** /* ATMega8 with one USART */
 271:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 272:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 273:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 274:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 275:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 276:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 277:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 278:stk500boot.c  **** #define	UART_DATA_REG				UDR
 279:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 280:stk500boot.c  **** 
 281:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 282:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 283:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 284:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 285:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 286:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 287:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 288:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 289:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 290:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 291:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 292:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 293:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 294:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 295:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 296:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 297:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 298:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 299:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 300:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 301:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 302:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 303:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 304:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 305:stk500boot.c  **** //* catch all
 306:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 307:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 308:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 309:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 310:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 311:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 312:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 313:stk500boot.c  **** #define	UART_DATA_REG				UDR
 314:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 315:stk500boot.c  **** #else
 316:stk500boot.c  **** #error "no UART definition for MCU available"
 317:stk500boot.c  **** #endif
 318:stk500boot.c  **** 
 319:stk500boot.c  **** #define SPI_MODE_MASK 0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
 320:stk500boot.c  **** #define SPI_CLOCK_MASK 0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
 321:stk500boot.c  **** #define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR
 322:stk500boot.c  **** 
 323:stk500boot.c  **** #define LSBFIRST 0
 324:stk500boot.c  **** #define MSBFIRST 1
 325:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
 326:stk500boot.c  **** 	SPDR = _data;
 327:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
 328:stk500boot.c  **** 		;
 329:stk500boot.c  **** 	return SPDR;
 330:stk500boot.c  **** }
 331:stk500boot.c  **** void setDataMode(uint8_t mode) {
 332:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
 333:stk500boot.c  **** }
 334:stk500boot.c  **** 
 335:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
 336:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
 337:stk500boot.c  **** 		SPCR |= _BV(DORD);
 338:stk500boot.c  **** 	} else {
 339:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 340:stk500boot.c  **** 	}
 341:stk500boot.c  **** }
 342:stk500boot.c  **** 
 343:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 344:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 345:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 346:stk500boot.c  **** }
 347:stk500boot.c  **** 
 348:stk500boot.c  **** /// return the STATUS register
 349:stk500boot.c  **** #define SPIFLASH_STATUSREAD       0x05
 350:stk500boot.c  **** uint8_t readStatus() {
 351:stk500boot.c  **** 	SS_LOW();
 352:stk500boot.c  **** //	SS_MASTER_HIGH();
 353:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 354:stk500boot.c  **** 	uint8_t status = transfer(0);
 355:stk500boot.c  **** 	SS_HIGH();
 356:stk500boot.c  **** //	SS_MASTER_LOW();
 357:stk500boot.c  **** 	return status;
 358:stk500boot.c  **** }
 359:stk500boot.c  **** uint8_t busy() {
 360:stk500boot.c  **** 	return readStatus() & 1;
 361:stk500boot.c  **** }
 362:stk500boot.c  **** 
 363:stk500boot.c  **** void command(uint8_t cmd) {
 364:stk500boot.c  **** 
 365:stk500boot.c  **** 	while (busy())
 366:stk500boot.c  **** 		; //wait for any write/erase to complete
 367:stk500boot.c  **** 	SS_LOW();
 368:stk500boot.c  **** 	transfer(cmd);
 369:stk500boot.c  **** }
 370:stk500boot.c  **** 
 371:stk500boot.c  **** #define SPIFLASH_ARRAYREADLOWFREQ 0x03
 372:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 373:stk500boot.c  **** 	SS_LOW();
 374:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 375:stk500boot.c  **** 	transfer(address >> 16);
 376:stk500boot.c  **** 	transfer(address >> 8);
 377:stk500boot.c  **** 	transfer(address);
 378:stk500boot.c  **** 	uint8_t result = transfer(0);
 379:stk500boot.c  **** 	SS_HIGH();
 380:stk500boot.c  **** 	return result;
 381:stk500boot.c  **** }
 382:stk500boot.c  **** 
 383:stk500boot.c  **** /*
 384:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 385:stk500boot.c  ****  */
 386:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 387:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 388:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 389:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 390:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 391:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 392:stk500boot.c  **** #else
 393:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 394:stk500boot.c  **** #endif
 395:stk500boot.c  **** 
 396:stk500boot.c  **** /*
 397:stk500boot.c  ****  * States used in the receive state machine
 398:stk500boot.c  ****  */
 399:stk500boot.c  **** #define	ST_START		0
 400:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 401:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 402:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 403:stk500boot.c  **** #define ST_GET_TOKEN	4
 404:stk500boot.c  **** #define ST_GET_DATA		5
 405:stk500boot.c  **** #define	ST_GET_CHECK	6
 406:stk500boot.c  **** #define	ST_PROCESS		7
 407:stk500boot.c  **** 
 408:stk500boot.c  **** /*
 409:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 410:stk500boot.c  ****  */
 411:stk500boot.c  **** #if defined(RAMPZ)
 412:stk500boot.c  **** typedef uint32_t address_t;
 413:stk500boot.c  **** #else
 414:stk500boot.c  **** typedef uint16_t address_t;
 415:stk500boot.c  **** #endif
 416:stk500boot.c  **** 
 417:stk500boot.c  **** /*
 418:stk500boot.c  ****  * function prototypes
 419:stk500boot.c  ****  */
 420:stk500boot.c  **** static void sendchar(char c);
 421:stk500boot.c  **** 
 422:stk500boot.c  **** // SDCARD BOOTLOADER
 423:stk500boot.c  **** 
 424:stk500boot.c  **** unsigned char Buff[SPM_PAGESIZE]; /* Page data buffer */
 425:stk500boot.c  **** 
 426:stk500boot.c  **** // SDCARD BOOTLOADER
 427:stk500boot.c  **** 
 428:stk500boot.c  **** /*
 429:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 430:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 431:stk500boot.c  ****  */
 432:stk500boot.c  **** void __jumpMain(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 433:stk500boot.c  **** #include <avr/sfr_defs.h>
 434:stk500boot.c  **** 
 435:stk500boot.c  **** //#define	SPH_REG	0x3E
 436:stk500boot.c  **** //#define	SPL_REG	0x3D
 437:stk500boot.c  **** 
 438:stk500boot.c  **** //*****************************************************************************
 439:stk500boot.c  **** void __jumpMain(void) {
 440:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 441:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 442:stk500boot.c  **** 
 443:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 444:stk500boot.c  **** 
 445:stk500boot.c  **** //*	set stack pointer to top of RAM
 446:stk500boot.c  **** 
 447:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 448:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 449:stk500boot.c  **** 
 450:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 451:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 452:stk500boot.c  **** 
 453:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 454:stk500boot.c  **** 	// GCC depends on register r1 set to 0
 455:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 456:stk500boot.c  **** 	// set SREG to 0
 457:stk500boot.c  **** 	asm volatile ( "jmp main");
 458:stk500boot.c  **** 	// jump to main()
 459:stk500boot.c  **** }
 460:stk500boot.c  **** 
 461:stk500boot.c  **** //*****************************************************************************
 462:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 463:stk500boot.c  **** 	unsigned int i;
 464:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 465:stk500boot.c  **** 		_delay_ms(0.5);
 466:stk500boot.c  **** 	}
 467:stk500boot.c  **** }
 468:stk500boot.c  **** 
 469:stk500boot.c  **** //*****************************************************************************
 470:stk500boot.c  **** /*
 471:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 472:stk500boot.c  ****  */
 473:stk500boot.c  **** static void sendchar(char c) {
  17               		.loc 1 473 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 474:stk500boot.c  **** 	UART_DATA_REG = c; // prepare transmission
  24               		.loc 1 474 0
  25 0000 8093 C600 		sts 198,r24
  26               	.LVL1:
  27               	.L2:
 475:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)))
  28               		.loc 1 475 0 discriminator 1
  29 0004 8091 C000 		lds r24,192
  30 0008 86FF      		sbrs r24,6
  31 000a 00C0      		rjmp .L2
 476:stk500boot.c  **** 		; // wait until byte sent
 477:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE); // delete TXCflag
  32               		.loc 1 477 0
  33 000c 8091 C000 		lds r24,192
  34 0010 8064      		ori r24,lo8(64)
  35 0012 8093 C000 		sts 192,r24
  36               	/* epilogue start */
 478:stk500boot.c  **** }
  37               		.loc 1 478 0
  38 0016 0895      		ret
  39               		.cfi_endproc
  40               	.LFE17:
  42               	.global	transfer
  44               	transfer:
  45               	.LFB7:
 325:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
  46               		.loc 1 325 0
  47               		.cfi_startproc
  48               	.LVL2:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 326:stk500boot.c  **** 	SPDR = _data;
  53               		.loc 1 326 0
  54 0018 8EBD      		out 78-32,r24
  55               	.L5:
 327:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
  56               		.loc 1 327 0 discriminator 1
  57 001a 0DB4      		in __tmp_reg__,77-32
  58 001c 07FE      		sbrs __tmp_reg__,7
  59 001e 00C0      		rjmp .L5
 329:stk500boot.c  **** 	return SPDR;
  60               		.loc 1 329 0
  61 0020 8EB5      		in r24,78-32
  62               	.LVL3:
  63               	/* epilogue start */
 330:stk500boot.c  **** }
  64               		.loc 1 330 0
  65 0022 0895      		ret
  66               		.cfi_endproc
  67               	.LFE7:
  69               	.global	setDataMode
  71               	setDataMode:
  72               	.LFB8:
 331:stk500boot.c  **** void setDataMode(uint8_t mode) {
  73               		.loc 1 331 0
  74               		.cfi_startproc
  75               	.LVL4:
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
 332:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
  80               		.loc 1 332 0
  81 0024 9CB5      		in r25,76-32
  82 0026 937F      		andi r25,lo8(-13)
  83 0028 982B      		or r25,r24
  84 002a 9CBD      		out 76-32,r25
  85               	/* epilogue start */
 333:stk500boot.c  **** }
  86               		.loc 1 333 0
  87 002c 0895      		ret
  88               		.cfi_endproc
  89               	.LFE8:
  91               	.global	setBitOrder
  93               	setBitOrder:
  94               	.LFB9:
 335:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
  95               		.loc 1 335 0
  96               		.cfi_startproc
  97               	.LVL5:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 336:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
 102               		.loc 1 336 0
 103 002e 8823      		tst r24
 104 0030 01F4      		brne .L9
 337:stk500boot.c  **** 		SPCR |= _BV(DORD);
 105               		.loc 1 337 0
 106 0032 8CB5      		in r24,76-32
 107               	.LVL6:
 108 0034 8062      		ori r24,lo8(32)
 109 0036 00C0      		rjmp .L11
 110               	.LVL7:
 111               	.L9:
 339:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 112               		.loc 1 339 0
 113 0038 8CB5      		in r24,76-32
 114               	.LVL8:
 115 003a 8F7D      		andi r24,lo8(-33)
 116               	.L11:
 117 003c 8CBD      		out 76-32,r24
 118 003e 0895      		ret
 119               		.cfi_endproc
 120               	.LFE9:
 122               	.global	setClockDivider
 124               	setClockDivider:
 125               	.LFB10:
 343:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 126               		.loc 1 343 0
 127               		.cfi_startproc
 128               	.LVL9:
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 0 */
 132               	.L__stack_usage = 0
 344:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 133               		.loc 1 344 0
 134 0040 2CB5      		in r18,76-32
 135 0042 982F      		mov r25,r24
 136 0044 9370      		andi r25,lo8(3)
 137 0046 2C7F      		andi r18,lo8(-4)
 138 0048 922B      		or r25,r18
 139 004a 9CBD      		out 76-32,r25
 345:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 140               		.loc 1 345 0
 141 004c 9DB5      		in r25,77-32
 142 004e 8695      		lsr r24
 143 0050 8695      		lsr r24
 144               	.LVL10:
 145 0052 8170      		andi r24,lo8(1)
 146 0054 9E7F      		andi r25,lo8(-2)
 147 0056 892B      		or r24,r25
 148 0058 8DBD      		out 77-32,r24
 149               	/* epilogue start */
 346:stk500boot.c  **** }
 150               		.loc 1 346 0
 151 005a 0895      		ret
 152               		.cfi_endproc
 153               	.LFE10:
 155               	.global	readStatus
 157               	readStatus:
 158               	.LFB11:
 350:stk500boot.c  **** uint8_t readStatus() {
 159               		.loc 1 350 0
 160               		.cfi_startproc
 161               	/* prologue: function */
 162               	/* frame size = 0 */
 163               	/* stack size = 0 */
 164               	.L__stack_usage = 0
 351:stk500boot.c  **** 	SS_LOW();
 165               		.loc 1 351 0
 166 005c 1098      		cbi 34-32,0
 353:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 167               		.loc 1 353 0
 168 005e 85E0      		ldi r24,lo8(5)
 169 0060 0E94 0000 		call transfer
 354:stk500boot.c  **** 	uint8_t status = transfer(0);
 170               		.loc 1 354 0
 171 0064 80E0      		ldi r24,lo8(0)
 172 0066 0E94 0000 		call transfer
 173               	.LVL11:
 355:stk500boot.c  **** 	SS_HIGH();
 174               		.loc 1 355 0
 175 006a 109A      		sbi 34-32,0
 176               	/* epilogue start */
 358:stk500boot.c  **** }
 177               		.loc 1 358 0
 178 006c 0895      		ret
 179               		.cfi_endproc
 180               	.LFE11:
 182               	.global	busy
 184               	busy:
 185               	.LFB12:
 359:stk500boot.c  **** uint8_t busy() {
 186               		.loc 1 359 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 360:stk500boot.c  **** 	return readStatus() & 1;
 192               		.loc 1 360 0
 193 006e 0E94 0000 		call readStatus
 361:stk500boot.c  **** }
 194               		.loc 1 361 0
 195 0072 8170      		andi r24,lo8(1)
 196               	/* epilogue start */
 197 0074 0895      		ret
 198               		.cfi_endproc
 199               	.LFE12:
 201               	.global	command
 203               	command:
 204               	.LFB13:
 363:stk500boot.c  **** void command(uint8_t cmd) {
 205               		.loc 1 363 0
 206               		.cfi_startproc
 207               	.LVL12:
 208 0076 CF93      		push r28
 209               	.LCFI0:
 210               		.cfi_def_cfa_offset 4
 211               		.cfi_offset 28, -3
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 1 */
 215               	.L__stack_usage = 1
 216 0078 C82F      		mov r28,r24
 217               	.LVL13:
 218               	.L16:
 365:stk500boot.c  **** 	while (busy())
 219               		.loc 1 365 0 discriminator 1
 220 007a 0E94 0000 		call busy
 221 007e 8823      		tst r24
 222 0080 01F4      		brne .L16
 367:stk500boot.c  **** 	SS_LOW();
 223               		.loc 1 367 0
 224 0082 1098      		cbi 34-32,0
 368:stk500boot.c  **** 	transfer(cmd);
 225               		.loc 1 368 0
 226 0084 8C2F      		mov r24,r28
 227 0086 0E94 0000 		call transfer
 228               	/* epilogue start */
 369:stk500boot.c  **** }
 229               		.loc 1 369 0
 230 008a CF91      		pop r28
 231               	.LVL14:
 232 008c 0895      		ret
 233               		.cfi_endproc
 234               	.LFE13:
 236               	.global	spiReadReg
 238               	spiReadReg:
 239               	.LFB14:
 372:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 240               		.loc 1 372 0
 241               		.cfi_startproc
 242               	.LVL15:
 243 008e 1F93      		push r17
 244               	.LCFI1:
 245               		.cfi_def_cfa_offset 4
 246               		.cfi_offset 17, -3
 247 0090 CF93      		push r28
 248               	.LCFI2:
 249               		.cfi_def_cfa_offset 5
 250               		.cfi_offset 28, -4
 251 0092 DF93      		push r29
 252               	.LCFI3:
 253               		.cfi_def_cfa_offset 6
 254               		.cfi_offset 29, -5
 255 0094 0F92      		push __tmp_reg__
 256 0096 0F92      		push __tmp_reg__
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 8
 259 0098 CDB7      		in r28,__SP_L__
 260 009a DEB7      		in r29,__SP_H__
 261               	.LCFI5:
 262               		.cfi_def_cfa_register 28
 263               	/* prologue: function */
 264               	/* frame size = 2 */
 265               	/* stack size = 5 */
 266               	.L__stack_usage = 5
 267 009c 182F      		mov r17,r24
 373:stk500boot.c  **** 	SS_LOW();
 268               		.loc 1 373 0
 269 009e 1098      		cbi 34-32,0
 374:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 270               		.loc 1 374 0
 271 00a0 83E0      		ldi r24,lo8(3)
 272 00a2 6A83      		std Y+2,r22
 273 00a4 7983      		std Y+1,r23
 274 00a6 0E94 0000 		call command
 275               	.LVL16:
 375:stk500boot.c  **** 	transfer(address >> 16);
 276               		.loc 1 375 0
 277 00aa 812F      		mov r24,r17
 278 00ac 0E94 0000 		call transfer
 376:stk500boot.c  **** 	transfer(address >> 8);
 279               		.loc 1 376 0
 280 00b0 7981      		ldd r23,Y+1
 281 00b2 872F      		mov r24,r23
 282 00b4 0E94 0000 		call transfer
 377:stk500boot.c  **** 	transfer(address);
 283               		.loc 1 377 0
 284 00b8 6A81      		ldd r22,Y+2
 285 00ba 862F      		mov r24,r22
 286 00bc 0E94 0000 		call transfer
 378:stk500boot.c  **** 	uint8_t result = transfer(0);
 287               		.loc 1 378 0
 288 00c0 80E0      		ldi r24,lo8(0)
 289 00c2 0E94 0000 		call transfer
 290               	.LVL17:
 379:stk500boot.c  **** 	SS_HIGH();
 291               		.loc 1 379 0
 292 00c6 109A      		sbi 34-32,0
 293               	/* epilogue start */
 381:stk500boot.c  **** }
 294               		.loc 1 381 0
 295 00c8 0F90      		pop __tmp_reg__
 296 00ca 0F90      		pop __tmp_reg__
 297 00cc DF91      		pop r29
 298 00ce CF91      		pop r28
 299 00d0 1F91      		pop r17
 300 00d2 0895      		ret
 301               		.cfi_endproc
 302               	.LFE14:
 304               		.section	.init9,"ax",@progbits
 305               	.global	__jumpMain
 307               	__jumpMain:
 308               	.LFB15:
 439:stk500boot.c  **** void __jumpMain(void) {
 309               		.loc 1 439 0
 310               		.cfi_startproc
 311               	/* prologue: naked */
 312               	/* frame size = 0 */
 313               	/* stack size = 0 */
 314               	.L__stack_usage = 0
 443:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 315               		.loc 1 443 0
 316               	/* #APP */
 317               	 ;  443 "stk500boot.c" 1
 318               		.set __stack, 8703
 319               	 ;  0 "" 2
 447:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 320               		.loc 1 447 0
 321               	 ;  447 "stk500boot.c" 1
 322 0000 01E2      		ldi	16, 33
 323               	 ;  0 "" 2
 448:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 324               		.loc 1 448 0
 325               	 ;  448 "stk500boot.c" 1
 326 0002 0EBF      		out 62,16
 327               	 ;  0 "" 2
 450:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 328               		.loc 1 450 0
 329               	 ;  450 "stk500boot.c" 1
 330 0004 0FEF      		ldi	16, 255
 331               	 ;  0 "" 2
 451:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 332               		.loc 1 451 0
 333               	 ;  451 "stk500boot.c" 1
 334 0006 0DBF      		out 61,16
 335               	 ;  0 "" 2
 453:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 336               		.loc 1 453 0
 337               	 ;  453 "stk500boot.c" 1
 338 0008 1124      		clr __zero_reg__
 339               	 ;  0 "" 2
 455:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 340               		.loc 1 455 0
 341               	 ;  455 "stk500boot.c" 1
 342 000a 1FBE      		out 63, __zero_reg__
 343               	 ;  0 "" 2
 457:stk500boot.c  **** 	asm volatile ( "jmp main");
 344               		.loc 1 457 0
 345               	 ;  457 "stk500boot.c" 1
 346 000c 0C94 0000 		jmp main
 347               	 ;  0 "" 2
 348               	/* epilogue start */
 459:stk500boot.c  **** }
 349               		.loc 1 459 0
 350               	/* #NOAPP */
 351               		.cfi_endproc
 352               	.LFE15:
 354               		.text
 355               	.global	delay_ms
 357               	delay_ms:
 358               	.LFB16:
 462:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 359               		.loc 1 462 0
 360               		.cfi_startproc
 361               	.LVL18:
 362               	/* prologue: function */
 363               	/* frame size = 0 */
 364               	/* stack size = 0 */
 365               	.L__stack_usage = 0
 464:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 366               		.loc 1 464 0
 367 00d4 20E0      		ldi r18,lo8(0)
 368 00d6 30E0      		ldi r19,hi8(0)
 369 00d8 00C0      		rjmp .L21
 370               	.LVL19:
 371               	.L22:
 372               	.LBB32:
 373               	.LBB33:
 374               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 375               		.loc 2 164 0
 376 00da EFEC      		 ldi r30,lo8(1999)
 377 00dc F7E0      	    ldi r31,hi8(1999)
 378 00de 3197      	    1:sbiw r30,1
 379 00e0 01F4      	    brne 1b
 380 00e2 00C0      		rjmp .
 381 00e4 0000      		nop
 382               	.LBE33:
 383               	.LBE32:
 464:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 384               		.loc 1 464 0
 385 00e6 2F5F      		subi r18,lo8(-(1))
 386 00e8 3F4F      		sbci r19,hi8(-(1))
 387               	.LVL20:
 388               	.L21:
 464:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 389               		.loc 1 464 0 is_stmt 0 discriminator 1
 390 00ea 2817      		cp r18,r24
 391 00ec 3907      		cpc r19,r25
 392 00ee 01F4      		brne .L22
 393               	/* epilogue start */
 467:stk500boot.c  **** }
 394               		.loc 1 467 0 is_stmt 1
 395 00f0 0895      		ret
 396               		.cfi_endproc
 397               	.LFE16:
 399               	.global	dec_hex
 401               	dec_hex:
 402               	.LFB20:
 479:stk500boot.c  **** 
 480:stk500boot.c  **** //************************************************************************
 481:stk500boot.c  **** static int Serial_Available(void) {
 482:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 483:stk500boot.c  **** }
 484:stk500boot.c  **** 
 485:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 486:stk500boot.c  **** //*****************************************************************************
 487:stk500boot.c  **** static unsigned char recchar_timeout(void) {
 488:stk500boot.c  **** 	uint32_t count = 0;
 489:stk500boot.c  **** 
 490:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 491:stk500boot.c  **** 		// wait for data
 492:stk500boot.c  **** 		count++;
 493:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 494:stk500boot.c  **** 			unsigned int data;
 495:stk500boot.c  **** #if (FLASHEND > 0x10000)
 496:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 497:stk500boot.c  **** #else
 498:stk500boot.c  **** 			data = pgm_read_word_near(0); //*	get the first word of the user program
 499:stk500boot.c  **** #endif
 500:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 501:stk500boot.c  **** 					{
 502:stk500boot.c  **** 				asm volatile(
 503:stk500boot.c  **** 						"clr	r30		\n\t"
 504:stk500boot.c  **** 						"clr	r31		\n\t"
 505:stk500boot.c  **** 						"ijmp	\n\t"
 506:stk500boot.c  **** 				);
 507:stk500boot.c  **** 			}
 508:stk500boot.c  **** 			count = 0;
 509:stk500boot.c  **** 		}
 510:stk500boot.c  **** 	}
 511:stk500boot.c  **** 	return UART_DATA_REG;
 512:stk500boot.c  **** }
 513:stk500boot.c  **** 
 514:stk500boot.c  **** 
 515:stk500boot.c  **** void dec_hex(long int num)   // Function Definition
 516:stk500boot.c  **** {
 403               		.loc 1 516 0
 404               		.cfi_startproc
 405               	.LVL21:
 406 00f2 CF92      		push r12
 407               	.LCFI6:
 408               		.cfi_def_cfa_offset 4
 409               		.cfi_offset 12, -3
 410 00f4 DF92      		push r13
 411               	.LCFI7:
 412               		.cfi_def_cfa_offset 5
 413               		.cfi_offset 13, -4
 414 00f6 EF92      		push r14
 415               	.LCFI8:
 416               		.cfi_def_cfa_offset 6
 417               		.cfi_offset 14, -5
 418 00f8 FF92      		push r15
 419               	.LCFI9:
 420               		.cfi_def_cfa_offset 7
 421               		.cfi_offset 15, -6
 422 00fa CF93      		push r28
 423               	.LCFI10:
 424               		.cfi_def_cfa_offset 8
 425               		.cfi_offset 28, -7
 426 00fc DF93      		push r29
 427               	.LCFI11:
 428               		.cfi_def_cfa_offset 9
 429               		.cfi_offset 29, -8
 430 00fe CDB7      		in r28,__SP_L__
 431 0100 DEB7      		in r29,__SP_H__
 432 0102 C85C      		subi r28,lo8(-(-200))
 433 0104 D040      		sbci r29,hi8(-(-200))
 434               	.LCFI12:
 435               		.cfi_def_cfa 28, 209
 436 0106 0FB6      		in __tmp_reg__,__SREG__
 437 0108 F894      		cli
 438 010a DEBF      		out __SP_H__,r29
 439 010c 0FBE      		out __SREG__,__tmp_reg__
 440 010e CDBF      		out __SP_L__,r28
 441               	/* prologue: function */
 442               	/* frame size = 200 */
 443               	/* stack size = 206 */
 444               	.L__stack_usage = 206
 445 0110 6B01      		movw r12,r22
 446 0112 7C01      		movw r14,r24
 447               	.LVL22:
 517:stk500boot.c  **** long int rem[50],i=0,length=0;
 518:stk500boot.c  **** if(num == 0){
 448               		.loc 1 518 0
 449 0114 6115      		cp r22,__zero_reg__
 450 0116 7105      		cpc r23,__zero_reg__
 451 0118 8105      		cpc r24,__zero_reg__
 452 011a 9105      		cpc r25,__zero_reg__
 453 011c 01F4      		brne .L24
 454               	.LVL23:
 519:stk500boot.c  **** 	sendchar('0');
 455               		.loc 1 519 0
 456 011e 80E3      		ldi r24,lo8(48)
 457 0120 0E94 0000 		call sendchar
 520:stk500boot.c  **** 	sendchar('0');
 458               		.loc 1 520 0
 459 0124 80E3      		ldi r24,lo8(48)
 460 0126 0E94 0000 		call sendchar
 461               	.L24:
 462               		.loc 1 520 0 is_stmt 0 discriminator 1
 463 012a FE01      		movw r30,r28
 464 012c 3196      		adiw r30,1
 516:stk500boot.c  **** {
 465               		.loc 1 516 0 is_stmt 1 discriminator 1
 466 012e 80E0      		ldi r24,lo8(0)
 467 0130 90E0      		ldi r25,hi8(0)
 468 0132 DC01      		movw r26,r24
 469 0134 00C0      		rjmp .L25
 470               	.LVL24:
 471               	.L26:
 521:stk500boot.c  **** }
 522:stk500boot.c  **** while(num>0)
 523:stk500boot.c  ****    {
 524:stk500boot.c  ****       rem[i]=num%16;
 472               		.loc 1 524 0
 473 0136 B701      		movw r22,r14
 474 0138 A601      		movw r20,r12
 475 013a 4F70      		andi r20,lo8(15)
 476 013c 5070      		andi r21,hi8(15)
 477 013e 6070      		andi r22,hlo8(15)
 478 0140 7070      		andi r23,hhi8(15)
 479 0142 4193      		st Z+,r20
 480 0144 5193      		st Z+,r21
 481 0146 6193      		st Z+,r22
 482 0148 7193      		st Z+,r23
 525:stk500boot.c  ****       num=num/16;
 483               		.loc 1 525 0
 484 014a 24E0      		ldi r18,4
 485 014c F594      	1:	asr r15
 486 014e E794      		ror r14
 487 0150 D794      		ror r13
 488 0152 C794      		ror r12
 489 0154 2A95      		dec r18
 490 0156 01F4      		brne 1b
 491               	.LVL25:
 526:stk500boot.c  ****       i++;
 492               		.loc 1 526 0
 493 0158 0196      		adiw r24,1
 494 015a A11D      		adc r26,__zero_reg__
 495 015c B11D      		adc r27,__zero_reg__
 496               	.LVL26:
 497               	.L25:
 522:stk500boot.c  **** while(num>0)
 498               		.loc 1 522 0 discriminator 1
 499 015e 1C14      		cp __zero_reg__,r12
 500 0160 1D04      		cpc __zero_reg__,r13
 501 0162 1E04      		cpc __zero_reg__,r14
 502 0164 1F04      		cpc __zero_reg__,r15
 503 0166 04F0      		brlt .L26
 527:stk500boot.c  ****       length++;
 528:stk500boot.c  ****    }
 529:stk500boot.c  **** 
 530:stk500boot.c  **** for(i=length-1;i>=0;i--)
 504               		.loc 1 530 0
 505 0168 6C01      		movw r12,r24
 506 016a 7D01      		movw r14,r26
 507               	.LVL27:
 508 016c 00C0      		rjmp .L53
 509               	.LVL28:
 510               	.L49:
 515:stk500boot.c  **** void dec_hex(long int num)   // Function Definition
 511               		.loc 1 515 0
 512 016e F601      		movw r30,r12
 513 0170 EE0F      		lsl r30
 514 0172 FF1F      		rol r31
 515 0174 EE0F      		lsl r30
 516 0176 FF1F      		rol r31
 517 0178 81E0      		ldi r24,lo8(1)
 518 017a 90E0      		ldi r25,hi8(1)
 519 017c 8C0F      		add r24,r28
 520 017e 9D1F      		adc r25,r29
 521 0180 E80F      		add r30,r24
 522 0182 F91F      		adc r31,r25
 531:stk500boot.c  ****   {
 532:stk500boot.c  ****     switch(rem[i])
 523               		.loc 1 532 0
 524 0184 8081      		ld r24,Z
 525 0186 9181      		ldd r25,Z+1
 526 0188 A281      		ldd r26,Z+2
 527 018a B381      		ldd r27,Z+3
 528 018c 8730      		cpi r24,lo8(7)
 529 018e 9105      		cpc r25,__zero_reg__
 530 0190 A105      		cpc r26,__zero_reg__
 531 0192 B105      		cpc r27,__zero_reg__
 532 0194 01F4      		brne .+2
 533 0196 00C0      		rjmp .L36
 534 0198 8830      		cpi r24,lo8(8)
 535 019a 9105      		cpc r25,__zero_reg__
 536 019c A105      		cpc r26,__zero_reg__
 537 019e B105      		cpc r27,__zero_reg__
 538 01a0 04F4      		brge .L45
 539 01a2 8330      		cpi r24,lo8(3)
 540 01a4 9105      		cpc r25,__zero_reg__
 541 01a6 A105      		cpc r26,__zero_reg__
 542 01a8 B105      		cpc r27,__zero_reg__
 543 01aa 01F4      		brne .+2
 544 01ac 00C0      		rjmp .L32
 545 01ae 8430      		cpi r24,lo8(4)
 546 01b0 9105      		cpc r25,__zero_reg__
 547 01b2 A105      		cpc r26,__zero_reg__
 548 01b4 B105      		cpc r27,__zero_reg__
 549 01b6 04F4      		brge .L46
 550 01b8 8130      		cpi r24,lo8(1)
 551 01ba 9105      		cpc r25,__zero_reg__
 552 01bc A105      		cpc r26,__zero_reg__
 553 01be B105      		cpc r27,__zero_reg__
 554 01c0 01F4      		brne .+2
 555 01c2 00C0      		rjmp .L30
 556 01c4 8230      		cpi r24,lo8(2)
 557 01c6 9105      		cpc r25,__zero_reg__
 558 01c8 A105      		cpc r26,__zero_reg__
 559 01ca B105      		cpc r27,__zero_reg__
 560 01cc 04F0      		brlt .+2
 561 01ce 00C0      		rjmp .L31
 562 01d0 0097      		sbiw r24,0
 563 01d2 A105      		cpc r26,__zero_reg__
 564 01d4 B105      		cpc r27,__zero_reg__
 565 01d6 01F0      		breq .L29
 566 01d8 00C0      		rjmp .L28
 567               	.L46:
 568 01da 8530      		cpi r24,lo8(5)
 569 01dc 9105      		cpc r25,__zero_reg__
 570 01de A105      		cpc r26,__zero_reg__
 571 01e0 B105      		cpc r27,__zero_reg__
 572 01e2 01F0      		breq .L34
 573 01e4 8630      		cpi r24,lo8(6)
 574 01e6 9105      		cpc r25,__zero_reg__
 575 01e8 A105      		cpc r26,__zero_reg__
 576 01ea B105      		cpc r27,__zero_reg__
 577 01ec 04F4      		brge .L35
 578 01ee 00C0      		rjmp .L54
 579               	.L45:
 580 01f0 8B30      		cpi r24,lo8(11)
 581 01f2 9105      		cpc r25,__zero_reg__
 582 01f4 A105      		cpc r26,__zero_reg__
 583 01f6 B105      		cpc r27,__zero_reg__
 584 01f8 01F0      		breq .L40
 585 01fa 8C30      		cpi r24,lo8(12)
 586 01fc 9105      		cpc r25,__zero_reg__
 587 01fe A105      		cpc r26,__zero_reg__
 588 0200 B105      		cpc r27,__zero_reg__
 589 0202 04F4      		brge .L47
 590 0204 8930      		cpi r24,lo8(9)
 591 0206 9105      		cpc r25,__zero_reg__
 592 0208 A105      		cpc r26,__zero_reg__
 593 020a B105      		cpc r27,__zero_reg__
 594 020c 01F0      		breq .L38
 595 020e 8A30      		cpi r24,lo8(10)
 596 0210 9105      		cpc r25,__zero_reg__
 597 0212 A105      		cpc r26,__zero_reg__
 598 0214 B105      		cpc r27,__zero_reg__
 599 0216 04F4      		brge .L39
 600 0218 00C0      		rjmp .L55
 601               	.L47:
 602 021a 8D30      		cpi r24,lo8(13)
 603 021c 9105      		cpc r25,__zero_reg__
 604 021e A105      		cpc r26,__zero_reg__
 605 0220 B105      		cpc r27,__zero_reg__
 606 0222 01F0      		breq .L42
 607 0224 8D30      		cpi r24,lo8(13)
 608 0226 9105      		cpc r25,__zero_reg__
 609 0228 A105      		cpc r26,__zero_reg__
 610 022a B105      		cpc r27,__zero_reg__
 611 022c 04F0      		brlt .L41
 612 022e 8E30      		cpi r24,lo8(14)
 613 0230 9105      		cpc r25,__zero_reg__
 614 0232 A105      		cpc r26,__zero_reg__
 615 0234 B105      		cpc r27,__zero_reg__
 616 0236 01F0      		breq .L43
 617 0238 8F30      		cpi r24,lo8(15)
 618 023a 9105      		cpc r25,__zero_reg__
 619 023c A105      		cpc r26,__zero_reg__
 620 023e B105      		cpc r27,__zero_reg__
 621 0240 01F4      		brne .L28
 622 0242 00C0      		rjmp .L56
 623               	.L29:
 533:stk500boot.c  ****     {
 534:stk500boot.c  ****     case 0:
 535:stk500boot.c  ****         sendchar('0');
 624               		.loc 1 535 0
 625 0244 80E3      		ldi r24,lo8(48)
 626 0246 00C0      		rjmp .L52
 627               	.L30:
 536:stk500boot.c  ****         break;
 537:stk500boot.c  ****     case 1:
 538:stk500boot.c  ****         sendchar('1');
 628               		.loc 1 538 0
 629 0248 81E3      		ldi r24,lo8(49)
 630 024a 00C0      		rjmp .L52
 631               	.L31:
 539:stk500boot.c  ****         break;
 540:stk500boot.c  ****     case 2:
 541:stk500boot.c  ****         sendchar('2');
 632               		.loc 1 541 0
 633 024c 82E3      		ldi r24,lo8(50)
 634 024e 00C0      		rjmp .L52
 635               	.L32:
 542:stk500boot.c  ****         break;
 543:stk500boot.c  ****     case 3:
 544:stk500boot.c  ****         sendchar('3');
 636               		.loc 1 544 0
 637 0250 83E3      		ldi r24,lo8(51)
 638 0252 00C0      		rjmp .L52
 639               	.L54:
 545:stk500boot.c  ****         break;
 546:stk500boot.c  ****     case 4:
 547:stk500boot.c  ****         sendchar('4');
 640               		.loc 1 547 0
 641 0254 84E3      		ldi r24,lo8(52)
 642 0256 00C0      		rjmp .L52
 643               	.L34:
 548:stk500boot.c  ****         break;
 549:stk500boot.c  ****     case 5:
 550:stk500boot.c  ****         sendchar('5');
 644               		.loc 1 550 0
 645 0258 85E3      		ldi r24,lo8(53)
 646 025a 00C0      		rjmp .L52
 647               	.L35:
 551:stk500boot.c  ****         break;
 552:stk500boot.c  ****     case 6:
 553:stk500boot.c  ****         sendchar('6');
 648               		.loc 1 553 0
 649 025c 86E3      		ldi r24,lo8(54)
 650 025e 00C0      		rjmp .L52
 651               	.L36:
 554:stk500boot.c  ****         break;
 555:stk500boot.c  ****     case 7:
 556:stk500boot.c  ****         sendchar('7');
 652               		.loc 1 556 0
 653 0260 87E3      		ldi r24,lo8(55)
 654 0262 00C0      		rjmp .L52
 655               	.L55:
 557:stk500boot.c  ****         break;
 558:stk500boot.c  ****     case 8:
 559:stk500boot.c  ****         sendchar('8');
 656               		.loc 1 559 0
 657 0264 88E3      		ldi r24,lo8(56)
 658 0266 00C0      		rjmp .L52
 659               	.L38:
 560:stk500boot.c  ****         break;
 561:stk500boot.c  ****     case 9:
 562:stk500boot.c  ****         sendchar('9');
 660               		.loc 1 562 0
 661 0268 89E3      		ldi r24,lo8(57)
 662 026a 00C0      		rjmp .L52
 663               	.L39:
 563:stk500boot.c  ****         break;
 564:stk500boot.c  ****       case 10:
 565:stk500boot.c  ****           sendchar('A');
 664               		.loc 1 565 0
 665 026c 81E4      		ldi r24,lo8(65)
 666 026e 00C0      		rjmp .L52
 667               	.L40:
 566:stk500boot.c  ****           break;
 567:stk500boot.c  ****       case 11:
 568:stk500boot.c  ****     	  sendchar('B');
 668               		.loc 1 568 0
 669 0270 82E4      		ldi r24,lo8(66)
 670 0272 00C0      		rjmp .L52
 671               	.L41:
 569:stk500boot.c  ****           break;
 570:stk500boot.c  ****       case 12:
 571:stk500boot.c  ****     	  sendchar('C');
 672               		.loc 1 571 0
 673 0274 83E4      		ldi r24,lo8(67)
 674 0276 00C0      		rjmp .L52
 675               	.L42:
 572:stk500boot.c  ****           break;
 573:stk500boot.c  ****       case 13:
 574:stk500boot.c  ****     	  sendchar('D');
 676               		.loc 1 574 0
 677 0278 84E4      		ldi r24,lo8(68)
 678 027a 00C0      		rjmp .L52
 679               	.L43:
 575:stk500boot.c  ****           break;
 576:stk500boot.c  ****       case 14:
 577:stk500boot.c  ****     	  sendchar('E');
 680               		.loc 1 577 0
 681 027c 85E4      		ldi r24,lo8(69)
 682 027e 00C0      		rjmp .L52
 683               	.L56:
 578:stk500boot.c  ****           break;
 579:stk500boot.c  ****       case 15:
 580:stk500boot.c  ****     	  sendchar('F');
 684               		.loc 1 580 0
 685 0280 86E4      		ldi r24,lo8(70)
 686 0282 00C0      		rjmp .L52
 687               	.L28:
 581:stk500boot.c  ****           break;
 582:stk500boot.c  ****       default :
 583:stk500boot.c  ****          sendchar('X');
 688               		.loc 1 583 0
 689 0284 88E5      		ldi r24,lo8(88)
 690               	.L52:
 691 0286 0E94 0000 		call sendchar
 692               	.L53:
 530:stk500boot.c  **** for(i=length-1;i>=0;i--)
 693               		.loc 1 530 0
 694 028a 0894      		sec
 695 028c C108      		sbc r12,__zero_reg__
 696 028e D108      		sbc r13,__zero_reg__
 697 0290 E108      		sbc r14,__zero_reg__
 698 0292 F108      		sbc r15,__zero_reg__
 699               	.LVL29:
 700 0294 9FEF      		ldi r25,lo8(-1)
 701 0296 C916      		cp r12,r25
 702 0298 9FEF      		ldi r25,hi8(-1)
 703 029a D906      		cpc r13,r25
 704 029c 9FEF      		ldi r25,hlo8(-1)
 705 029e E906      		cpc r14,r25
 706 02a0 9FEF      		ldi r25,hhi8(-1)
 707 02a2 F906      		cpc r15,r25
 708 02a4 01F0      		breq .+2
 709 02a6 00C0      		rjmp .L49
 710               	/* epilogue start */
 584:stk500boot.c  ****          break;
 585:stk500boot.c  ****     }
 586:stk500boot.c  ****   }
 587:stk500boot.c  **** }
 711               		.loc 1 587 0
 712 02a8 C853      		subi r28,lo8(-(200))
 713 02aa DF4F      		sbci r29,hi8(-(200))
 714 02ac 0FB6      		in __tmp_reg__,__SREG__
 715 02ae F894      		cli
 716 02b0 DEBF      		out __SP_H__,r29
 717 02b2 0FBE      		out __SREG__,__tmp_reg__
 718 02b4 CDBF      		out __SP_L__,r28
 719 02b6 DF91      		pop r29
 720 02b8 CF91      		pop r28
 721 02ba FF90      		pop r15
 722 02bc EF90      		pop r14
 723 02be DF90      		pop r13
 724 02c0 CF90      		pop r12
 725               	.LVL30:
 726 02c2 0895      		ret
 727               		.cfi_endproc
 728               	.LFE20:
 730               		.section	.text.startup,"ax",@progbits
 731               	.global	main
 733               	main:
 734               	.LFB21:
 588:stk500boot.c  **** 
 589:stk500boot.c  **** 
 590:stk500boot.c  **** //*	for watch dog timer startup
 591:stk500boot.c  **** void (*app_start)(void) = 0;
 592:stk500boot.c  **** uint8_t check = 1;
 593:stk500boot.c  **** 
 594:stk500boot.c  **** //*****************************************************************************
 595:stk500boot.c  **** int main(void) {
 735               		.loc 1 595 0
 736               		.cfi_startproc
 737 0000 CF93      		push r28
 738               	.LCFI13:
 739               		.cfi_def_cfa_offset 4
 740               		.cfi_offset 28, -3
 741 0002 DF93      		push r29
 742               	.LCFI14:
 743               		.cfi_def_cfa_offset 5
 744               		.cfi_offset 29, -4
 745 0004 CDB7      		in r28,__SP_L__
 746 0006 DEB7      		in r29,__SP_H__
 747 0008 CF52      		subi r28,lo8(-(-303))
 748 000a D140      		sbci r29,hi8(-(-303))
 749               	.LCFI15:
 750               		.cfi_def_cfa 28, 308
 751 000c 0FB6      		in __tmp_reg__,__SREG__
 752 000e F894      		cli
 753 0010 DEBF      		out __SP_H__,r29
 754 0012 0FBE      		out __SREG__,__tmp_reg__
 755 0014 CDBF      		out __SP_L__,r28
 756               	/* prologue: function */
 757               	/* frame size = 303 */
 758               	/* stack size = 305 */
 759               	.L__stack_usage = 305
 596:stk500boot.c  **** 
 597:stk500boot.c  **** 	setDataMode(0x00);
 760               		.loc 1 597 0
 761 0016 80E0      		ldi r24,lo8(0)
 762 0018 0E94 0000 		call setDataMode
 598:stk500boot.c  **** 	setBitOrder(1);
 763               		.loc 1 598 0
 764 001c 81E0      		ldi r24,lo8(1)
 765 001e 0E94 0000 		call setBitOrder
 599:stk500boot.c  **** 	setClockDivider(0x04);
 766               		.loc 1 599 0
 767 0022 84E0      		ldi r24,lo8(4)
 768 0024 0E94 0000 		call setClockDivider
 600:stk500boot.c  **** 
 601:stk500boot.c  **** 	SPI_PORTA = _BV(SS);
 769               		.loc 1 601 0
 770 0028 81E0      		ldi r24,lo8(1)
 771 002a 82B9      		out 34-32,r24
 602:stk500boot.c  **** 	SPI_PORTB = _BV(SCK) | _BV(MISO) | _BV(MOSI);
 772               		.loc 1 602 0
 773 002c 9EE0      		ldi r25,lo8(14)
 774 002e 95B9      		out 37-32,r25
 603:stk500boot.c  **** 	SPI_DDRA = _BV(SS);
 775               		.loc 1 603 0
 776 0030 81B9      		out 33-32,r24
 604:stk500boot.c  **** 	SPI_DDRB = _BV(SCK) | _BV(MOSI);
 777               		.loc 1 604 0
 778 0032 86E0      		ldi r24,lo8(6)
 779 0034 84B9      		out 36-32,r24
 605:stk500boot.c  **** 
 606:stk500boot.c  **** 	SS_HIGH();
 780               		.loc 1 606 0
 781 0036 109A      		sbi 34-32,0
 607:stk500boot.c  **** //	SS_MASTER_HIGH();
 608:stk500boot.c  **** 
 609:stk500boot.c  **** 	SPCR |= _BV(MSTR);
 782               		.loc 1 609 0
 783 0038 8CB5      		in r24,76-32
 784 003a 8061      		ori r24,lo8(16)
 785 003c 8CBD      		out 76-32,r24
 610:stk500boot.c  **** 	SPCR |= _BV(SPE);
 786               		.loc 1 610 0
 787 003e 8CB5      		in r24,76-32
 788 0040 8064      		ori r24,lo8(64)
 789 0042 8CBD      		out 76-32,r24
 790               	.LVL31:
 611:stk500boot.c  **** 
 612:stk500boot.c  **** 	address_t address = 0;
 613:stk500boot.c  **** 	address_t eraseAddress = 0;
 614:stk500boot.c  **** 	unsigned char msgParseState;
 615:stk500boot.c  **** 	unsigned int ii = 0;
 616:stk500boot.c  **** 	unsigned char checksum = 0;
 617:stk500boot.c  **** 	unsigned char seqNum = 0;
 618:stk500boot.c  **** 	unsigned int msgLength = 0;
 619:stk500boot.c  **** 	unsigned char msgBuffer[285];
 620:stk500boot.c  **** 	unsigned char c, *p;
 621:stk500boot.c  **** 	unsigned char isLeave = 0;
 622:stk500boot.c  **** 
 623:stk500boot.c  **** 	unsigned long boot_timeout;
 624:stk500boot.c  **** 	unsigned long boot_timer;
 625:stk500boot.c  **** 	unsigned int boot_state;
 626:stk500boot.c  **** #ifdef ENABLE_MONITOR
 627:stk500boot.c  **** 	unsigned int exPointCntr = 0;
 628:stk500boot.c  **** 	unsigned int rcvdCharCntr = 0;
 629:stk500boot.c  **** #endif
 630:stk500boot.c  **** 
 631:stk500boot.c  **** 	//*	some chips dont set the stack properly
 632:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 791               		.loc 1 632 0
 792               	/* #APP */
 793               	 ;  632 "stk500boot.c" 1
 794               		.set __stack, 8703
 795               	 ;  0 "" 2
 633:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 796               		.loc 1 633 0
 797               	 ;  633 "stk500boot.c" 1
 798 0044 01E2      		ldi	16, 33
 799               	 ;  0 "" 2
 634:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 800               		.loc 1 634 0
 801               	 ;  634 "stk500boot.c" 1
 802 0046 0EBF      		out 62,16
 803               	 ;  0 "" 2
 635:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 804               		.loc 1 635 0
 805               	 ;  635 "stk500boot.c" 1
 806 0048 0FEF      		ldi	16, 255
 807               	 ;  0 "" 2
 636:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 808               		.loc 1 636 0
 809               	 ;  636 "stk500boot.c" 1
 810 004a 0DBF      		out 61,16
 811               	 ;  0 "" 2
 637:stk500boot.c  **** 
 638:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 639:stk500boot.c  **** 	//************************************************************************
 640:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 641:stk500boot.c  **** 	//*	handle the watch dog timer
 642:stk500boot.c  **** 	uint8_t mcuStatusReg;
 643:stk500boot.c  **** 	mcuStatusReg = MCUSR;
 812               		.loc 1 643 0
 813               	/* #NOAPP */
 814 004c 94B7      		in r25,84-32
 815               	.LVL32:
 644:stk500boot.c  **** 
 645:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 816               		.loc 1 645 0
 817               	/* #APP */
 818               	 ;  645 "stk500boot.c" 1
 819 004e F894      		cli
 820               	 ;  0 "" 2
 646:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 821               		.loc 1 646 0
 822               	 ;  646 "stk500boot.c" 1
 823 0050 A895      		wdr
 824               	 ;  0 "" 2
 647:stk500boot.c  **** 	MCUSR = 0;
 825               		.loc 1 647 0
 826               	/* #NOAPP */
 827 0052 14BE      		out 84-32,__zero_reg__
 648:stk500boot.c  **** 	WDTCSR |= _BV(WDCE) | _BV(WDE);
 828               		.loc 1 648 0
 829 0054 8091 6000 		lds r24,96
 830 0058 8861      		ori r24,lo8(24)
 831 005a 8093 6000 		sts 96,r24
 649:stk500boot.c  **** 	WDTCSR = 0;
 832               		.loc 1 649 0
 833 005e 1092 6000 		sts 96,__zero_reg__
 650:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 834               		.loc 1 650 0
 835               	/* #APP */
 836               	 ;  650 "stk500boot.c" 1
 837 0062 7894      		sei
 838               	 ;  0 "" 2
 651:stk500boot.c  **** 
 652:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 653:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF)) {
 839               		.loc 1 653 0
 840               	/* #NOAPP */
 841 0064 93FF      		sbrs r25,3
 842 0066 00C0      		rjmp .L58
 654:stk500boot.c  **** 		app_start();
 843               		.loc 1 654 0
 844 0068 E091 0000 		lds r30,app_start
 845 006c F091 0000 		lds r31,app_start+1
 846 0070 1995      		eicall
 847               	.LVL33:
 848               	.L58:
 655:stk500boot.c  **** 	}
 656:stk500boot.c  **** 	//************************************************************************
 657:stk500boot.c  **** #endif
 658:stk500boot.c  **** 
 659:stk500boot.c  **** 	boot_timer = 0;
 660:stk500boot.c  **** 	boot_state = 0;
 661:stk500boot.c  **** 
 662:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 663:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 664:stk500boot.c  **** //	boot_timeout	=	170000;
 665:stk500boot.c  **** 	boot_timeout = 100000; //*	should be about 1 second
 666:stk500boot.c  **** #else
 667:stk500boot.c  **** 			boot_timeout = 3500000; // 7 seconds , approx 2us per step when optimize "s"
 668:stk500boot.c  **** #endif
 669:stk500boot.c  **** 	/*
 670:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 671:stk500boot.c  **** 	 */
 672:stk500boot.c  **** 
 673:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 674:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 675:stk500boot.c  **** 			//PROGLED_DDR |= (1 << PROGLED_PIN);
 676:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 677:stk500boot.c  **** //	PROGLED_PORT |= (1 << PROGLED_PIN); // active high LED ON
 678:stk500boot.c  **** 
 679:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 680:stk500boot.c  **** //	for (ii=0; ii<3; ii++)
 681:stk500boot.c  **** //	{
 682:stk500boot.c  **** //		PROGLED_PORT &= ~(1<<PROGLED_PIN); // turn LED off
 683:stk500boot.c  **** //		delay_ms(100);
 684:stk500boot.c  **** //		PROGLED_PORT |= (1<<PROGLED_PIN);// turn LED on
 685:stk500boot.c  **** //		delay_ms(100);
 686:stk500boot.c  **** //	}
 687:stk500boot.c  **** #endif
 688:stk500boot.c  **** 
 689:stk500boot.c  **** #endif
 690:stk500boot.c  **** 
 691:stk500boot.c  **** 	/*
 692:stk500boot.c  **** 	 * Init UART
 693:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 694:stk500boot.c  **** 	 */
 695:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 696:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_DOUBLE_SPEED);
 849               		.loc 1 696 0
 850 0072 8091 C000 		lds r24,192
 851 0076 8260      		ori r24,lo8(2)
 852 0078 8093 C000 		sts 192,r24
 697:stk500boot.c  **** #endif
 698:stk500boot.c  **** 	UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
 853               		.loc 1 698 0
 854 007c 80E1      		ldi r24,lo8(16)
 855 007e 8093 C400 		sts 196,r24
 699:stk500boot.c  **** 	UART_CONTROL_REG = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 856               		.loc 1 699 0
 857 0082 88E1      		ldi r24,lo8(24)
 858 0084 8093 C100 		sts 193,r24
 700:stk500boot.c  **** 
 701:stk500boot.c  **** 	asm volatile ("nop");
 859               		.loc 1 701 0
 860               	/* #APP */
 861               	 ;  701 "stk500boot.c" 1
 862 0088 0000      		nop
 863               	 ;  0 "" 2
 659:stk500boot.c  **** 	boot_timer = 0;
 864               		.loc 1 659 0
 865               	/* #NOAPP */
 866 008a 40E0      		ldi r20,lo8(0)
 867 008c 50E0      		ldi r21,hi8(0)
 868 008e BA01      		movw r22,r20
 869 0090 00C0      		rjmp .L166
 870               	.LVL34:
 871               	.L62:
 872               	.LBB34:
 873               	.LBB35:
 874               		.loc 2 164 0
 875 0092 25E0      		 ldi r18,lo8(5)
 876 0094 2A95      	    1:dec r18
 877 0096 01F4      	    brne 1b
 878 0098 0000      		nop
 879               	.LBE35:
 880               	.LBE34:
 702:stk500boot.c  **** 	// wait until port has changed
 703:stk500boot.c  **** 
 704:stk500boot.c  **** //	sendchar('b');
 705:stk500boot.c  **** //    sendchar('o');
 706:stk500boot.c  **** //    sendchar('o');
 707:stk500boot.c  **** //    sendchar('t');
 708:stk500boot.c  **** //    sendchar('i');
 709:stk500boot.c  **** //    sendchar('n');
 710:stk500boot.c  **** //    sendchar('g');
 711:stk500boot.c  **** //    sendchar('.');
 712:stk500boot.c  **** //    sendchar('.');
 713:stk500boot.c  **** //    sendchar('.');
 714:stk500boot.c  **** //    sendchar(0x0d);
 715:stk500boot.c  **** //    sendchar(0x0a);
 716:stk500boot.c  **** //    delay_ms(100);
 717:stk500boot.c  **** 
 718:stk500boot.c  **** 	while (boot_state == 0) {
 719:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 720:stk500boot.c  **** 		{
 721:stk500boot.c  **** 			_delay_ms(0.001);
 722:stk500boot.c  **** 			boot_timer++;
 881               		.loc 1 722 0
 882 009a 4F5F      		subi r20,lo8(-(1))
 883 009c 5F4F      		sbci r21,hi8(-(1))
 884 009e 6F4F      		sbci r22,hlo8(-(1))
 885 00a0 7F4F      		sbci r23,hhi8(-(1))
 886               	.LVL35:
 723:stk500boot.c  **** 			if (boot_timer > boot_timeout) {
 724:stk500boot.c  **** 				boot_state = 1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 887               		.loc 1 724 0
 888 00a2 81E0      		ldi r24,lo8(1)
 889 00a4 90E0      		ldi r25,hi8(1)
 890               	.LVL36:
 891 00a6 413A      		cpi r20,lo8(100001)
 892 00a8 36E8      		ldi r19,hi8(100001)
 893 00aa 5307      		cpc r21,r19
 894 00ac 31E0      		ldi r19,hlo8(100001)
 895 00ae 6307      		cpc r22,r19
 896 00b0 30E0      		ldi r19,hhi8(100001)
 897 00b2 7307      		cpc r23,r19
 898 00b4 00F4      		brsh .L161
 899               	.LVL37:
 900               	.L166:
 901 00b6 80E0      		ldi r24,lo8(0)
 902 00b8 90E0      		ldi r25,hi8(0)
 903               	.L161:
 904               	.LVL38:
 905               	.LBB36:
 906               	.LBB37:
 482:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 907               		.loc 1 482 0 discriminator 1
 908 00ba 2091 C000 		lds r18,192
 909               	.LBE37:
 910               	.LBE36:
 719:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 911               		.loc 1 719 0 discriminator 1
 912 00be 27FD      		sbrc r18,7
 913 00c0 00C0      		rjmp .L61
 719:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 914               		.loc 1 719 0 is_stmt 0 discriminator 2
 915 00c2 0097      		sbiw r24,0
 916 00c4 01F0      		breq .L62
 917               	.L61:
 918               	.LVL39:
 718:stk500boot.c  **** 	while (boot_state == 0) {
 919               		.loc 1 718 0 is_stmt 1
 920 00c6 0196      		adiw r24,1
 921               	.LVL40:
 725:stk500boot.c  **** 			}
 726:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 727:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0) {
 728:stk500boot.c  **** 				//*	toggle the LED
 729:stk500boot.c  **** 				//PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
 730:stk500boot.c  **** 			}
 731:stk500boot.c  **** #endif
 732:stk500boot.c  **** 		}
 733:stk500boot.c  **** 		/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 734:stk500boot.c  **** 		//	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 735:stk500boot.c  **** 		// SDCARD BOOTLOADER
 736:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 737:stk500boot.c  **** 	}
 738:stk500boot.c  **** 
 739:stk500boot.c  **** 	if (boot_state == 1) {
 922               		.loc 1 739 0
 923 00c8 8130      		cpi r24,1
 924 00ca 9105      		cpc r25,__zero_reg__
 925 00cc 01F0      		breq .+2
 926 00ce 00C0      		rjmp .L163
 927 00d0 00C0      		rjmp .L175
 928               	.LVL41:
 929               	.L83:
 930 00d2 80E0      		ldi r24,lo8(0)
 931 00d4 90E0      		ldi r25,hi8(0)
 932               	.LVL42:
 933               	.L126:
 740:stk500boot.c  **** 		//*	main loop
 741:stk500boot.c  **** 		while (!isLeave) {
 742:stk500boot.c  **** 			/*
 743:stk500boot.c  **** 			 * Collect received bytes to a complete message
 744:stk500boot.c  **** 			 */
 745:stk500boot.c  **** 			msgParseState = ST_START;
 746:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 747:stk500boot.c  **** 				if (boot_state == 1) {
 934               		.loc 1 747 0
 935 00d6 8130      		cpi r24,1
 936 00d8 9105      		cpc r25,__zero_reg__
 937 00da 01F4      		brne .L132
 938 00dc 00C0      		rjmp .L167
 939               	.LVL43:
 940               	.L70:
 941               	.LBB38:
 942               	.LBB39:
 492:stk500boot.c  **** 		count++;
 943               		.loc 1 492 0
 944 00de 0196      		adiw r24,1
 945 00e0 A11D      		adc r26,__zero_reg__
 946 00e2 B11D      		adc r27,__zero_reg__
 947               	.LVL44:
 493:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 948               		.loc 1 493 0
 949 00e4 8130      		cpi r24,lo8(8000001)
 950 00e6 E2E1      		ldi r30,hi8(8000001)
 951 00e8 9E07      		cpc r25,r30
 952 00ea EAE7      		ldi r30,hlo8(8000001)
 953 00ec AE07      		cpc r26,r30
 954 00ee E0E0      		ldi r30,hhi8(8000001)
 955 00f0 BE07      		cpc r27,r30
 956 00f2 00F0      		brlo .L162
 957               	.LVL45:
 958               	.LBB40:
 500:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 959               		.loc 1 500 0
 960 00f4 C25D      		subi r28,lo8(-302)
 961 00f6 DE4F      		sbci r29,hi8(-302)
 962 00f8 8881      		ld r24,Y
 963 00fa 9981      		ldd r25,Y+1
 964 00fc CE52      		subi r28,lo8(302)
 965 00fe D140      		sbci r29,hi8(302)
 966               	.LVL46:
 967 0100 AFEF      		ldi r26,hi8(-1)
 968 0102 8F3F      		cpi r24,lo8(-1)
 969 0104 9A07      		cpc r25,r26
 970 0106 01F0      		breq .L132
 502:stk500boot.c  **** 				asm volatile(
 971               		.loc 1 502 0
 972               	/* #APP */
 973               	 ;  502 "stk500boot.c" 1
 974 0108 EE27      		clr	r30		
 975 010a FF27      		clr	r31		
 976 010c 0994      		ijmp	
 977               		
 978               	 ;  0 "" 2
 979               	.LVL47:
 980               	/* #NOAPP */
 981               	.L132:
 982               	.LBE40:
 983               	.LBE39:
 984               	.LBE38:
 985               		.loc 1 747 0
 986 010e 80E0      		ldi r24,lo8(0)
 987 0110 90E0      		ldi r25,hi8(0)
 988 0112 DC01      		movw r26,r24
 989               	.L162:
 990               	.LVL48:
 991               	.LBB45:
 992               	.LBB43:
 490:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 993               		.loc 1 490 0
 994 0114 3091 C000 		lds r19,192
 995 0118 37FF      		sbrs r19,7
 996 011a 00C0      		rjmp .L70
 997               	.LVL49:
 998               	.L167:
 511:stk500boot.c  **** 	return UART_DATA_REG;
 999               		.loc 1 511 0
 1000 011c 3091 C600 		lds r19,198
 1001               	.LVL50:
 1002               	.LBE43:
 1003               	.LBE45:
 748:stk500boot.c  **** 					boot_state = 0;
 749:stk500boot.c  **** 					c = UART_DATA_REG;
 750:stk500boot.c  **** 				} else {
 751:stk500boot.c  **** 					//	c	=	recchar();
 752:stk500boot.c  **** 					c = recchar_timeout();
 753:stk500boot.c  **** 
 754:stk500boot.c  **** 				}
 755:stk500boot.c  **** 
 756:stk500boot.c  **** #ifdef ENABLE_MONITOR
 757:stk500boot.c  **** 				rcvdCharCntr++;
 1004               		.loc 1 757 0
 1005 0120 0894      		sec
 1006 0122 C11C      		adc r12,__zero_reg__
 1007 0124 D11C      		adc r13,__zero_reg__
 1008               	.LVL51:
 758:stk500boot.c  **** 
 759:stk500boot.c  **** 				if ((c == '!') && (rcvdCharCntr < 10))
 1009               		.loc 1 759 0
 1010 0126 3132      		cpi r19,lo8(33)
 1011 0128 01F4      		brne .L135
 1012               		.loc 1 759 0 is_stmt 0 discriminator 1
 1013 012a BAE0      		ldi r27,lo8(10)
 1014 012c CB16      		cp r12,r27
 1015 012e D104      		cpc r13,__zero_reg__
 1016 0130 00F4      		brsh .L135
 760:stk500boot.c  **** 				{
 761:stk500boot.c  **** 					exPointCntr++;
 1017               		.loc 1 761 0 is_stmt 1
 1018 0132 0F5F      		subi r16,lo8(-(1))
 1019 0134 1F4F      		sbci r17,hi8(-(1))
 1020               	.LVL52:
 762:stk500boot.c  **** 					if (exPointCntr == 3)
 1021               		.loc 1 762 0
 1022 0136 0330      		cpi r16,3
 1023 0138 1105      		cpc r17,__zero_reg__
 1024 013a 01F4      		brne .L71
 1025 013c CC5D      		subi r28,lo8(-292)
 1026 013e DE4F      		sbci r29,hi8(-292)
 1027 0140 D982      		std Y+1,r13
 1028 0142 C882      		st Y,r12
 1029 0144 C452      		subi r28,lo8(292)
 1030 0146 D140      		sbci r29,hi8(292)
 1031 0148 CA5D      		subi r28,lo8(-294)
 1032 014a DE4F      		sbci r29,hi8(-294)
 1033 014c 7983      		std Y+1,r23
 1034 014e 6883      		st Y,r22
 1035 0150 C652      		subi r28,lo8(294)
 1036 0152 D140      		sbci r29,hi8(294)
 763:stk500boot.c  **** 					{
 764:stk500boot.c  **** 						exPointCntr = 0; //	reset back to zero so we dont get in an endless loop
 1037               		.loc 1 764 0
 1038 0154 CE5D      		subi r28,lo8(-290)
 1039 0156 DE4F      		sbci r29,hi8(-290)
 1040 0158 1982      		std Y+1,__zero_reg__
 1041 015a 1882      		st Y,__zero_reg__
 1042 015c C252      		subi r28,lo8(290)
 1043 015e D140      		sbci r29,hi8(290)
 765:stk500boot.c  **** 						isLeave = 1;
 1044               		.loc 1 765 0
 1045 0160 2224      		clr r2
 1046 0162 2394      		inc r2
 1047 0164 00C0      		rjmp .L72
 1048               	.L135:
 766:stk500boot.c  **** 						msgParseState = 99;//*	we dont want it do anything
 767:stk500boot.c  **** 						break;
 768:stk500boot.c  **** 					}
 769:stk500boot.c  **** 				}
 770:stk500boot.c  **** 				else
 771:stk500boot.c  **** 				{
 772:stk500boot.c  **** 					exPointCntr = 0;
 1049               		.loc 1 772 0
 1050 0166 00E0      		ldi r16,lo8(0)
 1051 0168 10E0      		ldi r17,hi8(0)
 1052               	.LVL53:
 1053               	.L71:
 773:stk500boot.c  **** 				}
 774:stk500boot.c  **** #endif
 775:stk500boot.c  **** 
 776:stk500boot.c  **** 				switch (msgParseState) {
 1054               		.loc 1 776 0
 1055 016a 2330      		cpi r18,lo8(3)
 1056 016c 01F0      		breq .L77
 1057 016e 2430      		cpi r18,lo8(4)
 1058 0170 00F4      		brsh .L81
 1059 0172 2130      		cpi r18,lo8(1)
 1060 0174 01F0      		breq .L75
 1061 0176 2230      		cpi r18,lo8(2)
 1062 0178 00F4      		brsh .L76
 1063 017a 00C0      		rjmp .L176
 1064               	.L81:
 1065 017c 2530      		cpi r18,lo8(5)
 1066 017e 01F0      		breq .L79
 1067 0180 2530      		cpi r18,lo8(5)
 1068 0182 00F0      		brlo .L78
 1069 0184 2630      		cpi r18,lo8(6)
 1070 0186 01F4      		brne .L165
 1071 0188 00C0      		rjmp .L177
 1072               	.L176:
 777:stk500boot.c  **** 				case ST_START:
 778:stk500boot.c  **** 					if (c == MESSAGE_START) {
 1073               		.loc 1 778 0
 1074 018a 3B31      		cpi r19,lo8(27)
 1075 018c 01F0      		breq .+2
 1076 018e 00C0      		rjmp .L83
 1077 0190 00C0      		rjmp .L178
 1078               	.L75:
 1079               	.LVL54:
 779:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 780:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 781:stk500boot.c  **** 					}
 782:stk500boot.c  **** 					break;
 783:stk500boot.c  **** 
 784:stk500boot.c  **** 				case ST_GET_SEQ_NUM:
 785:stk500boot.c  **** #ifdef _FIX_ISSUE_505_
 786:stk500boot.c  **** 					seqNum = c;
 787:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 788:stk500boot.c  **** 					checksum ^= c;
 1080               		.loc 1 788 0
 1081 0192 E326      		eor r14,r19
 1082               	.LVL55:
 789:stk500boot.c  **** #else
 790:stk500boot.c  **** 					if ( (c == 1) || (c == seqNum) )
 791:stk500boot.c  **** 					{
 792:stk500boot.c  **** 						seqNum = c;
 793:stk500boot.c  **** 						msgParseState = ST_MSG_SIZE_1;
 794:stk500boot.c  **** 						checksum ^= c;
 795:stk500boot.c  **** 					}
 796:stk500boot.c  **** 					else
 797:stk500boot.c  **** 					{
 798:stk500boot.c  **** 						msgParseState = ST_START;
 799:stk500boot.c  **** 					}
 800:stk500boot.c  **** #endif
 801:stk500boot.c  **** 					break;
 1083               		.loc 1 801 0
 1084 0194 332E      		mov r3,r19
 787:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 1085               		.loc 1 787 0
 1086 0196 22E0      		ldi r18,lo8(2)
 1087               		.loc 1 801 0
 1088 0198 00C0      		rjmp .L83
 1089               	.LVL56:
 1090               	.L76:
 802:stk500boot.c  **** 
 803:stk500boot.c  **** 				case ST_MSG_SIZE_1:
 804:stk500boot.c  **** 					msgLength = c << 8;
 1091               		.loc 1 804 0
 1092 019a 532F      		mov r21,r19
 1093 019c 40E0      		ldi r20,lo8(0)
 1094               	.LVL57:
 805:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 806:stk500boot.c  **** 					checksum ^= c;
 1095               		.loc 1 806 0
 1096 019e E326      		eor r14,r19
 1097               	.LVL58:
 805:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 1098               		.loc 1 805 0
 1099 01a0 23E0      		ldi r18,lo8(3)
 807:stk500boot.c  **** 					break;
 1100               		.loc 1 807 0
 1101 01a2 00C0      		rjmp .L83
 1102               	.LVL59:
 1103               	.L77:
 808:stk500boot.c  **** 
 809:stk500boot.c  **** 				case ST_MSG_SIZE_2:
 810:stk500boot.c  **** 					msgLength |= c;
 1104               		.loc 1 810 0
 1105 01a4 832F      		mov r24,r19
 1106 01a6 90E0      		ldi r25,lo8(0)
 1107 01a8 482B      		or r20,r24
 1108 01aa 592B      		or r21,r25
 1109               	.LVL60:
 811:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 812:stk500boot.c  **** 					checksum ^= c;
 1110               		.loc 1 812 0
 1111 01ac E326      		eor r14,r19
 1112               	.LVL61:
 811:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 1113               		.loc 1 811 0
 1114 01ae 24E0      		ldi r18,lo8(4)
 813:stk500boot.c  **** 					break;
 1115               		.loc 1 813 0
 1116 01b0 00C0      		rjmp .L83
 1117               	.LVL62:
 1118               	.L78:
 814:stk500boot.c  **** 
 815:stk500boot.c  **** 				case ST_GET_TOKEN:
 816:stk500boot.c  **** 					if (c == TOKEN) {
 1119               		.loc 1 816 0
 1120 01b2 3E30      		cpi r19,lo8(14)
 1121 01b4 01F0      		breq .+2
 1122 01b6 00C0      		rjmp .L138
 1123               	.LVL63:
 817:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 818:stk500boot.c  **** 						checksum ^= c;
 1124               		.loc 1 818 0
 1125 01b8 E326      		eor r14,r19
 1126               	.LVL64:
 819:stk500boot.c  **** 						ii = 0;
 1127               		.loc 1 819 0
 1128 01ba 60E0      		ldi r22,lo8(0)
 1129 01bc 70E0      		ldi r23,hi8(0)
 817:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 1130               		.loc 1 817 0
 1131 01be 25E0      		ldi r18,lo8(5)
 1132 01c0 00C0      		rjmp .L83
 1133               	.LVL65:
 1134               	.L79:
 820:stk500boot.c  **** 					} else {
 821:stk500boot.c  **** 						msgParseState = ST_START;
 822:stk500boot.c  **** 					}
 823:stk500boot.c  **** 					break;
 824:stk500boot.c  **** 
 825:stk500boot.c  **** 				case ST_GET_DATA:
 826:stk500boot.c  **** 					msgBuffer[ii++] = c;
 1135               		.loc 1 826 0
 1136 01c2 E1E0      		ldi r30,lo8(1)
 1137 01c4 F0E0      		ldi r31,hi8(1)
 1138 01c6 EC0F      		add r30,r28
 1139 01c8 FD1F      		adc r31,r29
 1140 01ca E60F      		add r30,r22
 1141 01cc F71F      		adc r31,r23
 1142 01ce 3083      		st Z,r19
 1143 01d0 6F5F      		subi r22,lo8(-(1))
 1144 01d2 7F4F      		sbci r23,hi8(-(1))
 1145               	.LVL66:
 827:stk500boot.c  **** 					checksum ^= c;
 1146               		.loc 1 827 0
 1147 01d4 E326      		eor r14,r19
 1148               	.LVL67:
 828:stk500boot.c  **** 					if (ii == msgLength) {
 1149               		.loc 1 828 0
 1150 01d6 6417      		cp r22,r20
 1151 01d8 7507      		cpc r23,r21
 1152 01da 01F0      		breq .+2
 1153 01dc 00C0      		rjmp .L83
 1154 01de 00C0      		rjmp .L179
 1155               	.LVL68:
 1156               	.L177:
 829:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 830:stk500boot.c  **** 					}
 831:stk500boot.c  **** 					break;
 832:stk500boot.c  **** 
 833:stk500boot.c  **** 				case ST_GET_CHECK:
 834:stk500boot.c  **** 					if (c == checksum) {
 1157               		.loc 1 834 0
 1158 01e0 3E15      		cp r19,r14
 1159 01e2 01F0      		breq .+2
 1160 01e4 00C0      		rjmp .L138
 1161 01e6 00C0      		rjmp .L140
 1162               	.L165:
 1163               	.LVL69:
 746:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 1164               		.loc 1 746 0 discriminator 1
 1165 01e8 2730      		cpi r18,lo8(7)
 1166 01ea 01F0      		breq .+2
 1167 01ec 00C0      		rjmp .L83
 1168               	.LVL70:
 1169               	.L140:
 1170 01ee CE5D      		subi r28,lo8(-290)
 1171 01f0 DE4F      		sbci r29,hi8(-290)
 1172 01f2 1983      		std Y+1,r17
 1173 01f4 0883      		st Y,r16
 1174 01f6 C252      		subi r28,lo8(290)
 1175 01f8 D140      		sbci r29,hi8(290)
 1176 01fa CC5D      		subi r28,lo8(-292)
 1177 01fc DE4F      		sbci r29,hi8(-292)
 1178 01fe D982      		std Y+1,r13
 1179 0200 C882      		st Y,r12
 1180 0202 C452      		subi r28,lo8(292)
 1181 0204 D140      		sbci r29,hi8(292)
 1182 0206 CA5D      		subi r28,lo8(-294)
 1183 0208 DE4F      		sbci r29,hi8(-294)
 1184 020a 7983      		std Y+1,r23
 1185 020c 6883      		st Y,r22
 1186 020e C652      		subi r28,lo8(294)
 1187 0210 D140      		sbci r29,hi8(294)
 1188               		.loc 1 834 0
 1189 0212 2224      		clr r2
 1190               	.L72:
 1191               	.LVL71:
 835:stk500boot.c  **** 						msgParseState = ST_PROCESS;
 836:stk500boot.c  **** 					} else {
 837:stk500boot.c  **** 						msgParseState = ST_START;
 838:stk500boot.c  **** 					}
 839:stk500boot.c  **** 					break;
 840:stk500boot.c  **** 				} //	switch
 841:stk500boot.c  **** 			} //	while(msgParseState)
 842:stk500boot.c  **** 
 843:stk500boot.c  **** 			/*
 844:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 845:stk500boot.c  **** 			 */
 846:stk500boot.c  **** 
 847:stk500boot.c  **** 			switch (msgBuffer[0]) {
 1192               		.loc 1 847 0
 1193 0214 8981      		ldd r24,Y+1
 1194 0216 8331      		cpi r24,lo8(19)
 1195 0218 01F4      		brne .+2
 1196 021a 00C0      		rjmp .L91
 1197 021c 8431      		cpi r24,lo8(20)
 1198 021e 00F4      		brsh .L98
 1199 0220 8630      		cpi r24,lo8(6)
 1200 0222 01F4      		brne .+2
 1201 0224 00C0      		rjmp .L88
 1202 0226 8730      		cpi r24,lo8(7)
 1203 0228 00F4      		brsh .L99
 1204 022a 8230      		cpi r24,lo8(2)
 1205 022c 01F4      		brne .+2
 1206 022e 00C0      		rjmp .L174
 1207 0230 8330      		cpi r24,lo8(3)
 1208 0232 01F4      		brne .+2
 1209 0234 00C0      		rjmp .L87
 1210 0236 8130      		cpi r24,lo8(1)
 1211 0238 01F0      		breq .+2
 1212 023a 00C0      		rjmp .L84
 1213 023c 00C0      		rjmp .L180
 1214               	.L99:
 1215 023e 8131      		cpi r24,lo8(17)
 1216 0240 01F4      		brne .+2
 1217 0242 00C0      		rjmp .L141
 1218 0244 8231      		cpi r24,lo8(18)
 1219 0246 00F0      		brlo .+2
 1220 0248 00C0      		rjmp .L90
 1221 024a 8031      		cpi r24,lo8(16)
 1222 024c 01F0      		breq .+2
 1223 024e 00C0      		rjmp .L84
 1224 0250 00C0      		rjmp .L174
 1225               	.L98:
 1226 0252 8831      		cpi r24,lo8(24)
 1227 0254 01F4      		brne .+2
 1228 0256 00C0      		rjmp .L93
 1229 0258 8931      		cpi r24,lo8(25)
 1230 025a 00F4      		brsh .L100
 1231 025c 8531      		cpi r24,lo8(21)
 1232 025e 01F4      		brne .+2
 1233 0260 00C0      		rjmp .L91
 1234 0262 8531      		cpi r24,lo8(21)
 1235 0264 00F4      		brsh .+2
 1236 0266 00C0      		rjmp .L92
 1237 0268 8631      		cpi r24,lo8(22)
 1238 026a 01F0      		breq .+2
 1239 026c 00C0      		rjmp .L84
 1240 026e 00C0      		rjmp .L92
 1241               	.L100:
 1242 0270 8A31      		cpi r24,lo8(26)
 1243 0272 01F4      		brne .+2
 1244 0274 00C0      		rjmp .L95
 1245 0276 8A31      		cpi r24,lo8(26)
 1246 0278 00F4      		brsh .+2
 1247 027a 00C0      		rjmp .L94
 1248 027c 8B31      		cpi r24,lo8(27)
 1249 027e 01F4      		brne .+2
 1250 0280 00C0      		rjmp .L96
 1251 0282 8D31      		cpi r24,lo8(29)
 1252 0284 01F0      		breq .+2
 1253 0286 00C0      		rjmp .L84
 1254               	.LVL72:
 1255               	.LBB46:
 848:stk500boot.c  **** #ifndef REMOVE_CMD_SPI_MULTI
 849:stk500boot.c  **** 			case CMD_SPI_MULTI: {
 850:stk500boot.c  **** 				unsigned char answerByte;
 851:stk500boot.c  **** 				unsigned char flag = 0;
 852:stk500boot.c  **** 
 853:stk500boot.c  **** 				if (msgBuffer[4] == 0x30) {
 1256               		.loc 1 853 0
 1257 0288 8D81      		ldd r24,Y+5
 1258 028a 8033      		cpi r24,lo8(48)
 1259 028c 01F4      		brne .L101
 1260               	.LBB47:
 854:stk500boot.c  **** 					unsigned char signatureIndex = msgBuffer[6];
 1261               		.loc 1 854 0
 1262 028e 9F81      		ldd r25,Y+7
 1263               	.LVL73:
 855:stk500boot.c  **** 
 856:stk500boot.c  **** 					if (signatureIndex == 0) {
 1264               		.loc 1 856 0
 1265 0290 9923      		tst r25
 1266 0292 01F0      		breq .L142
 857:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 858:stk500boot.c  **** 					} else if (signatureIndex == 1) {
 1267               		.loc 1 858 0
 1268 0294 9130      		cpi r25,lo8(1)
 1269 0296 01F4      		brne .L143
 859:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1270               		.loc 1 859 0
 1271 0298 E8E9      		ldi r30,lo8(-104)
 1272 029a 00C0      		rjmp .L102
 1273               	.LVL74:
 1274               	.L101:
 1275               	.LBE47:
 860:stk500boot.c  **** 					} else {
 861:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 862:stk500boot.c  **** 					}
 863:stk500boot.c  **** 				} else if (msgBuffer[4] & 0x50) {
 1276               		.loc 1 863 0
 1277 029c 982F      		mov r25,r24
 1278 029e 9075      		andi r25,lo8(80)
 1279 02a0 01F0      		breq .L145
 864:stk500boot.c  **** 					//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 865:stk500boot.c  **** 					//*	I cant find the docs that say what these are supposed to be but this was figured out by tr
 866:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 867:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 868:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 869:stk500boot.c  **** 					if (msgBuffer[4] == 0x50) {
 1280               		.loc 1 869 0
 1281 02a2 8035      		cpi r24,lo8(80)
 1282 02a4 01F4      		brne .L103
 1283               	.LBB48:
 870:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1284               		.loc 1 870 0
 1285 02a6 E0E0      		ldi r30,lo8(0)
 1286 02a8 F0E0      		ldi r31,hi8(0)
 1287 02aa 00C0      		rjmp .L168
 1288               	.L103:
 1289               	.LBE48:
 871:stk500boot.c  **** 					} else if (msgBuffer[4] == 0x58) {
 1290               		.loc 1 871 0
 1291 02ac 8835      		cpi r24,lo8(88)
 1292 02ae 01F4      		brne .L145
 1293               	.LBB49:
 872:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1294               		.loc 1 872 0
 1295 02b0 E3E0      		ldi r30,lo8(3)
 1296 02b2 F0E0      		ldi r31,hi8(3)
 1297               	.L168:
 1298 02b4 99E0      		ldi r25,lo8(9)
 1299               	/* #APP */
 1300               	 ;  872 "stk500boot.c" 1
 1301 02b6 9093 5700 		sts 87, r25
 1302 02ba E491      		lpm r30, Z
 1303               		
 1304               	 ;  0 "" 2
 1305               	.LVL75:
 1306               	/* #NOAPP */
 1307 02bc 00C0      		rjmp .L102
 1308               	.LVL76:
 1309               	.L142:
 1310               	.LBE49:
 1311               	.LBB50:
 857:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1312               		.loc 1 857 0
 1313 02be EEE1      		ldi r30,lo8(30)
 1314 02c0 00C0      		rjmp .L102
 1315               	.L143:
 861:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 1316               		.loc 1 861 0
 1317 02c2 E1E0      		ldi r30,lo8(1)
 1318 02c4 00C0      		rjmp .L102
 1319               	.LVL77:
 1320               	.L145:
 1321               	.LBE50:
 873:stk500boot.c  **** 					} else {
 874:stk500boot.c  **** 						answerByte = 0;
 1322               		.loc 1 874 0
 1323 02c6 E0E0      		ldi r30,lo8(0)
 1324               	.L102:
 1325               	.LVL78:
 875:stk500boot.c  **** 					}
 876:stk500boot.c  **** 				} else {
 877:stk500boot.c  **** 					answerByte = 0; // for all others command are not implemented, return dummy value for AVRDUDE 
 878:stk500boot.c  **** 				}
 879:stk500boot.c  **** 				if (!flag) {
 880:stk500boot.c  **** 					msgLength = 7;
 881:stk500boot.c  **** 					msgBuffer[1] = STATUS_CMD_OK;
 1326               		.loc 1 881 0
 1327 02c8 1A82      		std Y+2,__zero_reg__
 882:stk500boot.c  **** 					msgBuffer[2] = 0;
 1328               		.loc 1 882 0
 1329 02ca 1B82      		std Y+3,__zero_reg__
 883:stk500boot.c  **** 					msgBuffer[3] = msgBuffer[4];
 1330               		.loc 1 883 0
 1331 02cc 8C83      		std Y+4,r24
 884:stk500boot.c  **** 					msgBuffer[4] = 0;
 1332               		.loc 1 884 0
 1333 02ce 1D82      		std Y+5,__zero_reg__
 885:stk500boot.c  **** 					msgBuffer[5] = answerByte;
 1334               		.loc 1 885 0
 1335 02d0 EE83      		std Y+6,r30
 886:stk500boot.c  **** 					msgBuffer[6] = STATUS_CMD_OK;
 1336               		.loc 1 886 0
 1337 02d2 1F82      		std Y+7,__zero_reg__
 880:stk500boot.c  **** 					msgLength = 7;
 1338               		.loc 1 880 0
 1339 02d4 B7E0      		ldi r27,lo8(7)
 1340 02d6 CB2E      		mov r12,r27
 1341 02d8 D12C      		mov r13,__zero_reg__
 1342 02da 00C0      		rjmp .L104
 1343               	.LVL79:
 1344               	.L180:
 1345               	.LBE46:
 887:stk500boot.c  **** 				}
 888:stk500boot.c  **** 			}
 889:stk500boot.c  **** 				break;
 890:stk500boot.c  **** #endif
 891:stk500boot.c  **** 			case CMD_SIGN_ON:
 892:stk500boot.c  **** 				msgLength = 11;
 893:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1346               		.loc 1 893 0
 1347 02dc 1A82      		std Y+2,__zero_reg__
 894:stk500boot.c  **** 				msgBuffer[2] = 8;
 1348               		.loc 1 894 0
 1349 02de 88E0      		ldi r24,lo8(8)
 1350 02e0 8B83      		std Y+3,r24
 895:stk500boot.c  **** 				msgBuffer[3] = 'A';
 1351               		.loc 1 895 0
 1352 02e2 81E4      		ldi r24,lo8(65)
 1353 02e4 8C83      		std Y+4,r24
 896:stk500boot.c  **** 				msgBuffer[4] = 'V';
 1354               		.loc 1 896 0
 1355 02e6 86E5      		ldi r24,lo8(86)
 1356 02e8 8D83      		std Y+5,r24
 897:stk500boot.c  **** 				msgBuffer[5] = 'R';
 1357               		.loc 1 897 0
 1358 02ea 82E5      		ldi r24,lo8(82)
 1359 02ec 8E83      		std Y+6,r24
 898:stk500boot.c  **** 				msgBuffer[6] = 'I';
 1360               		.loc 1 898 0
 1361 02ee 89E4      		ldi r24,lo8(73)
 1362 02f0 8F83      		std Y+7,r24
 899:stk500boot.c  **** 				msgBuffer[7] = 'S';
 1363               		.loc 1 899 0
 1364 02f2 83E5      		ldi r24,lo8(83)
 1365 02f4 8887      		std Y+8,r24
 900:stk500boot.c  **** 				msgBuffer[8] = 'P';
 1366               		.loc 1 900 0
 1367 02f6 80E5      		ldi r24,lo8(80)
 1368 02f8 8987      		std Y+9,r24
 901:stk500boot.c  **** 				msgBuffer[9] = '_';
 1369               		.loc 1 901 0
 1370 02fa 8FE5      		ldi r24,lo8(95)
 1371 02fc 8A87      		std Y+10,r24
 902:stk500boot.c  **** 				msgBuffer[10] = '2';
 1372               		.loc 1 902 0
 1373 02fe 82E3      		ldi r24,lo8(50)
 1374 0300 8B87      		std Y+11,r24
 892:stk500boot.c  **** 				msgLength = 11;
 1375               		.loc 1 892 0
 1376 0302 ABE0      		ldi r26,lo8(11)
 1377 0304 CA2E      		mov r12,r26
 1378 0306 D12C      		mov r13,__zero_reg__
 903:stk500boot.c  **** 				break;
 1379               		.loc 1 903 0
 1380 0308 00C0      		rjmp .L104
 1381               	.LVL80:
 1382               	.L87:
 1383 030a EA81      		ldd r30,Y+2
 1384 030c E059      		subi r30,lo8(-(112))
 1385 030e E330      		cpi r30,lo8(3)
 1386 0310 00F4      		brsh .L146
 1387 0312 F0E0      		ldi r31,lo8(0)
 1388 0314 E050      		subi r30,lo8(-(CSWTCH.17))
 1389 0316 F040      		sbci r31,hi8(-(CSWTCH.17))
 1390 0318 8081      		ld r24,Z
 1391 031a 00C0      		rjmp .L105
 1392               	.L146:
 1393               	.LBB51:
 904:stk500boot.c  **** 
 905:stk500boot.c  **** 			case CMD_GET_PARAMETER: {
 906:stk500boot.c  **** 				unsigned char value;
 907:stk500boot.c  **** 
 908:stk500boot.c  **** 				switch (msgBuffer[1]) {
 1394               		.loc 1 908 0
 1395 031c 80E0      		ldi r24,lo8(0)
 1396               	.L105:
 1397               	.LVL81:
 909:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_LOW:
 910:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_LOW;
 911:stk500boot.c  **** 					break;
 912:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_HIGH:
 913:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_HIGH;
 914:stk500boot.c  **** 					break;
 915:stk500boot.c  **** 				case PARAM_HW_VER:
 916:stk500boot.c  **** 					value = CONFIG_PARAM_HW_VER;
 917:stk500boot.c  **** 					break;
 918:stk500boot.c  **** 				case PARAM_SW_MAJOR:
 919:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MAJOR;
 920:stk500boot.c  **** 					break;
 921:stk500boot.c  **** 				case PARAM_SW_MINOR:
 922:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MINOR;
 923:stk500boot.c  **** 					break;
 924:stk500boot.c  **** 				default:
 925:stk500boot.c  **** 					value = 0;
 926:stk500boot.c  **** 					break;
 927:stk500boot.c  **** 				}
 928:stk500boot.c  **** 				msgLength = 3;
 929:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1398               		.loc 1 929 0
 1399 031e 1A82      		std Y+2,__zero_reg__
 930:stk500boot.c  **** 				msgBuffer[2] = value;
 1400               		.loc 1 930 0
 1401 0320 8B83      		std Y+3,r24
 1402 0322 00C0      		rjmp .L170
 1403               	.LVL82:
 1404               	.L141:
 1405               	.LBE51:
 931:stk500boot.c  **** 			}
 932:stk500boot.c  **** 				break;
 933:stk500boot.c  **** 
 934:stk500boot.c  **** 			case CMD_LEAVE_PROGMODE_ISP:
 935:stk500boot.c  **** 				isLeave = 1;
 1406               		.loc 1 935 0
 1407 0324 2224      		clr r2
 1408 0326 2394      		inc r2
 1409               	.LVL83:
 1410 0328 00C0      		rjmp .L174
 1411               	.LVL84:
 1412               	.L96:
 1413               	.LBB52:
 936:stk500boot.c  **** 				//*	fall thru
 937:stk500boot.c  **** 
 938:stk500boot.c  **** 			case CMD_SET_PARAMETER:
 939:stk500boot.c  **** 			case CMD_ENTER_PROGMODE_ISP:
 940:stk500boot.c  **** 				msgLength = 2;
 941:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 942:stk500boot.c  **** 				break;
 943:stk500boot.c  **** 
 944:stk500boot.c  **** 			case CMD_READ_SIGNATURE_ISP: {
 945:stk500boot.c  **** 				unsigned char signatureIndex = msgBuffer[4];
 1414               		.loc 1 945 0
 1415 032a 8D81      		ldd r24,Y+5
 1416               	.LVL85:
 946:stk500boot.c  **** 				unsigned char signature;
 947:stk500boot.c  **** 
 948:stk500boot.c  **** 				if (signatureIndex == 0)
 1417               		.loc 1 948 0
 1418 032c 8823      		tst r24
 1419 032e 01F0      		breq .L147
 949:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 950:stk500boot.c  **** 				else if (signatureIndex == 1)
 1420               		.loc 1 950 0
 1421 0330 8130      		cpi r24,lo8(1)
 1422 0332 01F4      		brne .L148
 951:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1423               		.loc 1 951 0
 1424 0334 88E9      		ldi r24,lo8(-104)
 1425 0336 00C0      		rjmp .L106
 1426               	.L147:
 949:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1427               		.loc 1 949 0
 1428 0338 8EE1      		ldi r24,lo8(30)
 1429 033a 00C0      		rjmp .L106
 1430               	.L148:
 952:stk500boot.c  **** 				else
 953:stk500boot.c  **** 					signature = SIGNATURE_BYTES & 0x000000FF;
 1431               		.loc 1 953 0
 1432 033c 81E0      		ldi r24,lo8(1)
 1433               	.L106:
 1434               	.LVL86:
 954:stk500boot.c  **** 
 955:stk500boot.c  **** 				msgLength = 4;
 956:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1435               		.loc 1 956 0
 1436 033e 1A82      		std Y+2,__zero_reg__
 957:stk500boot.c  **** 				msgBuffer[2] = signature;
 1437               		.loc 1 957 0
 1438 0340 8B83      		std Y+3,r24
 1439 0342 00C0      		rjmp .L172
 1440               	.LVL87:
 1441               	.L95:
 1442               	.LBE52:
 958:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 959:stk500boot.c  **** 			}
 960:stk500boot.c  **** 				break;
 961:stk500boot.c  **** 
 962:stk500boot.c  **** 			case CMD_READ_LOCK_ISP:
 963:stk500boot.c  **** 				msgLength = 4;
 964:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1443               		.loc 1 964 0
 1444 0344 1A82      		std Y+2,__zero_reg__
 1445               	.LBB53:
 965:stk500boot.c  **** 				msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
 1446               		.loc 1 965 0
 1447 0346 E1E0      		ldi r30,lo8(1)
 1448 0348 F0E0      		ldi r31,hi8(1)
 1449 034a 89E0      		ldi r24,lo8(9)
 1450               	/* #APP */
 1451               	 ;  965 "stk500boot.c" 1
 1452 034c 8093 5700 		sts 87, r24
 1453 0350 E491      		lpm r30, Z
 1454               		
 1455               	 ;  0 "" 2
 1456               	/* #NOAPP */
 1457               	.L173:
 1458               	.LVL88:
 1459               	.LBE53:
 1460 0352 EB83      		std Y+3,r30
 1461               	.LVL89:
 1462               	.L172:
 966:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 1463               		.loc 1 966 0
 1464 0354 1C82      		std Y+4,__zero_reg__
 963:stk500boot.c  **** 				msgLength = 4;
 1465               		.loc 1 963 0
 1466 0356 F4E0      		ldi r31,lo8(4)
 1467 0358 CF2E      		mov r12,r31
 1468 035a D12C      		mov r13,__zero_reg__
 967:stk500boot.c  **** 				break;
 1469               		.loc 1 967 0
 1470 035c 00C0      		rjmp .L104
 1471               	.LVL90:
 1472               	.L93:
 1473               	.LBB54:
 968:stk500boot.c  **** 
 969:stk500boot.c  **** 			case CMD_READ_FUSE_ISP: {
 970:stk500boot.c  **** 				unsigned char fuseBits;
 971:stk500boot.c  **** 
 972:stk500boot.c  **** 				if (msgBuffer[2] == 0x50) {
 1474               		.loc 1 972 0
 1475 035e 8B81      		ldd r24,Y+3
 1476 0360 8035      		cpi r24,lo8(80)
 1477 0362 01F4      		brne .L107
 973:stk500boot.c  **** 					if (msgBuffer[3] == 0x08)
 1478               		.loc 1 973 0
 1479 0364 8C81      		ldd r24,Y+4
 1480 0366 8830      		cpi r24,lo8(8)
 1481 0368 01F4      		brne .L108
 1482               	.LBB55:
 974:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1483               		.loc 1 974 0
 1484 036a E2E0      		ldi r30,lo8(2)
 1485 036c F0E0      		ldi r31,hi8(2)
 1486 036e 00C0      		rjmp .L169
 1487               	.L108:
 1488               	.LBE55:
 1489               	.LBB56:
 975:stk500boot.c  **** 					else
 976:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 1490               		.loc 1 976 0
 1491 0370 E0E0      		ldi r30,lo8(0)
 1492 0372 F0E0      		ldi r31,hi8(0)
 1493 0374 00C0      		rjmp .L169
 1494               	.L107:
 1495               	.LBE56:
 1496               	.LBB57:
 977:stk500boot.c  **** 				} else {
 978:stk500boot.c  **** 					fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 1497               		.loc 1 978 0
 1498 0376 E3E0      		ldi r30,lo8(3)
 1499 0378 F0E0      		ldi r31,hi8(3)
 1500               	.L169:
 1501 037a 89E0      		ldi r24,lo8(9)
 1502               	/* #APP */
 1503               	 ;  978 "stk500boot.c" 1
 1504 037c 8093 5700 		sts 87, r24
 1505 0380 E491      		lpm r30, Z
 1506               		
 1507               	 ;  0 "" 2
 1508               	.LVL91:
 1509               	/* #NOAPP */
 1510               	.LBE57:
 979:stk500boot.c  **** 				}
 980:stk500boot.c  **** 				msgLength = 4;
 981:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1511               		.loc 1 981 0
 1512 0382 1A82      		std Y+2,__zero_reg__
 1513 0384 00C0      		rjmp .L173
 1514               	.LVL92:
 1515               	.L94:
 1516               	.LBE54:
 1517               	.LBB59:
 982:stk500boot.c  **** 				msgBuffer[2] = fuseBits;
 983:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 984:stk500boot.c  **** 			}
 985:stk500boot.c  **** 				break;
 986:stk500boot.c  **** 
 987:stk500boot.c  **** #ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 988:stk500boot.c  **** 			case CMD_PROGRAM_LOCK_ISP: {
 989:stk500boot.c  **** 				unsigned char lockBits = msgBuffer[4];
 990:stk500boot.c  **** 
 991:stk500boot.c  **** 				lockBits = (~lockBits) & 0x3C; // mask BLBxx bits
 1518               		.loc 1 991 0
 1519 0386 8D81      		ldd r24,Y+5
 1520               	.LVL93:
 1521               	.LBB60:
 992:stk500boot.c  **** 				boot_lock_bits_set(lockBits);
 1522               		.loc 1 992 0
 1523 0388 836C      		ori r24,lo8(-61)
 1524 038a 99E0      		ldi r25,lo8(9)
 1525               	/* #APP */
 1526               	 ;  992 "stk500boot.c" 1
 1527 038c E1E0      		ldi r30, 1
 1528 038e F0E0      		ldi r31, 0
 1529 0390 082E      		mov r0, r24
 1530 0392 9093 5700 		sts 87, r25
 1531 0396 E895      		spm
 1532               		
 1533               	 ;  0 "" 2
 1534               	/* #NOAPP */
 1535               	.L110:
 1536               	.LBE60:
 993:stk500boot.c  **** 				// and program it
 994:stk500boot.c  **** 				boot_spm_busy_wait();
 1537               		.loc 1 994 0 discriminator 1
 1538 0398 07B6      		in __tmp_reg__,87-32
 1539 039a 00FC      		sbrc __tmp_reg__,0
 1540 039c 00C0      		rjmp .L110
 1541               	.LVL94:
 995:stk500boot.c  **** 
 996:stk500boot.c  **** 				msgLength = 3;
 997:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1542               		.loc 1 997 0
 1543 039e 1A82      		std Y+2,__zero_reg__
 998:stk500boot.c  **** 				msgBuffer[2] = STATUS_CMD_OK;
 1544               		.loc 1 998 0
 1545 03a0 1B82      		std Y+3,__zero_reg__
 1546               	.LVL95:
 1547               	.L170:
 1548               	.LBE59:
 996:stk500boot.c  **** 				msgLength = 3;
 1549               		.loc 1 996 0
 1550 03a2 E3E0      		ldi r30,lo8(3)
 1551 03a4 CE2E      		mov r12,r30
 1552 03a6 D12C      		mov r13,__zero_reg__
 999:stk500boot.c  **** 			}
1000:stk500boot.c  **** 				break;
 1553               		.loc 1 1000 0
 1554 03a8 00C0      		rjmp .L104
 1555               	.LVL96:
 1556               	.L90:
1001:stk500boot.c  **** #endif
1002:stk500boot.c  **** 			case CMD_CHIP_ERASE_ISP:
1003:stk500boot.c  **** 				eraseAddress = 0;
1004:stk500boot.c  **** 				msgLength = 2;
1005:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1006:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED; //*	isue 543, return FAILED instead of OK
 1557               		.loc 1 1006 0
 1558 03aa 80EC      		ldi r24,lo8(-64)
 1559 03ac 8A83      		std Y+2,r24
1004:stk500boot.c  **** 				msgLength = 2;
 1560               		.loc 1 1004 0
 1561 03ae 72E0      		ldi r23,lo8(2)
 1562 03b0 C72E      		mov r12,r23
 1563 03b2 D12C      		mov r13,__zero_reg__
1003:stk500boot.c  **** 				eraseAddress = 0;
 1564               		.loc 1 1003 0
 1565 03b4 C25E      		subi r28,lo8(-286)
 1566 03b6 DE4F      		sbci r29,hi8(-286)
 1567 03b8 1882      		st Y,__zero_reg__
 1568 03ba 1982      		std Y+1,__zero_reg__
 1569 03bc 1A82      		std Y+2,__zero_reg__
 1570 03be 1B82      		std Y+3,__zero_reg__
 1571 03c0 CE51      		subi r28,lo8(286)
 1572 03c2 D140      		sbci r29,hi8(286)
1007:stk500boot.c  **** 				break;
 1573               		.loc 1 1007 0
 1574 03c4 00C0      		rjmp .L104
 1575               	.LVL97:
 1576               	.L88:
1008:stk500boot.c  **** 
1009:stk500boot.c  **** 			case CMD_LOAD_ADDRESS:
1010:stk500boot.c  **** #if defined(RAMPZ)
1011:stk500boot.c  **** 				address = ( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuf
 1577               		.loc 1 1011 0
 1578 03c6 8A81      		ldd r24,Y+2
 1579 03c8 90E0      		ldi r25,lo8(0)
 1580 03ca A0E0      		ldi r26,lo8(0)
 1581 03cc B0E0      		ldi r27,hi8(0)
 1582 03ce 782E      		mov r7,r24
 1583 03d0 6624      		clr r6
 1584 03d2 5524      		clr r5
 1585 03d4 4424      		clr r4
 1586               	.LVL98:
 1587 03d6 8B81      		ldd r24,Y+3
 1588 03d8 90E0      		ldi r25,lo8(0)
 1589 03da A0E0      		ldi r26,lo8(0)
 1590 03dc B0E0      		ldi r27,hi8(0)
 1591 03de DC01      		movw r26,r24
 1592 03e0 9927      		clr r25
 1593 03e2 8827      		clr r24
 1594 03e4 482A      		or r4,r24
 1595 03e6 592A      		or r5,r25
 1596 03e8 6A2A      		or r6,r26
 1597 03ea 7B2A      		or r7,r27
 1598 03ec 8D81      		ldd r24,Y+5
 1599 03ee 90E0      		ldi r25,lo8(0)
 1600 03f0 A0E0      		ldi r26,lo8(0)
 1601 03f2 B0E0      		ldi r27,hi8(0)
 1602 03f4 482A      		or r4,r24
 1603 03f6 592A      		or r5,r25
 1604 03f8 6A2A      		or r6,r26
 1605 03fa 7B2A      		or r7,r27
 1606 03fc 8C81      		ldd r24,Y+4
 1607 03fe 90E0      		ldi r25,lo8(0)
 1608 0400 A0E0      		ldi r26,lo8(0)
 1609 0402 B0E0      		ldi r27,hi8(0)
 1610 0404 BA2F      		mov r27,r26
 1611 0406 A92F      		mov r26,r25
 1612 0408 982F      		mov r25,r24
 1613 040a 8827      		clr r24
 1614 040c 482A      		or r4,r24
 1615 040e 592A      		or r5,r25
 1616 0410 6A2A      		or r6,r26
 1617 0412 7B2A      		or r7,r27
 1618 0414 440C      		lsl r4
 1619 0416 551C      		rol r5
 1620 0418 661C      		rol r6
 1621 041a 771C      		rol r7
 1622               	.L174:
 1623               	.LVL99:
1012:stk500boot.c  **** #else
1013:stk500boot.c  **** 				address = (((msgBuffer[3]) << 8) | (msgBuffer[4])) << 1; //convert word to byte address
1014:stk500boot.c  **** #endif
1015:stk500boot.c  **** 				msgLength = 2;
1016:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1624               		.loc 1 1016 0
 1625 041c 1A82      		std Y+2,__zero_reg__
 1626 041e 00C0      		rjmp .L171
 1627               	.LVL100:
 1628               	.L91:
 1629               	.LBB61:
1017:stk500boot.c  **** 				break;
1018:stk500boot.c  **** 
1019:stk500boot.c  **** 			case CMD_PROGRAM_FLASH_ISP:
1020:stk500boot.c  **** 			case CMD_PROGRAM_EEPROM_ISP: {
1021:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1630               		.loc 1 1021 0
 1631 0420 EA81      		ldd r30,Y+2
 1632 0422 C75D      		subi r28,lo8(-297)
 1633 0424 DE4F      		sbci r29,hi8(-297)
 1634 0426 E883      		st Y,r30
 1635 0428 C952      		subi r28,lo8(297)
 1636 042a D140      		sbci r29,hi8(297)
 1637 042c C85D      		subi r28,lo8(-296)
 1638 042e DE4F      		sbci r29,hi8(-296)
 1639 0430 1882      		st Y,__zero_reg__
 1640 0432 C852      		subi r28,lo8(296)
 1641 0434 D140      		sbci r29,hi8(296)
 1642 0436 CB80      		ldd r12,Y+3
 1643 0438 DD24      		clr r13
 1644 043a C85D      		subi r28,lo8(-296)
 1645 043c DE4F      		sbci r29,hi8(-296)
 1646 043e 2881      		ld r18,Y
 1647 0440 3981      		ldd r19,Y+1
 1648 0442 C852      		subi r28,lo8(296)
 1649 0444 D140      		sbci r29,hi8(296)
 1650 0446 C22A      		or r12,r18
 1651 0448 D32A      		or r13,r19
 1652               	.LVL101:
1022:stk500boot.c  **** 				unsigned char *p = msgBuffer + 10;
1023:stk500boot.c  **** 				unsigned int data;
1024:stk500boot.c  **** 				unsigned char highByte, lowByte;
1025:stk500boot.c  **** 				address_t tempaddress = address;
1026:stk500boot.c  **** 
1027:stk500boot.c  **** 				if (msgBuffer[0] == CMD_PROGRAM_FLASH_ISP) {
 1653               		.loc 1 1027 0
 1654 044a 8331      		cpi r24,lo8(19)
 1655 044c 01F0      		breq .+2
 1656 044e 00C0      		rjmp .L111
1028:stk500boot.c  **** 					// erase only main section (bootloader protection)
1029:stk500boot.c  **** 					if (eraseAddress < APP_END) {
 1657               		.loc 1 1029 0
 1658 0450 C25E      		subi r28,lo8(-286)
 1659 0452 DE4F      		sbci r29,hi8(-286)
 1660 0454 2881      		ld r18,Y
 1661 0456 3981      		ldd r19,Y+1
 1662 0458 4A81      		ldd r20,Y+2
 1663 045a 5B81      		ldd r21,Y+3
 1664 045c CE51      		subi r28,lo8(286)
 1665 045e D140      		sbci r29,hi8(286)
 1666 0460 2030      		cpi r18,lo8(245760)
 1667 0462 80EC      		ldi r24,hi8(245760)
 1668 0464 3807      		cpc r19,r24
 1669 0466 83E0      		ldi r24,hlo8(245760)
 1670 0468 4807      		cpc r20,r24
 1671 046a 80E0      		ldi r24,hhi8(245760)
 1672 046c 5807      		cpc r21,r24
 1673 046e 00F4      		brsh .L112
1030:stk500boot.c  **** 						boot_page_erase(eraseAddress);
 1674               		.loc 1 1030 0
 1675 0470 83E0      		ldi r24,lo8(3)
 1676               	/* #APP */
 1677               	 ;  1030 "stk500boot.c" 1
 1678 0472 F901      		movw r30, r18
 1679 0474 4093 5B00 		sts  91, r20
 1680 0478 8093 5700 		sts 87, r24
 1681 047c E895      		spm
 1682               		
 1683               	 ;  0 "" 2
 1684               	/* #NOAPP */
 1685               	.L113:
1031:stk500boot.c  **** 						// Perform page erase
1032:stk500boot.c  **** 						boot_spm_busy_wait(); // Wait until the memory is erased.
 1686               		.loc 1 1032 0 discriminator 1
 1687 047e 07B6      		in __tmp_reg__,87-32
 1688 0480 00FC      		sbrc __tmp_reg__,0
 1689 0482 00C0      		rjmp .L113
1033:stk500boot.c  **** 						eraseAddress += SPM_PAGESIZE; // point to next page to be erase
 1690               		.loc 1 1033 0
 1691 0484 C25E      		subi r28,lo8(-286)
 1692 0486 DE4F      		sbci r29,hi8(-286)
 1693 0488 2881      		ld r18,Y
 1694 048a 3981      		ldd r19,Y+1
 1695 048c 4A81      		ldd r20,Y+2
 1696 048e 5B81      		ldd r21,Y+3
 1697 0490 CE51      		subi r28,lo8(286)
 1698 0492 D140      		sbci r29,hi8(286)
 1699 0494 2050      		subi r18,lo8(-(256))
 1700 0496 3F4F      		sbci r19,hi8(-(256))
 1701 0498 4F4F      		sbci r20,hlo8(-(256))
 1702 049a 5F4F      		sbci r21,hhi8(-(256))
 1703 049c C25E      		subi r28,lo8(-286)
 1704 049e DE4F      		sbci r29,hi8(-286)
 1705 04a0 2883      		st Y,r18
 1706 04a2 3983      		std Y+1,r19
 1707 04a4 4A83      		std Y+2,r20
 1708 04a6 5B83      		std Y+3,r21
 1709 04a8 CE51      		subi r28,lo8(286)
 1710 04aa D140      		sbci r29,hi8(286)
 1711               	.LVL102:
 1712               	.L112:
 1713               		.loc 1 1033 0 is_stmt 0 discriminator 1
 1714 04ac 8B85      		ldd r24,Y+11
 1715 04ae DE01      		movw r26,r28
 1716 04b0 1D96      		adiw r26,13
 1717               	.LBE61:
 1718               	.LBB63:
 1719               	.LBB58:
 974:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1720               		.loc 1 974 0 is_stmt 1 discriminator 1
 1721 04b2 9301      		movw r18,r6
 1722 04b4 8201      		movw r16,r4
 1723               	.LBE58:
 1724               	.LBE63:
 1725               	.LBB64:
1034:stk500boot.c  **** 					}
1035:stk500boot.c  **** 
1036:stk500boot.c  **** 					/* Write FLASH */
1037:stk500boot.c  **** 					do {
1038:stk500boot.c  **** 						lowByte = *p++;
1039:stk500boot.c  **** 						highByte = *p++;
1040:stk500boot.c  **** 
1041:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
1042:stk500boot.c  **** 						boot_page_fill(address, data);
 1726               		.loc 1 1042 0 discriminator 1
 1727 04b6 41E0      		ldi r20,lo8(1)
 1728 04b8 B601      		movw r22,r12
 1729               	.LVL103:
 1730               	.L115:
 595:stk500boot.c  **** int main(void) {
 1731               		.loc 1 595 0 discriminator 1
 1732 04ba FD01      		movw r30,r26
 1733 04bc 3197      		sbiw r30,1
1041:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
 1734               		.loc 1 1041 0 discriminator 1
 1735 04be 5081      		ld r21,Z
 1736 04c0 C55D      		subi r28,lo8(-299)
 1737 04c2 DE4F      		sbci r29,hi8(-299)
 1738 04c4 5883      		st Y,r21
 1739 04c6 CB52      		subi r28,lo8(299)
 1740 04c8 D140      		sbci r29,hi8(299)
 1741 04ca C65D      		subi r28,lo8(-298)
 1742 04cc DE4F      		sbci r29,hi8(-298)
 1743 04ce 1882      		st Y,__zero_reg__
 1744 04d0 CA52      		subi r28,lo8(298)
 1745 04d2 D140      		sbci r29,hi8(298)
 1746 04d4 90E0      		ldi r25,lo8(0)
 1747 04d6 C65D      		subi r28,lo8(-298)
 1748 04d8 DE4F      		sbci r29,hi8(-298)
 1749 04da E881      		ld r30,Y
 1750 04dc F981      		ldd r31,Y+1
 1751 04de CA52      		subi r28,lo8(298)
 1752 04e0 D140      		sbci r29,hi8(298)
 1753 04e2 8E2B      		or r24,r30
 1754 04e4 9F2B      		or r25,r31
 1755               	.LVL104:
 1756               		.loc 1 1042 0 discriminator 1
 1757               	/* #APP */
 1758               	 ;  1042 "stk500boot.c" 1
 1759 04e6 0C01      		movw  r0, r24
 1760 04e8 F801      		movw r30, r16
 1761 04ea 2093 5B00 		sts 91, r18
 1762 04ee 4093 5700 		sts 87, r20
 1763 04f2 E895      		spm
 1764 04f4 1124      		clr  r1
 1765               		
 1766               	 ;  0 "" 2
1043:stk500boot.c  **** 
1044:stk500boot.c  **** 						address = address + 2; // Select next word in memory
 1767               		.loc 1 1044 0 discriminator 1
 1768               	/* #NOAPP */
 1769 04f6 0E5F      		subi r16,lo8(-(2))
 1770 04f8 1F4F      		sbci r17,hi8(-(2))
 1771 04fa 2F4F      		sbci r18,hlo8(-(2))
 1772 04fc 3F4F      		sbci r19,hhi8(-(2))
 1773               	.LVL105:
1045:stk500boot.c  **** 						size -= 2; // Reduce number of bytes to write by two
 1774               		.loc 1 1045 0 discriminator 1
 1775 04fe 6250      		subi r22,lo8(-(-2))
 1776 0500 7040      		sbci r23,hi8(-(-2))
 1777               	.LVL106:
1046:stk500boot.c  **** 					} while (size); // Loop until all bytes written
 1778               		.loc 1 1046 0 discriminator 1
 1779 0502 01F0      		breq .L114
1039:stk500boot.c  **** 						highByte = *p++;
 1780               		.loc 1 1039 0
 1781 0504 8C91      		ld r24,X
 1782 0506 1296      		adiw r26,2
 1783               	.LVL107:
 1784 0508 00C0      		rjmp .L115
 1785               	.LVL108:
 1786               	.L114:
1047:stk500boot.c  **** 
1048:stk500boot.c  **** 					boot_page_write(tempaddress);
 1787               		.loc 1 1048 0
 1788 050a 85E0      		ldi r24,lo8(5)
 1789               	/* #APP */
 1790               	 ;  1048 "stk500boot.c" 1
 1791 050c F201      		movw r30, r4
 1792 050e 6092 5B00 		sts 91, r6
 1793 0512 8093 5700 		sts 87, r24
 1794 0516 E895      		spm
 1795               		
 1796               	 ;  0 "" 2
 1797               	/* #NOAPP */
 1798               	.L116:
1049:stk500boot.c  **** 					boot_spm_busy_wait();
 1799               		.loc 1 1049 0 discriminator 1
 1800 0518 07B6      		in __tmp_reg__,87-32
 1801 051a 00FC      		sbrc __tmp_reg__,0
 1802 051c 00C0      		rjmp .L116
1050:stk500boot.c  **** 					boot_rww_enable(); // Re-enable the RWW section
 1803               		.loc 1 1050 0
 1804 051e 81E1      		ldi r24,lo8(17)
 1805               	/* #APP */
 1806               	 ;  1050 "stk500boot.c" 1
 1807 0520 8093 5700 		sts 87, r24
 1808 0524 E895      		spm
 1809               		
 1810               	 ;  0 "" 2
 1811               	/* #NOAPP */
 1812 0526 00C0      		rjmp .L117
 1813               	.LVL109:
 1814               	.L111:
 1815               	.LBB62:
1051:stk500boot.c  **** 				} else {
1052:stk500boot.c  **** 					//*	issue 543, this should work, It has not been tested.
1053:stk500boot.c  **** 					uint16_t ii = address >> 1;
 1816               		.loc 1 1053 0
 1817 0528 5301      		movw r10,r6
 1818 052a 4201      		movw r8,r4
 1819 052c B694      		lsr r11
 1820 052e A794      		ror r10
 1821 0530 9794      		ror r9
 1822 0532 8794      		ror r8
 1823               	.LVL110:
1054:stk500boot.c  **** 					/* write EEPROM */
1055:stk500boot.c  **** 					while (size) {
 1824               		.loc 1 1055 0
 1825 0534 00E0      		ldi r16,lo8(0)
 1826 0536 10E0      		ldi r17,hi8(0)
1022:stk500boot.c  **** 				unsigned char *p = msgBuffer + 10;
 1827               		.loc 1 1022 0
 1828 0538 2BE0      		ldi r18,lo8(11)
 1829 053a E22E      		mov r14,r18
 1830 053c F12C      		mov r15,__zero_reg__
 1831 053e EC0E      		add r14,r28
 1832 0540 FD1E      		adc r15,r29
 1833               		.loc 1 1055 0
 1834 0542 00C0      		rjmp .L118
 1835               	.LVL111:
 1836               	.L119:
1056:stk500boot.c  **** 						eeprom_write_byte((uint8_t*) ii, *p++);
 1837               		.loc 1 1056 0
 1838 0544 D701      		movw r26,r14
 1839 0546 6D91      		ld r22,X+
 1840 0548 7D01      		movw r14,r26
 1841               	.LVL112:
 595:stk500boot.c  **** int main(void) {
 1842               		.loc 1 595 0
 1843 054a C801      		movw r24,r16
 1844 054c 880D      		add r24,r8
 1845 054e 991D      		adc r25,r9
 1846               		.loc 1 1056 0
 1847 0550 0E94 0000 		call __eewr_byte_m2560
 1848               	.LVL113:
 1849 0554 0F5F      		subi r16,lo8(-(1))
 1850 0556 1F4F      		sbci r17,hi8(-(1))
 1851               	.LVL114:
 1852               	.L118:
1055:stk500boot.c  **** 					while (size) {
 1853               		.loc 1 1055 0 discriminator 1
 1854 0558 0C15      		cp r16,r12
 1855 055a 1D05      		cpc r17,r13
 1856 055c 01F4      		brne .L119
 595:stk500boot.c  **** int main(void) {
 1857               		.loc 1 595 0
 1858 055e 20E0      		ldi r18,lo8(0)
 1859 0560 30E0      		ldi r19,hi8(0)
 1860 0562 000F      		lsl r16
 1861 0564 111F      		rol r17
 1862 0566 221F      		rol r18
 1863 0568 331F      		rol r19
1055:stk500boot.c  **** 					while (size) {
 1864               		.loc 1 1055 0
 1865 056a 040D      		add r16,r4
 1866 056c 151D      		adc r17,r5
 1867 056e 261D      		adc r18,r6
 1868 0570 371D      		adc r19,r7
 1869               	.LVL115:
 1870               	.L117:
 1871               	.LBE62:
1057:stk500boot.c  **** 						address += 2; // Select next EEPROM byte
1058:stk500boot.c  **** 						ii++;
1059:stk500boot.c  **** 						size--;
1060:stk500boot.c  **** 					}
1061:stk500boot.c  **** 				}
1062:stk500boot.c  **** 				msgLength = 2;
1063:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1872               		.loc 1 1063 0
 1873 0572 1A82      		std Y+2,__zero_reg__
 1874               	.LBE64:
1064:stk500boot.c  **** 			}
1065:stk500boot.c  **** 				break;
 1875               		.loc 1 1065 0
 1876 0574 2801      		movw r4,r16
 1877 0576 3901      		movw r6,r18
 1878               	.LVL116:
 1879 0578 00C0      		rjmp .L171
 1880               	.LVL117:
 1881               	.L92:
 1882               	.LBB65:
1066:stk500boot.c  **** 
1067:stk500boot.c  **** 			case CMD_READ_FLASH_ISP:
1068:stk500boot.c  **** 			case CMD_READ_EEPROM_ISP: {
1069:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1883               		.loc 1 1069 0
 1884 057a BA81      		ldd r27,Y+2
 1885 057c C35D      		subi r28,lo8(-301)
 1886 057e DE4F      		sbci r29,hi8(-301)
 1887 0580 B883      		st Y,r27
 1888 0582 CD52      		subi r28,lo8(301)
 1889 0584 D140      		sbci r29,hi8(301)
 1890 0586 C45D      		subi r28,lo8(-300)
 1891 0588 DE4F      		sbci r29,hi8(-300)
 1892 058a 1882      		st Y,__zero_reg__
 1893 058c CC52      		subi r28,lo8(300)
 1894 058e D140      		sbci r29,hi8(300)
 1895 0590 2B81      		ldd r18,Y+3
 1896 0592 30E0      		ldi r19,lo8(0)
 1897               	.LVL118:
 1898 0594 C45D      		subi r28,lo8(-300)
 1899 0596 DE4F      		sbci r29,hi8(-300)
 1900 0598 4881      		ld r20,Y
 1901 059a 5981      		ldd r21,Y+1
 1902 059c CC52      		subi r28,lo8(300)
 1903 059e D140      		sbci r29,hi8(300)
 1904 05a0 242B      		or r18,r20
 1905 05a2 352B      		or r19,r21
 1906               	.LVL119:
1070:stk500boot.c  **** 				unsigned char *p = msgBuffer + 1;
1071:stk500boot.c  **** 				msgLength = size + 3;
 1907               		.loc 1 1071 0
 1908 05a4 13E0      		ldi r17,lo8(3)
 1909 05a6 C12E      		mov r12,r17
 1910 05a8 D12C      		mov r13,__zero_reg__
 1911 05aa C20E      		add r12,r18
 1912 05ac D31E      		adc r13,r19
 1913               	.LVL120:
1072:stk500boot.c  **** 
1073:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 1914               		.loc 1 1073 0
 1915 05ae 1A82      		std Y+2,__zero_reg__
 1916               	.LVL121:
1074:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1917               		.loc 1 1074 0
 1918 05b0 8431      		cpi r24,lo8(20)
 1919 05b2 01F4      		brne .L149
 1920 05b4 DE01      		movw r26,r28
 1921 05b6 1396      		adiw r26,3
 1922 05b8 A901      		movw r20,r18
 1923 05ba 9D01      		movw r18,r26
 1924               	.LVL122:
 1925 05bc D301      		movw r26,r6
 1926 05be C201      		movw r24,r4
 1927               	.LVL123:
 1928               	.L121:
 1929               	.LBB66:
 1930               	.LBB67:
1075:stk500boot.c  **** 					unsigned int data;
1076:stk500boot.c  **** 
1077:stk500boot.c  **** 					// Read FLASH
1078:stk500boot.c  **** 					do {
1079:stk500boot.c  **** 						//#if defined(RAMPZ)
1080:stk500boot.c  **** #if (FLASHEND > 0x10000)
1081:stk500boot.c  **** 						data = pgm_read_word_far(address);
 1931               		.loc 1 1081 0 discriminator 1
 1932               	/* #APP */
 1933               	 ;  1081 "stk500boot.c" 1
 1934 05c0 ABBF      		out 59, r26
 1935 05c2 FC01      		movw r30, r24
 1936 05c4 6791      		elpm r22, Z+
 1937 05c6 7691      		elpm r23, Z
 1938               		
 1939               	 ;  0 "" 2
 1940               	/* #NOAPP */
 1941               	.LBE67:
1082:stk500boot.c  **** #else
1083:stk500boot.c  **** 						data = pgm_read_word_near(address);
1084:stk500boot.c  **** #endif
1085:stk500boot.c  **** 						*p++ = (unsigned char) data; //LSB
 1942               		.loc 1 1085 0 discriminator 1
 1943 05c8 F901      		movw r30,r18
 1944 05ca 6083      		st Z,r22
 1945               	.LVL124:
1086:stk500boot.c  **** 						*p++ = (unsigned char) (data >> 8); //MSB
 1946               		.loc 1 1086 0 discriminator 1
 1947 05cc 7183      		std Z+1,r23
 595:stk500boot.c  **** int main(void) {
 1948               		.loc 1 595 0 discriminator 1
 1949 05ce 2E5F      		subi r18,lo8(-(2))
 1950 05d0 3F4F      		sbci r19,hi8(-(2))
 1951               	.LVL125:
1087:stk500boot.c  **** 						address += 2; // Select next word in memory
 1952               		.loc 1 1087 0 discriminator 1
 1953 05d2 0296      		adiw r24,2
 1954 05d4 A11D      		adc r26,__zero_reg__
 1955 05d6 B11D      		adc r27,__zero_reg__
 1956               	.LVL126:
1088:stk500boot.c  **** 						size -= 2;
 1957               		.loc 1 1088 0 discriminator 1
 1958 05d8 4250      		subi r20,lo8(-(-2))
 1959 05da 5040      		sbci r21,hi8(-(-2))
 1960               	.LVL127:
1089:stk500boot.c  **** 					} while (size);
 1961               		.loc 1 1089 0 discriminator 1
 1962 05dc 01F4      		brne .L121
 1963 05de 2C01      		movw r4,r24
 1964 05e0 3D01      		movw r6,r26
 1965 05e2 D901      		movw r26,r18
 1966 05e4 00C0      		rjmp .L122
 1967               	.LVL128:
 1968               	.L149:
 1969               	.LBE66:
1074:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1970               		.loc 1 1074 0
 1971 05e6 F901      		movw r30,r18
 1972 05e8 B301      		movw r22,r6
 1973 05ea A201      		movw r20,r4
 1974 05ec 8E01      		movw r16,r28
 1975 05ee 0D5F      		subi r16,lo8(-(3))
 1976 05f0 1F4F      		sbci r17,hi8(-(3))
 1977               	.LVL129:
 1978               	.L120:
1090:stk500boot.c  **** 				} else {
1091:stk500boot.c  **** 					/* Read EEPROM */
1092:stk500boot.c  **** 					do {
1093:stk500boot.c  **** 						EEARL = address; // Setup EEPROM address
 1979               		.loc 1 1093 0 discriminator 1
 1980 05f2 41BD      		out 65-32,r20
1094:stk500boot.c  **** 						EEARH = ((address >> 8));
 1981               		.loc 1 1094 0 discriminator 1
 1982 05f4 BB27      		clr r27
 1983 05f6 A72F      		mov r26,r23
 1984 05f8 962F      		mov r25,r22
 1985 05fa 852F      		mov r24,r21
 1986 05fc 82BD      		out 66-32,r24
1095:stk500boot.c  **** 						address++; // Select next EEPROM byte
 1987               		.loc 1 1095 0 discriminator 1
 1988 05fe 4F5F      		subi r20,lo8(-(1))
 1989 0600 5F4F      		sbci r21,hi8(-(1))
 1990 0602 6F4F      		sbci r22,hlo8(-(1))
 1991 0604 7F4F      		sbci r23,hhi8(-(1))
 1992               	.LVL130:
1096:stk500boot.c  **** 						EECR |= (1 << EERE); // Read EEPROM
 1993               		.loc 1 1096 0 discriminator 1
 1994 0606 F89A      		sbi 63-32,0
1097:stk500boot.c  **** 						*p++ = EEDR; // Send EEPROM data
 1995               		.loc 1 1097 0 discriminator 1
 1996 0608 80B5      		in r24,64-32
 1997 060a D801      		movw r26,r16
 1998 060c 8D93      		st X+,r24
 1999 060e 8D01      		movw r16,r26
 2000               	.LVL131:
1098:stk500boot.c  **** 						size--;
 2001               		.loc 1 1098 0 discriminator 1
 2002 0610 3197      		sbiw r30,1
 2003               	.LVL132:
1099:stk500boot.c  **** 					} while (size);
 2004               		.loc 1 1099 0 discriminator 1
 2005 0612 01F4      		brne .L120
 595:stk500boot.c  **** int main(void) {
 2006               		.loc 1 595 0
 2007 0614 C901      		movw r24,r18
 2008 0616 0197      		sbiw r24,1
 2009 0618 A0E0      		ldi r26,lo8(0)
 2010 061a B0E0      		ldi r27,hi8(0)
 2011               	.LVL133:
 2012 061c 0196      		adiw r24,1
 2013 061e A11D      		adc r26,__zero_reg__
 2014 0620 B11D      		adc r27,__zero_reg__
 2015               		.loc 1 1099 0
 2016 0622 480E      		add r4,r24
 2017 0624 591E      		adc r5,r25
 2018 0626 6A1E      		adc r6,r26
 2019 0628 7B1E      		adc r7,r27
 2020 062a A3E0      		ldi r26,lo8(3)
 2021 062c B0E0      		ldi r27,hi8(3)
 2022 062e AC0F      		add r26,r28
 2023 0630 BD1F      		adc r27,r29
 2024 0632 A20F      		add r26,r18
 2025 0634 B31F      		adc r27,r19
 2026               	.LVL134:
 2027               	.L122:
1100:stk500boot.c  **** 				}
1101:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 2028               		.loc 1 1101 0
 2029 0636 1C92      		st X,__zero_reg__
 2030               	.LVL135:
 2031               	.LBE65:
1102:stk500boot.c  **** 			}
1103:stk500boot.c  **** 				break;
 2032               		.loc 1 1103 0
 2033 0638 00C0      		rjmp .L104
 2034               	.LVL136:
 2035               	.L84:
1104:stk500boot.c  **** 
1105:stk500boot.c  **** 			default:
1106:stk500boot.c  **** 				msgLength = 2;
1107:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED;
 2036               		.loc 1 1107 0
 2037 063a 80EC      		ldi r24,lo8(-64)
 2038 063c 8A83      		std Y+2,r24
 2039               	.LVL137:
 2040               	.L171:
1106:stk500boot.c  **** 				msgLength = 2;
 2041               		.loc 1 1106 0
 2042 063e A2E0      		ldi r26,lo8(2)
 2043 0640 CA2E      		mov r12,r26
 2044 0642 D12C      		mov r13,__zero_reg__
 2045               	.LVL138:
 2046               	.L104:
1108:stk500boot.c  **** 				break;
1109:stk500boot.c  **** 			}
1110:stk500boot.c  **** 
1111:stk500boot.c  **** 			/*
1112:stk500boot.c  **** 			 * Now send answer message back
1113:stk500boot.c  **** 			 */
1114:stk500boot.c  **** 			sendchar(MESSAGE_START);
 2047               		.loc 1 1114 0
 2048 0644 8BE1      		ldi r24,lo8(27)
 2049 0646 0E94 0000 		call sendchar
 2050               	.LVL139:
1115:stk500boot.c  **** 			checksum = MESSAGE_START ^ 0;
1116:stk500boot.c  **** 
1117:stk500boot.c  **** 			sendchar(seqNum);
 2051               		.loc 1 1117 0
 2052 064a 832D      		mov r24,r3
 2053 064c 0E94 0000 		call sendchar
 2054               	.LVL140:
1118:stk500boot.c  **** 			checksum ^= seqNum;
1119:stk500boot.c  **** 
1120:stk500boot.c  **** 			c = ((msgLength >> 8) & 0xFF);
1121:stk500boot.c  **** 			sendchar(c);
 2055               		.loc 1 1121 0
 2056 0650 8D2D      		mov r24,r13
 2057 0652 0E94 0000 		call sendchar
 2058               	.LVL141:
1122:stk500boot.c  **** 			checksum ^= c;
1123:stk500boot.c  **** 
1124:stk500boot.c  **** 			c = msgLength & 0x00FF;
1125:stk500boot.c  **** 			sendchar(c);
 2059               		.loc 1 1125 0
 2060 0656 8C2D      		mov r24,r12
 2061 0658 0E94 0000 		call sendchar
 2062               	.LVL142:
1126:stk500boot.c  **** 			checksum ^= c;
1127:stk500boot.c  **** 
1128:stk500boot.c  **** 			sendchar(TOKEN);
 2063               		.loc 1 1128 0
 2064 065c 8EE0      		ldi r24,lo8(14)
 2065 065e 0E94 0000 		call sendchar
1122:stk500boot.c  **** 			checksum ^= c;
 2066               		.loc 1 1122 0
 2067 0662 F5E1      		ldi r31,lo8(21)
 2068 0664 EF2E      		mov r14,r31
 2069 0666 E324      		eor r14,r3
1126:stk500boot.c  **** 			checksum ^= c;
 2070               		.loc 1 1126 0
 2071 0668 EC24      		eor r14,r12
1129:stk500boot.c  **** 			checksum ^= TOKEN;
 2072               		.loc 1 1129 0
 2073 066a ED24      		eor r14,r13
 2074               	.LVL143:
1130:stk500boot.c  **** 
1131:stk500boot.c  **** 			p = msgBuffer;
 2075               		.loc 1 1131 0
 2076 066c 4E01      		movw r8,r28
 2077 066e 0894      		sec
 2078 0670 811C      		adc r8,__zero_reg__
 2079 0672 911C      		adc r9,__zero_reg__
1132:stk500boot.c  **** 			while (msgLength) {
 2080               		.loc 1 1132 0
 2081 0674 00C0      		rjmp .L123
 2082               	.LVL144:
 2083               	.L124:
1133:stk500boot.c  **** 				c = *p++;
 2084               		.loc 1 1133 0
 2085 0676 F401      		movw r30,r8
 2086 0678 1191      		ld r17,Z+
 2087 067a 4F01      		movw r8,r30
 2088               	.LVL145:
1134:stk500boot.c  **** 				sendchar(c);
 2089               		.loc 1 1134 0
 2090 067c 812F      		mov r24,r17
 2091 067e 0E94 0000 		call sendchar
 2092               	.LVL146:
1135:stk500boot.c  **** 				checksum ^= c;
 2093               		.loc 1 1135 0
 2094 0682 E126      		eor r14,r17
 2095               	.LVL147:
1136:stk500boot.c  **** 				msgLength--;
 2096               		.loc 1 1136 0
 2097 0684 0894      		sec
 2098 0686 C108      		sbc r12,__zero_reg__
 2099 0688 D108      		sbc r13,__zero_reg__
 2100               	.LVL148:
 2101               	.L123:
1132:stk500boot.c  **** 			while (msgLength) {
 2102               		.loc 1 1132 0 discriminator 1
 2103 068a C114      		cp r12,__zero_reg__
 2104 068c D104      		cpc r13,__zero_reg__
 2105 068e 01F4      		brne .L124
1137:stk500boot.c  **** 			}
1138:stk500boot.c  **** 			sendchar(checksum);
 2106               		.loc 1 1138 0
 2107 0690 8E2D      		mov r24,r14
 2108 0692 0E94 0000 		call sendchar
1139:stk500boot.c  **** 			seqNum++;
 2109               		.loc 1 1139 0
 2110 0696 3394      		inc r3
 2111               	.LVL149:
 741:stk500boot.c  **** 		while (!isLeave) {
 2112               		.loc 1 741 0
 2113 0698 2220      		tst r2
 2114 069a 01F0      		breq .+2
 2115 069c 00C0      		rjmp .L125
 2116 069e 80E0      		ldi r24,lo8(0)
 2117 06a0 90E0      		ldi r25,hi8(0)
 2118 06a2 00C0      		rjmp .L65
 2119               	.LVL150:
 2120               	.L175:
 739:stk500boot.c  **** 	if (boot_state == 1) {
 2121               		.loc 1 739 0
 2122 06a4 CC5D      		subi r28,lo8(-292)
 2123 06a6 DE4F      		sbci r29,hi8(-292)
 2124 06a8 1982      		std Y+1,__zero_reg__
 2125 06aa 1882      		st Y,__zero_reg__
 2126 06ac C452      		subi r28,lo8(292)
 2127 06ae D140      		sbci r29,hi8(292)
 2128 06b0 CE5D      		subi r28,lo8(-290)
 2129 06b2 DE4F      		sbci r29,hi8(-290)
 2130 06b4 1982      		std Y+1,__zero_reg__
 2131 06b6 1882      		st Y,__zero_reg__
 2132 06b8 C252      		subi r28,lo8(290)
 2133 06ba D140      		sbci r29,hi8(290)
 2134 06bc 3324      		clr r3
 2135 06be 10E0      		ldi r17,lo8(0)
 2136 06c0 CA5D      		subi r28,lo8(-294)
 2137 06c2 DE4F      		sbci r29,hi8(-294)
 2138 06c4 1982      		std Y+1,__zero_reg__
 2139 06c6 1882      		st Y,__zero_reg__
 2140 06c8 C652      		subi r28,lo8(294)
 2141 06ca D140      		sbci r29,hi8(294)
 2142 06cc C25E      		subi r28,lo8(-286)
 2143 06ce DE4F      		sbci r29,hi8(-286)
 2144 06d0 1882      		st Y,__zero_reg__
 2145 06d2 1982      		std Y+1,__zero_reg__
 2146 06d4 1A82      		std Y+2,__zero_reg__
 2147 06d6 1B82      		std Y+3,__zero_reg__
 2148 06d8 CE51      		subi r28,lo8(286)
 2149 06da D140      		sbci r29,hi8(286)
 2150 06dc 4424      		clr r4
 2151 06de 5524      		clr r5
 2152 06e0 3201      		movw r6,r4
 2153               	.LBB68:
 2154               	.LBB44:
 2155               	.LBB42:
 2156               	.LBB41:
 496:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 2157               		.loc 1 496 0
 2158 06e2 20E0      		ldi r18,lo8(0)
 2159 06e4 30E0      		ldi r19,hi8(0)
 2160 06e6 A901      		movw r20,r18
 2161               	/* #APP */
 2162               	 ;  496 "stk500boot.c" 1
 2163 06e8 4BBF      		out 59, r20
 2164 06ea F901      		movw r30, r18
 2165 06ec 4791      		elpm r20, Z+
 2166 06ee 5691      		elpm r21, Z
 2167               		
 2168               	 ;  0 "" 2
 2169               	/* #NOAPP */
 2170 06f0 C25D      		subi r28,lo8(-302)
 2171 06f2 DE4F      		sbci r29,hi8(-302)
 2172 06f4 5983      		std Y+1,r21
 2173 06f6 4883      		st Y,r20
 2174 06f8 CE52      		subi r28,lo8(302)
 2175 06fa D140      		sbci r29,hi8(302)
 2176 06fc E12E      		mov r14,r17
 2177               	.LVL151:
 2178               	.L65:
 2179               	.LBE41:
 2180               	.LBE42:
 2181               	.LBE44:
 2182               	.LBE68:
 659:stk500boot.c  **** 	boot_timer = 0;
 2183               		.loc 1 659 0 discriminator 1
 2184 06fe 40E0      		ldi r20,lo8(0)
 2185 0700 50E0      		ldi r21,hi8(0)
 2186 0702 20E0      		ldi r18,lo8(0)
 2187 0704 CE5D      		subi r28,lo8(-290)
 2188 0706 DE4F      		sbci r29,hi8(-290)
 2189 0708 0881      		ld r16,Y
 2190 070a 1981      		ldd r17,Y+1
 2191 070c C252      		subi r28,lo8(290)
 2192 070e D140      		sbci r29,hi8(290)
 2193 0710 CC5D      		subi r28,lo8(-292)
 2194 0712 DE4F      		sbci r29,hi8(-292)
 2195 0714 C880      		ld r12,Y
 2196 0716 D980      		ldd r13,Y+1
 2197 0718 C452      		subi r28,lo8(292)
 2198 071a D140      		sbci r29,hi8(292)
 2199 071c CA5D      		subi r28,lo8(-294)
 2200 071e DE4F      		sbci r29,hi8(-294)
 2201 0720 6881      		ld r22,Y
 2202 0722 7981      		ldd r23,Y+1
 2203 0724 C652      		subi r28,lo8(294)
 2204 0726 D140      		sbci r29,hi8(294)
 2205 0728 00C0      		rjmp .L126
 2206               	.LVL152:
 2207               	.L163:
1140:stk500boot.c  **** 
1141:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1142:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1143:stk500boot.c  **** 		//	PROGLED_PORT ^= (1 << PROGLED_PIN); // active high LED ON
1144:stk500boot.c  **** #endif
1145:stk500boot.c  **** 
1146:stk500boot.c  **** 		}
1147:stk500boot.c  **** 	}
1148:stk500boot.c  **** 
1149:stk500boot.c  **** 	if (boot_state == 2) {
 2208               		.loc 1 1149 0
 2209 072a 8230      		cpi r24,2
 2210 072c 9105      		cpc r25,__zero_reg__
 2211 072e 01F0      		breq .+2
 2212 0730 00C0      		rjmp .L125
1150:stk500boot.c  **** 		if (eeprom_read_byte(4095) == 0xF0) {
 2213               		.loc 1 1150 0
 2214 0732 8FEF      		ldi r24,lo8(4095)
 2215 0734 9FE0      		ldi r25,hi8(4095)
 2216               	.LVL153:
 2217 0736 0E94 0000 		call __eerd_byte_m2560
 2218 073a 803F      		cpi r24,lo8(-16)
 2219 073c 01F0      		breq .+2
 2220 073e 00C0      		rjmp .L125
 2221               	.LBB69:
1151:stk500boot.c  **** 			sendchar('u');
 2222               		.loc 1 1151 0
 2223 0740 85E7      		ldi r24,lo8(117)
 2224 0742 0E94 0000 		call sendchar
1152:stk500boot.c  **** 			sendchar('p');
 2225               		.loc 1 1152 0
 2226 0746 80E7      		ldi r24,lo8(112)
 2227 0748 0E94 0000 		call sendchar
1153:stk500boot.c  **** 			sendchar('g');
 2228               		.loc 1 1153 0
 2229 074c 87E6      		ldi r24,lo8(103)
 2230 074e 0E94 0000 		call sendchar
1154:stk500boot.c  **** 			sendchar('r');
 2231               		.loc 1 1154 0
 2232 0752 82E7      		ldi r24,lo8(114)
 2233 0754 0E94 0000 		call sendchar
1155:stk500boot.c  **** 			sendchar('a');
 2234               		.loc 1 1155 0
 2235 0758 81E6      		ldi r24,lo8(97)
 2236 075a 0E94 0000 		call sendchar
1156:stk500boot.c  **** 			sendchar('d');
 2237               		.loc 1 1156 0
 2238 075e 84E6      		ldi r24,lo8(100)
 2239 0760 0E94 0000 		call sendchar
1157:stk500boot.c  **** 			sendchar('i');
 2240               		.loc 1 1157 0
 2241 0764 89E6      		ldi r24,lo8(105)
 2242 0766 0E94 0000 		call sendchar
1158:stk500boot.c  **** 			sendchar('n');
 2243               		.loc 1 1158 0
 2244 076a 8EE6      		ldi r24,lo8(110)
 2245 076c 0E94 0000 		call sendchar
1159:stk500boot.c  **** 			sendchar('g');
 2246               		.loc 1 1159 0
 2247 0770 87E6      		ldi r24,lo8(103)
 2248 0772 0E94 0000 		call sendchar
1160:stk500boot.c  **** 			sendchar(0x0d);
 2249               		.loc 1 1160 0
 2250 0776 8DE0      		ldi r24,lo8(13)
 2251 0778 0E94 0000 		call sendchar
1161:stk500boot.c  **** 			sendchar(0x0a);
 2252               		.loc 1 1161 0
 2253 077c 8AE0      		ldi r24,lo8(10)
 2254 077e 0E94 0000 		call sendchar
1162:stk500boot.c  **** 			delay_ms(100);
 2255               		.loc 1 1162 0
 2256 0782 84E6      		ldi r24,lo8(100)
 2257 0784 90E0      		ldi r25,hi8(100)
 2258 0786 0E94 0000 		call delay_ms
1163:stk500boot.c  **** 
1164:stk500boot.c  **** 			DWORD fa; /* Flash address */
1165:stk500boot.c  **** 			sendchar(0x0d);
 2259               		.loc 1 1165 0
 2260 078a 8DE0      		ldi r24,lo8(13)
 2261 078c 0E94 0000 		call sendchar
1166:stk500boot.c  **** 			sendchar(0x0a);
 2262               		.loc 1 1166 0
 2263 0790 8AE0      		ldi r24,lo8(10)
 2264 0792 0E94 0000 		call sendchar
 2265               	.LVL154:
1167:stk500boot.c  **** 			long address = 16;
1168:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2266               		.loc 1 1168 0
 2267 0796 8824      		clr r8
 2268 0798 9924      		clr r9
 2269 079a 5401      		movw r10,r8
 2270               	.LVL155:
 2271               	.L129:
 595:stk500boot.c  **** int main(void) {
 2272               		.loc 1 595 0
 2273 079c 40E1      		ldi r20,lo8(16)
 2274 079e C42E      		mov r12,r20
 2275 07a0 D12C      		mov r13,__zero_reg__
 2276 07a2 E12C      		mov r14,__zero_reg__
 2277 07a4 F12C      		mov r15,__zero_reg__
 2278 07a6 C80C      		add r12,r8
 2279 07a8 D91C      		adc r13,r9
 2280 07aa EA1C      		adc r14,r10
 2281 07ac FB1C      		adc r15,r11
1169:stk500boot.c  **** 		//		PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
1170:stk500boot.c  **** 				delay_ms(50);
 2282               		.loc 1 1170 0
 2283 07ae 82E3      		ldi r24,lo8(50)
 2284 07b0 90E0      		ldi r25,hi8(50)
 2285 07b2 0E94 0000 		call delay_ms
1171:stk500boot.c  **** 				flash_erase(fa); /* Erase a page */
 2286               		.loc 1 1171 0
 2287 07b6 C501      		movw r24,r10
 2288 07b8 B401      		movw r22,r8
 2289 07ba 0E94 0000 		call flash_erase
1172:stk500boot.c  **** 				memset(Buff, 0xFF, SPM_PAGESIZE); /* Clear buffer */
 2290               		.loc 1 1172 0
 2291 07be 80E0      		ldi r24,lo8(Buff)
 2292 07c0 90E0      		ldi r25,hi8(Buff)
 2293 07c2 6FEF      		ldi r22,lo8(255)
 2294 07c4 70E0      		ldi r23,hi8(255)
 2295 07c6 40E0      		ldi r20,lo8(256)
 2296 07c8 51E0      		ldi r21,hi8(256)
 2297 07ca 0E94 0000 		call memset
 2298               	.LVL156:
 2299 07ce E0E0      		ldi r30,lo8(Buff)
 2300 07d0 6E2E      		mov r6,r30
 2301 07d2 E0E0      		ldi r30,hi8(Buff)
 2302 07d4 7E2E      		mov r7,r30
1173:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
 2303               		.loc 1 1173 0
 2304 07d6 4424      		clr r4
 2305 07d8 5524      		clr r5
 2306               	.LVL157:
 2307               	.L128:
 2308               	.LBB70:
1174:stk500boot.c  **** 					Buff[i] = spiReadReg(address);
 2309               		.loc 1 1174 0
 2310 07da C701      		movw r24,r14
 2311 07dc B601      		movw r22,r12
 2312 07de 0E94 0000 		call spiReadReg
 595:stk500boot.c  **** int main(void) {
 2313               		.loc 1 595 0
 2314 07e2 8301      		movw r16,r6
 2315               		.loc 1 1174 0
 2316 07e4 D301      		movw r26,r6
 2317 07e6 8D93      		st X+,r24
 2318 07e8 3D01      		movw r6,r26
1175:stk500boot.c  **** 					address++;
 2319               		.loc 1 1175 0
 2320 07ea 0894      		sec
 2321 07ec C11C      		adc r12,__zero_reg__
 2322 07ee D11C      		adc r13,__zero_reg__
 2323 07f0 E11C      		adc r14,__zero_reg__
 2324 07f2 F11C      		adc r15,__zero_reg__
 2325               	.LVL158:
1176:stk500boot.c  **** 					sendchar('[');
 2326               		.loc 1 1176 0
 2327 07f4 8BE5      		ldi r24,lo8(91)
 2328 07f6 0E94 0000 		call sendchar
1177:stk500boot.c  **** 					dec_hex(Buff[i]);
 2329               		.loc 1 1177 0
 2330 07fa F801      		movw r30,r16
 2331 07fc 6081      		ld r22,Z
 2332 07fe 70E0      		ldi r23,lo8(0)
 2333 0800 80E0      		ldi r24,lo8(0)
 2334 0802 90E0      		ldi r25,hi8(0)
 2335 0804 0E94 0000 		call dec_hex
1178:stk500boot.c  **** 					sendchar(']');
 2336               		.loc 1 1178 0
 2337 0808 8DE5      		ldi r24,lo8(93)
 2338 080a 0E94 0000 		call sendchar
1179:stk500boot.c  **** 					if(address % 16 == 0 && address != 0){
 2339               		.loc 1 1179 0
 2340 080e D701      		movw r26,r14
 2341 0810 C601      		movw r24,r12
 2342 0812 8F70      		andi r24,lo8(15)
 2343 0814 9070      		andi r25,hi8(15)
 2344 0816 A070      		andi r26,hlo8(15)
 2345 0818 B070      		andi r27,hhi8(15)
 2346 081a 0097      		sbiw r24,0
 2347 081c A105      		cpc r26,__zero_reg__
 2348 081e B105      		cpc r27,__zero_reg__
 2349 0820 01F4      		brne .L127
1180:stk500boot.c  **** 						sendchar(0x0d);
 2350               		.loc 1 1180 0
 2351 0822 8DE0      		ldi r24,lo8(13)
 2352 0824 0E94 0000 		call sendchar
1181:stk500boot.c  **** 						sendchar(0x0a);
 2353               		.loc 1 1181 0
 2354 0828 8AE0      		ldi r24,lo8(10)
 2355 082a 0E94 0000 		call sendchar
 2356               	.L127:
1173:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
 2357               		.loc 1 1173 0
 2358 082e 0894      		sec
 2359 0830 411C      		adc r4,__zero_reg__
 2360 0832 511C      		adc r5,__zero_reg__
 2361               	.LVL159:
 2362 0834 F0E0      		ldi r31,lo8(256)
 2363 0836 4F16      		cp r4,r31
 2364 0838 F1E0      		ldi r31,hi8(256)
 2365 083a 5F06      		cpc r5,r31
 2366 083c 01F4      		brne .L128
 2367               	.LBE70:
1182:stk500boot.c  **** 					}
1183:stk500boot.c  **** 				}
1184:stk500boot.c  **** 				flash_write(fa, Buff); /* Write it if the data is available */
 2368               		.loc 1 1184 0
 2369 083e C501      		movw r24,r10
 2370 0840 B401      		movw r22,r8
 2371 0842 40E0      		ldi r20,lo8(Buff)
 2372 0844 50E0      		ldi r21,hi8(Buff)
 2373 0846 0E94 0000 		call flash_write
1168:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2374               		.loc 1 1168 0
 2375 084a 20E0      		ldi r18,lo8(256)
 2376 084c 31E0      		ldi r19,hi8(256)
 2377 084e 40E0      		ldi r20,hlo8(256)
 2378 0850 50E0      		ldi r21,hhi8(256)
 2379 0852 820E      		add r8,r18
 2380 0854 931E      		adc r9,r19
 2381 0856 A41E      		adc r10,r20
 2382 0858 B51E      		adc r11,r21
 2383               	.LVL160:
 2384 085a 30E0      		ldi r19,lo8(253952)
 2385 085c 8316      		cp r8,r19
 2386 085e 30EE      		ldi r19,hi8(253952)
 2387 0860 9306      		cpc r9,r19
 2388 0862 33E0      		ldi r19,hlo8(253952)
 2389 0864 A306      		cpc r10,r19
 2390 0866 30E0      		ldi r19,hhi8(253952)
 2391 0868 B306      		cpc r11,r19
 2392 086a 01F0      		breq .+2
 2393 086c 00C0      		rjmp .L129
1185:stk500boot.c  **** 			}
1186:stk500boot.c  **** 			sendchar('d');
 2394               		.loc 1 1186 0
 2395 086e 84E6      		ldi r24,lo8(100)
 2396 0870 0E94 0000 		call sendchar
1187:stk500boot.c  **** 			sendchar(0x0d);
 2397               		.loc 1 1187 0
 2398 0874 8DE0      		ldi r24,lo8(13)
 2399 0876 0E94 0000 		call sendchar
1188:stk500boot.c  **** 			sendchar(0x0a);
 2400               		.loc 1 1188 0
 2401 087a 8AE0      		ldi r24,lo8(10)
 2402 087c 0E94 0000 		call sendchar
1189:stk500boot.c  **** 			check = 0;
 2403               		.loc 1 1189 0
 2404 0880 1092 0000 		sts check,__zero_reg__
1190:stk500boot.c  **** 			eeprom_write_byte(4095, 0x00);
 2405               		.loc 1 1190 0
 2406 0884 8FEF      		ldi r24,lo8(4095)
 2407 0886 9FE0      		ldi r25,hi8(4095)
 2408 0888 60E0      		ldi r22,lo8(0)
 2409 088a 0E94 0000 		call __eewr_byte_m2560
 2410               	.LVL161:
 2411               	.L125:
 2412               	.LBE69:
1191:stk500boot.c  **** 		}
1192:stk500boot.c  **** 
1193:stk500boot.c  **** 		boot_state = 0;
1194:stk500boot.c  **** 	}
1195:stk500boot.c  **** 
1196:stk500boot.c  **** 	asm volatile ("nop");
 2413               		.loc 1 1196 0
 2414               	/* #APP */
 2415               	 ;  1196 "stk500boot.c" 1
 2416 088e 0000      		nop
 2417               	 ;  0 "" 2
1197:stk500boot.c  **** 	// wait until port has changed
1198:stk500boot.c  **** 
1199:stk500boot.c  **** //    // SDCARD BOOTLOADER
1200:stk500boot.c  **** //
1201:stk500boot.c  **** //    WORD fa;	/* Flash address */
1202:stk500boot.c  **** //    WORD br;	/* Bytes read */
1203:stk500boot.c  **** //	uint8_t i = 0;
1204:stk500boot.c  **** //
1205:stk500boot.c  **** //
1206:stk500boot.c  **** //	pf_mount(&Fatfs);	/* Initialize file system */
1207:stk500boot.c  **** //
1208:stk500boot.c  **** //
1209:stk500boot.c  **** //	if (pf_open("app.bin") == FR_OK) {	/* Open application file */
1210:stk500boot.c  **** //        PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1211:stk500boot.c  **** //		
1212:stk500boot.c  **** //        for (fa = 0; fa < 0x1000; fa += SPM_PAGESIZE) {	/* Update all application pages */
1213:stk500boot.c  **** //            memset(Buff, 0xFF, SPM_PAGESIZE);		/* Clear buffer */
1214:stk500boot.c  **** //            pf_read(Buff, SPM_PAGESIZE, &br);		/* Load a page data */
1215:stk500boot.c  **** //            
1216:stk500boot.c  **** //			if (br) {					/* Bytes Read > 0? */
1217:stk500boot.c  **** //            	for (i = br; i < SPM_PAGESIZE; i++)     /* Pad the remaining last page with 0xFF so 
1218:stk500boot.c  **** //                    Buff[i] = 0xFF;
1219:stk500boot.c  **** //                if (pagecmp(fa, Buff)) {
1220:stk500boot.c  **** //                    flash_erase(fa);		/* Erase a page */
1221:stk500boot.c  **** //                    flash_write(fa, Buff);		/* Write it if the data is available */
1222:stk500boot.c  **** //                }
1223:stk500boot.c  **** //            }
1224:stk500boot.c  **** //    	}
1225:stk500boot.c  **** //        PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1226:stk500boot.c  **** //        
1227:stk500boot.c  **** //    }
1228:stk500boot.c  **** //    
1229:stk500boot.c  **** //    if (pgm_read_word(0) != 0xFFFF)		/* Start application if exist */
1230:stk500boot.c  **** //        asm volatile("jmp 0000");
1231:stk500boot.c  **** //    // SD CARD BOOTLOADER
1232:stk500boot.c  **** 
1233:stk500boot.c  **** 	/*
1234:stk500boot.c  **** 	 * Now leave bootloader
1235:stk500boot.c  **** 	 */
1236:stk500boot.c  **** 
1237:stk500boot.c  **** 	UART_STATUS_REG &= 0xfd;
 2418               		.loc 1 1237 0
 2419               	/* #NOAPP */
 2420 0890 8091 C000 		lds r24,192
 2421 0894 8D7F      		andi r24,lo8(-3)
 2422 0896 8093 C000 		sts 192,r24
1238:stk500boot.c  **** 	boot_rww_enable(); // enable application section
 2423               		.loc 1 1238 0
 2424 089a 81E1      		ldi r24,lo8(17)
 2425               	/* #APP */
 2426               	 ;  1238 "stk500boot.c" 1
 2427 089c 8093 5700 		sts 87, r24
 2428 08a0 E895      		spm
 2429               		
 2430               	 ;  0 "" 2
1239:stk500boot.c  **** 
1240:stk500boot.c  **** 	asm volatile(
 2431               		.loc 1 1240 0
 2432               	 ;  1240 "stk500boot.c" 1
 2433 08a2 EE27      		clr	r30		
 2434 08a4 FF27      		clr	r31		
 2435 08a6 0994      		ijmp	
 2436               		
 2437               	 ;  0 "" 2
 2438               	/* #NOAPP */
 2439               	.L130:
 2440 08a8 00C0      		rjmp .L130
 2441               	.LVL162:
 2442               	.L178:
 780:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 2443               		.loc 1 780 0
 2444 08aa 3BE1      		ldi r19,lo8(27)
 2445 08ac E32E      		mov r14,r19
 2446               	.LVL163:
 779:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 2447               		.loc 1 779 0
 2448 08ae 21E0      		ldi r18,lo8(1)
 2449 08b0 00C0      		rjmp .L83
 2450               	.LVL164:
 2451               	.L138:
 821:stk500boot.c  **** 						msgParseState = ST_START;
 2452               		.loc 1 821 0
 2453 08b2 20E0      		ldi r18,lo8(0)
 2454 08b4 00C0      		rjmp .L83
 2455               	.LVL165:
 2456               	.L179:
 829:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 2457               		.loc 1 829 0
 2458 08b6 26E0      		ldi r18,lo8(6)
 2459               	.LVL166:
 2460 08b8 00C0      		rjmp .L83
 2461               		.cfi_endproc
 2462               	.LFE21:
 2464               		.text
 2465               	.global	PrintFromPROGMEM
 2467               	PrintFromPROGMEM:
 2468               	.LFB22:
1241:stk500boot.c  **** 			"clr	r30		\n\t"
1242:stk500boot.c  **** 			"clr	r31		\n\t"
1243:stk500boot.c  **** 			"ijmp	\n\t"
1244:stk500boot.c  **** 	);
1245:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1246:stk500boot.c  **** //					"push r1" "\n\t"
1247:stk500boot.c  **** //					"ret"	 "\n\t"
1248:stk500boot.c  **** //					::);
1249:stk500boot.c  **** 
1250:stk500boot.c  **** 	/*
1251:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1252:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1253:stk500boot.c  **** 	 * understand this
1254:stk500boot.c  **** 	 */
1255:stk500boot.c  **** 	for (;;)
1256:stk500boot.c  **** 		;
1257:stk500boot.c  **** }
1258:stk500boot.c  **** 
1259:stk500boot.c  **** /*
1260:stk500boot.c  ****  base address = f800
1261:stk500boot.c  **** 
1262:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1263:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1264:stk500boot.c  ****  avrdude: safemode: hfuse reads as DA
1265:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1266:stk500boot.c  ****  avrdude>
1267:stk500boot.c  **** 
1268:stk500boot.c  **** 
1269:stk500boot.c  ****  base address = f000
1270:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1271:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1272:stk500boot.c  ****  avrdude: safemode: hfuse reads as D8
1273:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1274:stk500boot.c  ****  avrdude>
1275:stk500boot.c  ****  */
1276:stk500boot.c  **** 
1277:stk500boot.c  **** //************************************************************************
1278:stk500boot.c  **** #ifdef ENABLE_MONITOR
1279:stk500boot.c  **** #include	<math.h>
1280:stk500boot.c  **** 
1281:stk500boot.c  **** unsigned long gRamIndex;
1282:stk500boot.c  **** unsigned long gFlashIndex;
1283:stk500boot.c  **** unsigned long gEepromIndex;
1284:stk500boot.c  **** 
1285:stk500boot.c  **** #define	true	1
1286:stk500boot.c  **** #define	false	0
1287:stk500boot.c  **** 
1288:stk500boot.c  **** #include	"avr_cpunames.h"
1289:stk500boot.c  **** 
1290:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1291:stk500boot.c  **** #error cpu name not defined
1292:stk500boot.c  **** #endif
1293:stk500boot.c  **** 
1294:stk500boot.c  **** #ifdef _VECTORS_SIZE
1295:stk500boot.c  **** #define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1296:stk500boot.c  **** #else
1297:stk500boot.c  **** #define	kInterruptVectorCount 23
1298:stk500boot.c  **** #endif
1299:stk500boot.c  **** 
1300:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt);
1301:stk500boot.c  **** 
1302:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1303:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = _AVR_CPU_NAME_;
1304:stk500boot.c  **** #else
1305:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = "UNKNOWN";
1306:stk500boot.c  **** #endif
1307:stk500boot.c  **** 
1308:stk500boot.c  **** //************************************************************************
1309:stk500boot.c  **** void PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1310:stk500boot.c  **** {
 2469               		.loc 1 1310 0
 2470               		.cfi_startproc
 2471               	.LVL167:
 2472 02c4 CF93      		push r28
 2473               	.LCFI16:
 2474               		.cfi_def_cfa_offset 4
 2475               		.cfi_offset 28, -3
 2476 02c6 DF93      		push r29
 2477               	.LCFI17:
 2478               		.cfi_def_cfa_offset 5
 2479               		.cfi_offset 29, -4
 2480               	/* prologue: function */
 2481               	/* frame size = 0 */
 2482               	/* stack size = 2 */
 2483               	.L__stack_usage = 2
1311:stk500boot.c  **** 	char theChar;
1312:stk500boot.c  **** 
1313:stk500boot.c  **** 	dataPtr += offset;
 2484               		.loc 1 1313 0
 2485 02c8 EC01      		movw r28,r24
 2486 02ca C60F      		add r28,r22
 2487 02cc D11D      		adc r29,__zero_reg__
 2488               	.LVL168:
 2489               	.L183:
 2490               	.LBB71:
1314:stk500boot.c  **** 
1315:stk500boot.c  **** 	do {
1316:stk500boot.c  **** #if (FLASHEND > 0x10000)
1317:stk500boot.c  **** 		theChar = pgm_read_byte_far((uint16_t)dataPtr++);
 2491               		.loc 1 1317 0
 2492 02ce CE01      		movw r24,r28
 2493 02d0 A0E0      		ldi r26,lo8(0)
 2494 02d2 B0E0      		ldi r27,hi8(0)
 2495               	.LVL169:
 2496 02d4 2196      		adiw r28,1
 2497               	.LVL170:
 2498               	/* #APP */
 2499               	 ;  1317 "stk500boot.c" 1
 2500 02d6 ABBF      		out 59, r26
 2501 02d8 FC01      		movw r30, r24
 2502 02da 8791      		elpm r24, Z+
 2503               		
 2504               	 ;  0 "" 2
 2505               	.LVL171:
 2506               	/* #NOAPP */
 2507               	.LBE71:
1318:stk500boot.c  **** #else
1319:stk500boot.c  **** 		theChar = pgm_read_byte_near((uint16_t)dataPtr++);
1320:stk500boot.c  **** #endif
1321:stk500boot.c  **** 		if (theChar != 0)
 2508               		.loc 1 1321 0
 2509 02dc 8823      		tst r24
 2510 02de 01F0      		breq .L181
1322:stk500boot.c  **** 		{
1323:stk500boot.c  **** 			sendchar(theChar);
 2511               		.loc 1 1323 0
 2512 02e0 0E94 0000 		call sendchar
 2513               	.LVL172:
 2514 02e4 00C0      		rjmp .L183
 2515               	.LVL173:
 2516               	.L181:
 2517               	/* epilogue start */
1324:stk500boot.c  **** 		}
1325:stk500boot.c  **** 	}while (theChar != 0);
1326:stk500boot.c  **** }
 2518               		.loc 1 1326 0
 2519 02e6 DF91      		pop r29
 2520 02e8 CF91      		pop r28
 2521               	.LVL174:
 2522 02ea 0895      		ret
 2523               		.cfi_endproc
 2524               	.LFE22:
 2526               	.global	PrintNewLine
 2528               	PrintNewLine:
 2529               	.LFB23:
1327:stk500boot.c  **** 
1328:stk500boot.c  **** //************************************************************************
1329:stk500boot.c  **** void PrintNewLine(void)
1330:stk500boot.c  **** {
 2530               		.loc 1 1330 0
 2531               		.cfi_startproc
 2532               	/* prologue: function */
 2533               	/* frame size = 0 */
 2534               	/* stack size = 0 */
 2535               	.L__stack_usage = 0
1331:stk500boot.c  **** 	sendchar(0x0d);
 2536               		.loc 1 1331 0
 2537 02ec 8DE0      		ldi r24,lo8(13)
 2538 02ee 0E94 0000 		call sendchar
1332:stk500boot.c  **** 	sendchar(0x0a);
 2539               		.loc 1 1332 0
 2540 02f2 8AE0      		ldi r24,lo8(10)
 2541 02f4 0E94 0000 		call sendchar
 2542               	/* epilogue start */
1333:stk500boot.c  **** }
 2543               		.loc 1 1333 0
 2544 02f8 0895      		ret
 2545               		.cfi_endproc
 2546               	.LFE23:
 2548               	.global	PrintFromPROGMEMln
 2550               	PrintFromPROGMEMln:
 2551               	.LFB24:
1334:stk500boot.c  **** 
1335:stk500boot.c  **** //************************************************************************
1336:stk500boot.c  **** void PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1337:stk500boot.c  **** {
 2552               		.loc 1 1337 0
 2553               		.cfi_startproc
 2554               	.LVL175:
 2555               	/* prologue: function */
 2556               	/* frame size = 0 */
 2557               	/* stack size = 0 */
 2558               	.L__stack_usage = 0
1338:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 2559               		.loc 1 1338 0
 2560 02fa 0E94 0000 		call PrintFromPROGMEM
 2561               	.LVL176:
1339:stk500boot.c  **** 
1340:stk500boot.c  **** 	PrintNewLine();
 2562               		.loc 1 1340 0
 2563 02fe 0E94 0000 		call PrintNewLine
 2564               	/* epilogue start */
1341:stk500boot.c  **** }
 2565               		.loc 1 1341 0
 2566 0302 0895      		ret
 2567               		.cfi_endproc
 2568               	.LFE24:
 2570               	.global	PrintString
 2572               	PrintString:
 2573               	.LFB25:
1342:stk500boot.c  **** 
1343:stk500boot.c  **** //************************************************************************
1344:stk500boot.c  **** void PrintString(char *textString)
1345:stk500boot.c  **** {
 2574               		.loc 1 1345 0
 2575               		.cfi_startproc
 2576               	.LVL177:
 2577 0304 CF93      		push r28
 2578               	.LCFI18:
 2579               		.cfi_def_cfa_offset 4
 2580               		.cfi_offset 28, -3
 2581 0306 DF93      		push r29
 2582               	.LCFI19:
 2583               		.cfi_def_cfa_offset 5
 2584               		.cfi_offset 29, -4
 2585               	/* prologue: function */
 2586               	/* frame size = 0 */
 2587               	/* stack size = 2 */
 2588               	.L__stack_usage = 2
 2589               	.LVL178:
 2590               		.loc 1 1345 0
 2591 0308 EC01      		movw r28,r24
 2592               	.LVL179:
 2593               	.L188:
1346:stk500boot.c  **** 	char theChar;
1347:stk500boot.c  **** 	int ii;
1348:stk500boot.c  **** 
1349:stk500boot.c  **** 	theChar = 1;
1350:stk500boot.c  **** 	ii = 0;
1351:stk500boot.c  **** 	while (theChar != 0)
1352:stk500boot.c  **** 	{
1353:stk500boot.c  **** 		theChar = textString[ii];
 2594               		.loc 1 1353 0
 2595 030a 8991      		ld r24,Y+
 2596               	.LVL180:
1354:stk500boot.c  **** 		if (theChar != 0)
 2597               		.loc 1 1354 0
 2598 030c 8823      		tst r24
 2599 030e 01F0      		breq .L186
1355:stk500boot.c  **** 		{
1356:stk500boot.c  **** 			sendchar(theChar);
 2600               		.loc 1 1356 0
 2601 0310 0E94 0000 		call sendchar
 2602               	.LVL181:
 2603 0314 00C0      		rjmp .L188
 2604               	.LVL182:
 2605               	.L186:
 2606               	/* epilogue start */
1357:stk500boot.c  **** 		}
1358:stk500boot.c  **** 		ii++;
1359:stk500boot.c  **** 	}
1360:stk500boot.c  **** }
 2607               		.loc 1 1360 0
 2608 0316 DF91      		pop r29
 2609 0318 CF91      		pop r28
 2610 031a 0895      		ret
 2611               		.cfi_endproc
 2612               	.LFE25:
 2614               	.global	PrintHexByte
 2616               	PrintHexByte:
 2617               	.LFB26:
1361:stk500boot.c  **** 
1362:stk500boot.c  **** //************************************************************************
1363:stk500boot.c  **** void PrintHexByte(unsigned char theByte)
1364:stk500boot.c  **** {
 2618               		.loc 1 1364 0
 2619               		.cfi_startproc
 2620               	.LVL183:
 2621 031c CF93      		push r28
 2622               	.LCFI20:
 2623               		.cfi_def_cfa_offset 4
 2624               		.cfi_offset 28, -3
 2625               	/* prologue: function */
 2626               	/* frame size = 0 */
 2627               	/* stack size = 1 */
 2628               	.L__stack_usage = 1
 2629 031e C82F      		mov r28,r24
1365:stk500boot.c  **** 	char theChar;
1366:stk500boot.c  **** 
1367:stk500boot.c  **** 	theChar = 0x30 + ((theByte >> 4) & 0x0f);
 2630               		.loc 1 1367 0
 2631 0320 982F      		mov r25,r24
 2632 0322 9295      		swap r25
 2633 0324 9F70      		andi r25,lo8(15)
 2634 0326 892F      		mov r24,r25
 2635               	.LVL184:
 2636 0328 805D      		subi r24,lo8(-(48))
 2637               	.LVL185:
1368:stk500boot.c  **** 	if (theChar > 0x39)
 2638               		.loc 1 1368 0
 2639 032a 8A33      		cpi r24,lo8(58)
 2640 032c 00F0      		brlo .L190
1369:stk500boot.c  **** 	{
1370:stk500boot.c  **** 		theChar += 7;
 2641               		.loc 1 1370 0
 2642 032e 895F      		subi r24,lo8(-(7))
 2643               	.LVL186:
 2644               	.L190:
1371:stk500boot.c  **** 	}
1372:stk500boot.c  **** 	sendchar(theChar );
 2645               		.loc 1 1372 0
 2646 0330 0E94 0000 		call sendchar
 2647               	.LVL187:
1373:stk500boot.c  **** 
1374:stk500boot.c  **** 	theChar = 0x30 + (theByte & 0x0f);
 2648               		.loc 1 1374 0
 2649 0334 CF70      		andi r28,lo8(15)
 2650               	.LVL188:
 2651 0336 8C2F      		mov r24,r28
 2652 0338 805D      		subi r24,lo8(-(48))
 2653               	.LVL189:
1375:stk500boot.c  **** 	if (theChar > 0x39)
 2654               		.loc 1 1375 0
 2655 033a 8A33      		cpi r24,lo8(58)
 2656 033c 00F0      		brlo .L191
1376:stk500boot.c  **** 	{
1377:stk500boot.c  **** 		theChar += 7;
 2657               		.loc 1 1377 0
 2658 033e 895F      		subi r24,lo8(-(7))
 2659               	.LVL190:
 2660               	.L191:
1378:stk500boot.c  **** 	}
1379:stk500boot.c  **** 	sendchar(theChar );
 2661               		.loc 1 1379 0
 2662 0340 0E94 0000 		call sendchar
 2663               	.LVL191:
 2664               	/* epilogue start */
1380:stk500boot.c  **** }
 2665               		.loc 1 1380 0
 2666 0344 CF91      		pop r28
 2667 0346 0895      		ret
 2668               		.cfi_endproc
 2669               	.LFE26:
 2671               	.global	PrintDecInt
 2673               	PrintDecInt:
 2674               	.LFB27:
1381:stk500boot.c  **** 
1382:stk500boot.c  **** //************************************************************************
1383:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt)
1384:stk500boot.c  **** {
 2675               		.loc 1 1384 0
 2676               		.cfi_startproc
 2677               	.LVL192:
 2678 0348 0F93      		push r16
 2679               	.LCFI21:
 2680               		.cfi_def_cfa_offset 4
 2681               		.cfi_offset 16, -3
 2682 034a 1F93      		push r17
 2683               	.LCFI22:
 2684               		.cfi_def_cfa_offset 5
 2685               		.cfi_offset 17, -4
 2686 034c CF93      		push r28
 2687               	.LCFI23:
 2688               		.cfi_def_cfa_offset 6
 2689               		.cfi_offset 28, -5
 2690 034e DF93      		push r29
 2691               	.LCFI24:
 2692               		.cfi_def_cfa_offset 7
 2693               		.cfi_offset 29, -6
 2694               	/* prologue: function */
 2695               	/* frame size = 0 */
 2696               	/* stack size = 4 */
 2697               	.L__stack_usage = 4
 2698 0350 EC01      		movw r28,r24
 2699 0352 8B01      		movw r16,r22
 2700               	.LVL193:
1385:stk500boot.c  **** 	int theChar;
1386:stk500boot.c  **** 	int myNumber;
1387:stk500boot.c  **** 
1388:stk500boot.c  **** 	myNumber = theNumber;
1389:stk500boot.c  **** 
1390:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 2701               		.loc 1 1390 0
 2702 0354 8536      		cpi r24,101
 2703 0356 9105      		cpc r25,__zero_reg__
 2704 0358 04F4      		brge .L193
 2705               	.LVL194:
 2706               		.loc 1 1390 0 is_stmt 0 discriminator 1
 2707 035a 6330      		cpi r22,3
 2708 035c 7105      		cpc r23,__zero_reg__
 2709 035e 04F0      		brlt .L194
 2710               	.LVL195:
 2711               	.L193:
1391:stk500boot.c  **** 	{
1392:stk500boot.c  **** 		theChar = 0x30 + myNumber / 100;
 2712               		.loc 1 1392 0 is_stmt 1
 2713 0360 CE01      		movw r24,r28
 2714               	.LVL196:
 2715 0362 64E6      		ldi r22,lo8(100)
 2716 0364 70E0      		ldi r23,hi8(100)
 2717 0366 0E94 0000 		call __divmodhi4
1393:stk500boot.c  **** 		sendchar(theChar );
 2718               		.loc 1 1393 0
 2719 036a 862F      		mov r24,r22
 2720 036c 805D      		subi r24,lo8(-(48))
 2721 036e 0E94 0000 		call sendchar
 2722               	.LVL197:
 2723               	.L194:
1394:stk500boot.c  **** 	}
1395:stk500boot.c  **** 
1396:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 2724               		.loc 1 1396 0
 2725 0372 CB30      		cpi r28,11
 2726 0374 D105      		cpc r29,__zero_reg__
 2727 0376 04F4      		brge .L195
 2728               		.loc 1 1396 0 is_stmt 0 discriminator 1
 2729 0378 0230      		cpi r16,2
 2730 037a 1105      		cpc r17,__zero_reg__
 2731 037c 04F0      		brlt .L196
 2732               	.L195:
 2733               	.LVL198:
1397:stk500boot.c  **** 	{
1398:stk500boot.c  **** 		theChar = 0x30 + ((myNumber % 100) / 10 );
 2734               		.loc 1 1398 0 is_stmt 1
 2735 037e CE01      		movw r24,r28
 2736 0380 64E6      		ldi r22,lo8(100)
 2737 0382 70E0      		ldi r23,hi8(100)
 2738 0384 0E94 0000 		call __divmodhi4
 2739 0388 6AE0      		ldi r22,lo8(10)
 2740 038a 70E0      		ldi r23,hi8(10)
 2741 038c 0E94 0000 		call __divmodhi4
1399:stk500boot.c  **** 		sendchar(theChar );
 2742               		.loc 1 1399 0
 2743 0390 862F      		mov r24,r22
 2744 0392 805D      		subi r24,lo8(-(48))
 2745 0394 0E94 0000 		call sendchar
 2746               	.LVL199:
 2747               	.L196:
1400:stk500boot.c  **** 	}
1401:stk500boot.c  **** 	theChar = 0x30 + (myNumber % 10);
 2748               		.loc 1 1401 0
 2749 0398 CE01      		movw r24,r28
 2750 039a 6AE0      		ldi r22,lo8(10)
 2751 039c 70E0      		ldi r23,hi8(10)
 2752 039e 0E94 0000 		call __divmodhi4
1402:stk500boot.c  **** 	sendchar(theChar );
 2753               		.loc 1 1402 0
 2754 03a2 805D      		subi r24,lo8(-(48))
 2755 03a4 0E94 0000 		call sendchar
 2756               	/* epilogue start */
1403:stk500boot.c  **** }
 2757               		.loc 1 1403 0
 2758 03a8 DF91      		pop r29
 2759 03aa CF91      		pop r28
 2760               	.LVL200:
 2761 03ac 1F91      		pop r17
 2762 03ae 0F91      		pop r16
 2763               	.LVL201:
 2764 03b0 0895      		ret
 2765               		.cfi_endproc
 2766               	.LFE27:
 2768               	.global	gTextMsg_CPU_Name
 2769               		.section	.progmem.data,"a",@progbits
 2772               	gTextMsg_CPU_Name:
 2773 0000 4154 6D65 		.string	"ATmega2560"
 2773      6761 3235 
 2773      3630 00
 2774               		.comm gEepromIndex,4,1
 2775               		.comm gFlashIndex,4,1
 2776               		.comm gRamIndex,4,1
 2777               	.global	check
 2778               		.data
 2781               	check:
 2782 0000 01        		.byte	1
 2783               	.global	app_start
 2784               	.global	app_start
 2785               		.section .bss
 2788               	app_start:
 2789 0000 0000      		.skip 2,0
 2790               		.comm Buff,256,1
 2791               		.data
 2794               	CSWTCH.17:
 2795 0001 0F        		.byte	15
 2796 0002 02        		.byte	2
 2797 0003 0A        		.byte	10
 2798               		.text
 2799               	.Letext0:
 2800               		.file 3 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 2801               		.file 4 "integer.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stk500boot.c
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2      *ABS*:0000003f __SREG__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:3      *ABS*:0000003e __SP_H__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:4      *ABS*:0000003d __SP_L__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:5      *ABS*:00000034 __CCP__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:14     .text:00000000 sendchar
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:44     .text:00000018 transfer
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:71     .text:00000024 setDataMode
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:93     .text:0000002e setBitOrder
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:124    .text:00000040 setClockDivider
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:157    .text:0000005c readStatus
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:184    .text:0000006e busy
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:203    .text:00000076 command
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:238    .text:0000008e spiReadReg
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:307    .init9:00000000 __jumpMain
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:318    *ABS*:000021ff __stack
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:733    .text.startup:00000000 main
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:357    .text:000000d4 delay_ms
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:401    .text:000000f2 dec_hex
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2788   .bss:00000000 app_start
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2794   .data:00000001 CSWTCH.17
                            *COM*:00000100 Buff
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2781   .data:00000000 check
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2467   .text:000002c4 PrintFromPROGMEM
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2528   .text:000002ec PrintNewLine
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2550   .text:000002fa PrintFromPROGMEMln
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2572   .text:00000304 PrintString
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2616   .text:0000031c PrintHexByte
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2673   .text:00000348 PrintDecInt
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccoJetuz.s:2772   .progmem.data:00000000 gTextMsg_CPU_Name
                            *COM*:00000004 gEepromIndex
                            *COM*:00000004 gFlashIndex
                            *COM*:00000004 gRamIndex

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__eewr_byte_m2560
__eerd_byte_m2560
flash_erase
memset
flash_write
__divmodhi4
