   1               		.file	"stk500boot.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	sendchar:
  15               	.LFB17:
  16               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  ****  Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****  Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  ****  Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  ****  File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  ****  Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  ****  Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  ****  License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  ****  Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  ****  Date:      17 October 2007
  12:stk500boot.c  ****  Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte r
  13:stk500boot.c  ****  Compiler:  WINAVR20060421
  14:stk500boot.c  ****  Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  ****  DESCRIPTION:
  17:stk500boot.c  ****  This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****  read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****  an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****  is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****  "reset" vector in Application area.
  22:stk500boot.c  ****  Size fits into a 1024 word bootloader section
  23:stk500boot.c  ****  when compiled with avr-gcc 4.1
  24:stk500boot.c  ****  (direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  ****  USAGE:
  27:stk500boot.c  ****  - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****  - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****  - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****  - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****  for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****  - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****  - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****  - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****  - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****  - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****  - AVRISP will detect the bootloader
  38:stk500boot.c  ****  - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  ****  Note:
  41:stk500boot.c  ****  Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****  is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****  Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  ****  AVRdude:
  46:stk500boot.c  ****  Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  ****  Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  ****  Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  ****  NOTES:
  51:stk500boot.c  ****  Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****  Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  ****  LICENSE:
  55:stk500boot.c  ****  Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****  This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****  it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****  the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****  any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****  This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****  but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****  GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  ****  *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //************************************************************************
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** #include <string.h>
 115:stk500boot.c  **** #include "pff.h"
 116:stk500boot.c  **** 
 117:stk500boot.c  **** void flash_erase(DWORD); /* Erase a flash page (asmfunc.S) */
 118:stk500boot.c  **** void flash_write(DWORD, const BYTE*); /* Program a flash page (asmfunc.S) */
 119:stk500boot.c  **** 
 120:stk500boot.c  **** #define BLINK_LED_WHILE_WAITING
 121:stk500boot.c  **** //#define _DEBUG_WITH_LEDS_
 122:stk500boot.c  **** //#define _DEBUG_SERIAL_
 123:stk500boot.c  **** 
 124:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 125:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 126:stk500boot.c  **** #undef		ENABLE_MONITOR
 127:stk500boot.c  **** #define		ENABLE_MONITOR
 128:stk500boot.c  **** #endif
 129:stk500boot.c  **** 
 130:stk500boot.c  **** #ifndef EEWE
 131:stk500boot.c  **** #define EEWE    1
 132:stk500boot.c  **** #endif
 133:stk500boot.c  **** #ifndef EEMWE
 134:stk500boot.c  **** #define EEMWE   2
 135:stk500boot.c  **** #endif
 136:stk500boot.c  **** 
 137:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 138:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 139:stk500boot.c  **** 
 140:stk500boot.c  **** /*
 141:stk500boot.c  ****  * Uncomment the following lines to save code space
 142:stk500boot.c  ****  */
 143:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 144:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 145:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 146:stk500boot.c  **** //
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 149:stk500boot.c  **** //*	indicates that bootloader is active
 150:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 151:stk500boot.c  **** //************************************************************************
 152:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 153:stk500boot.c  **** 
 154:stk500boot.c  **** 
 155:stk500boot.c  **** #define SPI_DDRA DDRA
 156:stk500boot.c  **** #define SPI_PORTA PORTA
 157:stk500boot.c  **** #define SPI_DDRB DDRB
 158:stk500boot.c  **** #define SPI_PORTB PORTB
 159:stk500boot.c  **** 
 160:stk500boot.c  **** #define SCK PINB1 //Pin 52
 161:stk500boot.c  **** #define MISO PINB3 //Pin 50
 162:stk500boot.c  **** #define MOSI PINB2 //Pin 51
 163:stk500boot.c  **** #define SS PINB4 //Pin 22
 164:stk500boot.c  **** //#define SS_MASTER PINB0 //Pin 53
 165:stk500boot.c  **** #define LED1 PINB5
 166:stk500boot.c  **** #define LED2 PINB6
 167:stk500boot.c  **** #define LED3 PINB7
 168:stk500boot.c  **** 		
 169:stk500boot.c  **** 
 170:stk500boot.c  **** #define LED1_LOW() SPI_PORTB &= ~(_BV(LED1))
 171:stk500boot.c  **** #define LED1_HIGH() SPI_PORTB |= _BV(LED1)
 172:stk500boot.c  **** #define LED2_LOW() SPI_PORTB &= ~(_BV(LED2))
 173:stk500boot.c  **** #define LED2_HIGH() SPI_PORTB |= _BV(LED2)
 174:stk500boot.c  **** #define LED3_LOW() SPI_PORTB &= ~(_BV(LED3))
 175:stk500boot.c  **** #define LED3_HIGH() SPI_PORTB |= _BV(LED3)
 176:stk500boot.c  **** 
 177:stk500boot.c  **** 
 178:stk500boot.c  **** #define SS_LOW() SPI_PORTB &= ~(_BV(SS))
 179:stk500boot.c  **** #define SS_HIGH() SPI_PORTB |= _BV(SS)
 180:stk500boot.c  **** //#define SS_MASTER_LOW() SPI_PORTB &= ~_BV(SS_MASTER)
 181:stk500boot.c  **** //#define SS_MASTER_HIGH() SPI_PORTB |= _BV(SS_MASTER)
 182:stk500boot.c  **** 
 183:stk500boot.c  **** /*
 184:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 185:stk500boot.c  ****  */
 186:stk500boot.c  **** #ifndef F_CPU
 187:stk500boot.c  **** #define F_CPU 16000000UL
 188:stk500boot.c  **** #endif
 189:stk500boot.c  **** 
 190:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 191:stk500boot.c  **** /*
 192:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 193:stk500boot.c  ****  */
 194:stk500boot.c  **** 
 195:stk500boot.c  **** #ifndef BAUDRATE
 196:stk500boot.c  **** #define BAUDRATE 115200
 197:stk500boot.c  **** #endif
 198:stk500boot.c  **** 
 199:stk500boot.c  **** /*
 200:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 201:stk500boot.c  ****  */
 202:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 203:stk500boot.c  **** #if defined (__AVR_ATmega32__)
 204:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 0
 205:stk500boot.c  **** #else
 206:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 1
 207:stk500boot.c  **** #endif
 208:stk500boot.c  **** #endif
 209:stk500boot.c  **** 
 210:stk500boot.c  **** /*
 211:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 212:stk500boot.c  ****  */
 213:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 214:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 215:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 216:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 217:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 218:stk500boot.c  **** 
 219:stk500boot.c  **** /*
 220:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 221:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 222:stk500boot.c  ****  */
 223:stk500boot.c  **** //#define BOOTSIZE 1024
 224:stk500boot.c  **** #if FLASHEND > 0x0F000
 225:stk500boot.c  **** #define BOOTSIZE 8192
 226:stk500boot.c  **** #else
 227:stk500boot.c  **** #define BOOTSIZE 2048
 228:stk500boot.c  **** #endif
 229:stk500boot.c  **** 
 230:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 231:stk500boot.c  **** 
 232:stk500boot.c  **** /*
 233:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 234:stk500boot.c  ****  */
 235:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 236:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9307
 237:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 238:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9403
 239:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 240:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9502
 241:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 242:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9306
 243:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 244:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9308
 245:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 246:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9404
 247:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 248:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9702
 249:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 250:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9703
 251:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 252:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9801
 253:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 254:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9802
 255:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 256:stk500boot.c  **** #define SIGNATURE_BYTES 0x1e9705
 257:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 258:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9608
 259:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 260:stk500boot.c  **** #define SIGNATURE_BYTES  0x1E9602
 261:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 262:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9405
 263:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 264:stk500boot.c  **** #define SIGNATURE_BYTES  0x1e9782
 265:stk500boot.c  **** #else
 266:stk500boot.c  **** #error "no signature definition for MCU available"
 267:stk500boot.c  **** #endif
 268:stk500boot.c  **** 
 269:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 270:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR1L
 271:stk500boot.c  **** #define	UART_STATUS_REG				UCSR1A
 272:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR1B
 273:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN1
 274:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN1
 275:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC1
 276:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC1
 277:stk500boot.c  **** #define	UART_DATA_REG				UDR1
 278:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X1
 279:stk500boot.c  **** 
 280:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 281:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 282:stk500boot.c  **** /* ATMega8 with one USART */
 283:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 284:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 285:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 286:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 287:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 288:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 289:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 290:stk500boot.c  **** #define	UART_DATA_REG				UDR
 291:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 292:stk500boot.c  **** 
 293:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 294:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 295:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 296:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 297:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 298:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 299:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 300:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 301:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 302:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 303:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 304:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 305:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 306:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 307:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 308:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 309:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 310:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 311:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 312:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 313:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 314:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 315:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 316:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 317:stk500boot.c  **** //* catch all
 318:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRRL
 319:stk500boot.c  **** #define	UART_STATUS_REG				UCSRA
 320:stk500boot.c  **** #define	UART_CONTROL_REG			UCSRB
 321:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN
 322:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN
 323:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC
 324:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC
 325:stk500boot.c  **** #define	UART_DATA_REG				UDR
 326:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X
 327:stk500boot.c  **** #else
 328:stk500boot.c  **** #error "no UART definition for MCU available"
 329:stk500boot.c  **** #endif
 330:stk500boot.c  **** 
 331:stk500boot.c  **** #define SPI_MODE_MASK 0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
 332:stk500boot.c  **** #define SPI_CLOCK_MASK 0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
 333:stk500boot.c  **** #define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR
 334:stk500boot.c  **** 
 335:stk500boot.c  **** #define LSBFIRST 0
 336:stk500boot.c  **** #define MSBFIRST 1
 337:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
 338:stk500boot.c  **** 	SPDR = _data;
 339:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
 340:stk500boot.c  **** 		;
 341:stk500boot.c  **** 	return SPDR;
 342:stk500boot.c  **** }
 343:stk500boot.c  **** void setDataMode(uint8_t mode) {
 344:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
 345:stk500boot.c  **** }
 346:stk500boot.c  **** 
 347:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
 348:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
 349:stk500boot.c  **** 		SPCR |= _BV(DORD);
 350:stk500boot.c  **** 	} else {
 351:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 352:stk500boot.c  **** 	}
 353:stk500boot.c  **** }
 354:stk500boot.c  **** 
 355:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 356:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 357:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 358:stk500boot.c  **** }
 359:stk500boot.c  **** 
 360:stk500boot.c  **** /// return the STATUS register
 361:stk500boot.c  **** #define SPIFLASH_STATUSREAD       0x05
 362:stk500boot.c  **** uint8_t readStatus() {
 363:stk500boot.c  **** 	SS_LOW();
 364:stk500boot.c  **** //	SS_MASTER_HIGH();
 365:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 366:stk500boot.c  **** 	uint8_t status = transfer(0);
 367:stk500boot.c  **** 	SS_HIGH();
 368:stk500boot.c  **** //	SS_MASTER_LOW();
 369:stk500boot.c  **** 	return status;
 370:stk500boot.c  **** }
 371:stk500boot.c  **** uint8_t busy() {
 372:stk500boot.c  **** 	return readStatus() & 1;
 373:stk500boot.c  **** }
 374:stk500boot.c  **** 
 375:stk500boot.c  **** void command(uint8_t cmd) {
 376:stk500boot.c  **** 
 377:stk500boot.c  **** 	while (busy())
 378:stk500boot.c  **** 		; //wait for any write/erase to complete
 379:stk500boot.c  **** 	SS_LOW();
 380:stk500boot.c  **** 	transfer(cmd);
 381:stk500boot.c  **** }
 382:stk500boot.c  **** 
 383:stk500boot.c  **** #define SPIFLASH_ARRAYREADLOWFREQ 0x03
 384:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 385:stk500boot.c  **** 	SS_LOW();
 386:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 387:stk500boot.c  **** 	transfer(address >> 16);
 388:stk500boot.c  **** 	transfer(address >> 8);
 389:stk500boot.c  **** 	transfer(address);
 390:stk500boot.c  **** 	uint8_t result = transfer(0);
 391:stk500boot.c  **** 	SS_HIGH();
 392:stk500boot.c  **** 	return result;
 393:stk500boot.c  **** }
 394:stk500boot.c  **** 
 395:stk500boot.c  **** /*
 396:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 397:stk500boot.c  ****  */
 398:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 399:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 400:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 401:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 402:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 403:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 404:stk500boot.c  **** #else
 405:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 406:stk500boot.c  **** #endif
 407:stk500boot.c  **** 
 408:stk500boot.c  **** /*
 409:stk500boot.c  ****  * States used in the receive state machine
 410:stk500boot.c  ****  */
 411:stk500boot.c  **** #define	ST_START		0
 412:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 413:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 414:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 415:stk500boot.c  **** #define ST_GET_TOKEN	4
 416:stk500boot.c  **** #define ST_GET_DATA		5
 417:stk500boot.c  **** #define	ST_GET_CHECK	6
 418:stk500boot.c  **** #define	ST_PROCESS		7
 419:stk500boot.c  **** 
 420:stk500boot.c  **** /*
 421:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 422:stk500boot.c  ****  */
 423:stk500boot.c  **** #if defined(RAMPZ)
 424:stk500boot.c  **** typedef uint32_t address_t;
 425:stk500boot.c  **** #else
 426:stk500boot.c  **** typedef uint16_t address_t;
 427:stk500boot.c  **** #endif
 428:stk500boot.c  **** 
 429:stk500boot.c  **** /*
 430:stk500boot.c  ****  * function prototypes
 431:stk500boot.c  ****  */
 432:stk500boot.c  **** static void sendchar(char c);
 433:stk500boot.c  **** 
 434:stk500boot.c  **** // SDCARD BOOTLOADER
 435:stk500boot.c  **** 
 436:stk500boot.c  **** unsigned char Buff[SPM_PAGESIZE]; /* Page data buffer */
 437:stk500boot.c  **** 
 438:stk500boot.c  **** // SDCARD BOOTLOADER
 439:stk500boot.c  **** 
 440:stk500boot.c  **** /*
 441:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 442:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 443:stk500boot.c  ****  */
 444:stk500boot.c  **** void __jumpMain(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 445:stk500boot.c  **** #include <avr/sfr_defs.h>
 446:stk500boot.c  **** 
 447:stk500boot.c  **** //#define	SPH_REG	0x3E
 448:stk500boot.c  **** //#define	SPL_REG	0x3D
 449:stk500boot.c  **** 
 450:stk500boot.c  **** //*****************************************************************************
 451:stk500boot.c  **** void __jumpMain(void) {
 452:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 453:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 454:stk500boot.c  **** 
 455:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 456:stk500boot.c  **** 
 457:stk500boot.c  **** //*	set stack pointer to top of RAM
 458:stk500boot.c  **** 
 459:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 460:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 461:stk500boot.c  **** 
 462:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 463:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 464:stk500boot.c  **** 
 465:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 466:stk500boot.c  **** 	// GCC depends on register r1 set to 0
 467:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 468:stk500boot.c  **** 	// set SREG to 0
 469:stk500boot.c  **** 	asm volatile ( "jmp main");
 470:stk500boot.c  **** 	// jump to main()
 471:stk500boot.c  **** }
 472:stk500boot.c  **** 
 473:stk500boot.c  **** //*****************************************************************************
 474:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 475:stk500boot.c  **** 	unsigned int i;
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 477:stk500boot.c  **** 		_delay_ms(0.5);
 478:stk500boot.c  **** 	}
 479:stk500boot.c  **** }
 480:stk500boot.c  **** 
 481:stk500boot.c  **** //*****************************************************************************
 482:stk500boot.c  **** /*
 483:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 484:stk500boot.c  ****  */
 485:stk500boot.c  **** static void sendchar(char c) {
  17               		.loc 1 485 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 486:stk500boot.c  **** 	UART_DATA_REG = c; // prepare transmission
  24               		.loc 1 486 0
  25 0000 8093 C600 		sts 198,r24
  26               	.LVL1:
  27               	.L2:
 487:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)))
  28               		.loc 1 487 0 discriminator 1
  29 0004 8091 C000 		lds r24,192
  30 0008 86FF      		sbrs r24,6
  31 000a 00C0      		rjmp .L2
 488:stk500boot.c  **** 		; // wait until byte sent
 489:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE); // delete TXCflag
  32               		.loc 1 489 0
  33 000c 8091 C000 		lds r24,192
  34 0010 8064      		ori r24,lo8(64)
  35 0012 8093 C000 		sts 192,r24
  36               	/* epilogue start */
 490:stk500boot.c  **** }
  37               		.loc 1 490 0
  38 0016 0895      		ret
  39               		.cfi_endproc
  40               	.LFE17:
  42               	.global	transfer
  44               	transfer:
  45               	.LFB7:
 337:stk500boot.c  **** uint8_t transfer(uint8_t _data) {
  46               		.loc 1 337 0
  47               		.cfi_startproc
  48               	.LVL2:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 338:stk500boot.c  **** 	SPDR = _data;
  53               		.loc 1 338 0
  54 0018 8EBD      		out 78-32,r24
  55               	.L5:
 339:stk500boot.c  **** 	while (!(SPSR & _BV(SPIF)))
  56               		.loc 1 339 0 discriminator 1
  57 001a 0DB4      		in __tmp_reg__,77-32
  58 001c 07FE      		sbrs __tmp_reg__,7
  59 001e 00C0      		rjmp .L5
 341:stk500boot.c  **** 	return SPDR;
  60               		.loc 1 341 0
  61 0020 8EB5      		in r24,78-32
  62               	.LVL3:
  63               	/* epilogue start */
 342:stk500boot.c  **** }
  64               		.loc 1 342 0
  65 0022 0895      		ret
  66               		.cfi_endproc
  67               	.LFE7:
  69               	.global	setDataMode
  71               	setDataMode:
  72               	.LFB8:
 343:stk500boot.c  **** void setDataMode(uint8_t mode) {
  73               		.loc 1 343 0
  74               		.cfi_startproc
  75               	.LVL4:
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
 344:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
  80               		.loc 1 344 0
  81 0024 9CB5      		in r25,76-32
  82 0026 937F      		andi r25,lo8(-13)
  83 0028 982B      		or r25,r24
  84 002a 9CBD      		out 76-32,r25
  85               	/* epilogue start */
 345:stk500boot.c  **** }
  86               		.loc 1 345 0
  87 002c 0895      		ret
  88               		.cfi_endproc
  89               	.LFE8:
  91               	.global	setBitOrder
  93               	setBitOrder:
  94               	.LFB9:
 347:stk500boot.c  **** void setBitOrder(uint8_t bitOrder) {
  95               		.loc 1 347 0
  96               		.cfi_startproc
  97               	.LVL5:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 348:stk500boot.c  **** 	if (bitOrder == LSBFIRST) {
 102               		.loc 1 348 0
 103 002e 8823      		tst r24
 104 0030 01F4      		brne .L9
 349:stk500boot.c  **** 		SPCR |= _BV(DORD);
 105               		.loc 1 349 0
 106 0032 8CB5      		in r24,76-32
 107               	.LVL6:
 108 0034 8062      		ori r24,lo8(32)
 109 0036 00C0      		rjmp .L11
 110               	.LVL7:
 111               	.L9:
 351:stk500boot.c  **** 		SPCR &= ~(_BV(DORD));
 112               		.loc 1 351 0
 113 0038 8CB5      		in r24,76-32
 114               	.LVL8:
 115 003a 8F7D      		andi r24,lo8(-33)
 116               	.L11:
 117 003c 8CBD      		out 76-32,r24
 118 003e 0895      		ret
 119               		.cfi_endproc
 120               	.LFE9:
 122               	.global	setClockDivider
 124               	setClockDivider:
 125               	.LFB10:
 355:stk500boot.c  **** void setClockDivider(uint8_t rate) {
 126               		.loc 1 355 0
 127               		.cfi_startproc
 128               	.LVL9:
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 0 */
 132               	.L__stack_usage = 0
 356:stk500boot.c  **** 	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
 133               		.loc 1 356 0
 134 0040 2CB5      		in r18,76-32
 135 0042 982F      		mov r25,r24
 136 0044 9370      		andi r25,lo8(3)
 137 0046 2C7F      		andi r18,lo8(-4)
 138 0048 922B      		or r25,r18
 139 004a 9CBD      		out 76-32,r25
 357:stk500boot.c  **** 	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
 140               		.loc 1 357 0
 141 004c 9DB5      		in r25,77-32
 142 004e 8695      		lsr r24
 143 0050 8695      		lsr r24
 144               	.LVL10:
 145 0052 8170      		andi r24,lo8(1)
 146 0054 9E7F      		andi r25,lo8(-2)
 147 0056 892B      		or r24,r25
 148 0058 8DBD      		out 77-32,r24
 149               	/* epilogue start */
 358:stk500boot.c  **** }
 150               		.loc 1 358 0
 151 005a 0895      		ret
 152               		.cfi_endproc
 153               	.LFE10:
 155               	.global	readStatus
 157               	readStatus:
 158               	.LFB11:
 362:stk500boot.c  **** uint8_t readStatus() {
 159               		.loc 1 362 0
 160               		.cfi_startproc
 161               	/* prologue: function */
 162               	/* frame size = 0 */
 163               	/* stack size = 0 */
 164               	.L__stack_usage = 0
 363:stk500boot.c  **** 	SS_LOW();
 165               		.loc 1 363 0
 166 005c 2C98      		cbi 37-32,4
 365:stk500boot.c  **** 	transfer(SPIFLASH_STATUSREAD);
 167               		.loc 1 365 0
 168 005e 85E0      		ldi r24,lo8(5)
 169 0060 0E94 0000 		call transfer
 366:stk500boot.c  **** 	uint8_t status = transfer(0);
 170               		.loc 1 366 0
 171 0064 80E0      		ldi r24,lo8(0)
 172 0066 0E94 0000 		call transfer
 173               	.LVL11:
 367:stk500boot.c  **** 	SS_HIGH();
 174               		.loc 1 367 0
 175 006a 2C9A      		sbi 37-32,4
 176               	/* epilogue start */
 370:stk500boot.c  **** }
 177               		.loc 1 370 0
 178 006c 0895      		ret
 179               		.cfi_endproc
 180               	.LFE11:
 182               	.global	busy
 184               	busy:
 185               	.LFB12:
 371:stk500boot.c  **** uint8_t busy() {
 186               		.loc 1 371 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 372:stk500boot.c  **** 	return readStatus() & 1;
 192               		.loc 1 372 0
 193 006e 0E94 0000 		call readStatus
 373:stk500boot.c  **** }
 194               		.loc 1 373 0
 195 0072 8170      		andi r24,lo8(1)
 196               	/* epilogue start */
 197 0074 0895      		ret
 198               		.cfi_endproc
 199               	.LFE12:
 201               	.global	command
 203               	command:
 204               	.LFB13:
 375:stk500boot.c  **** void command(uint8_t cmd) {
 205               		.loc 1 375 0
 206               		.cfi_startproc
 207               	.LVL12:
 208 0076 CF93      		push r28
 209               	.LCFI0:
 210               		.cfi_def_cfa_offset 4
 211               		.cfi_offset 28, -3
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 1 */
 215               	.L__stack_usage = 1
 216 0078 C82F      		mov r28,r24
 217               	.LVL13:
 218               	.L16:
 377:stk500boot.c  **** 	while (busy())
 219               		.loc 1 377 0 discriminator 1
 220 007a 0E94 0000 		call busy
 221 007e 8823      		tst r24
 222 0080 01F4      		brne .L16
 379:stk500boot.c  **** 	SS_LOW();
 223               		.loc 1 379 0
 224 0082 2C98      		cbi 37-32,4
 380:stk500boot.c  **** 	transfer(cmd);
 225               		.loc 1 380 0
 226 0084 8C2F      		mov r24,r28
 227 0086 0E94 0000 		call transfer
 228               	/* epilogue start */
 381:stk500boot.c  **** }
 229               		.loc 1 381 0
 230 008a CF91      		pop r28
 231               	.LVL14:
 232 008c 0895      		ret
 233               		.cfi_endproc
 234               	.LFE13:
 236               	.global	spiReadReg
 238               	spiReadReg:
 239               	.LFB14:
 384:stk500boot.c  **** uint8_t spiReadReg(uint32_t address) {
 240               		.loc 1 384 0
 241               		.cfi_startproc
 242               	.LVL15:
 243 008e 1F93      		push r17
 244               	.LCFI1:
 245               		.cfi_def_cfa_offset 4
 246               		.cfi_offset 17, -3
 247 0090 CF93      		push r28
 248               	.LCFI2:
 249               		.cfi_def_cfa_offset 5
 250               		.cfi_offset 28, -4
 251 0092 DF93      		push r29
 252               	.LCFI3:
 253               		.cfi_def_cfa_offset 6
 254               		.cfi_offset 29, -5
 255 0094 0F92      		push __tmp_reg__
 256 0096 0F92      		push __tmp_reg__
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 8
 259 0098 CDB7      		in r28,__SP_L__
 260 009a DEB7      		in r29,__SP_H__
 261               	.LCFI5:
 262               		.cfi_def_cfa_register 28
 263               	/* prologue: function */
 264               	/* frame size = 2 */
 265               	/* stack size = 5 */
 266               	.L__stack_usage = 5
 267 009c 182F      		mov r17,r24
 385:stk500boot.c  **** 	SS_LOW();
 268               		.loc 1 385 0
 269 009e 2C98      		cbi 37-32,4
 386:stk500boot.c  **** 	command(SPIFLASH_ARRAYREADLOWFREQ);
 270               		.loc 1 386 0
 271 00a0 83E0      		ldi r24,lo8(3)
 272 00a2 6A83      		std Y+2,r22
 273 00a4 7983      		std Y+1,r23
 274 00a6 0E94 0000 		call command
 275               	.LVL16:
 387:stk500boot.c  **** 	transfer(address >> 16);
 276               		.loc 1 387 0
 277 00aa 812F      		mov r24,r17
 278 00ac 0E94 0000 		call transfer
 388:stk500boot.c  **** 	transfer(address >> 8);
 279               		.loc 1 388 0
 280 00b0 7981      		ldd r23,Y+1
 281 00b2 872F      		mov r24,r23
 282 00b4 0E94 0000 		call transfer
 389:stk500boot.c  **** 	transfer(address);
 283               		.loc 1 389 0
 284 00b8 6A81      		ldd r22,Y+2
 285 00ba 862F      		mov r24,r22
 286 00bc 0E94 0000 		call transfer
 390:stk500boot.c  **** 	uint8_t result = transfer(0);
 287               		.loc 1 390 0
 288 00c0 80E0      		ldi r24,lo8(0)
 289 00c2 0E94 0000 		call transfer
 290               	.LVL17:
 391:stk500boot.c  **** 	SS_HIGH();
 291               		.loc 1 391 0
 292 00c6 2C9A      		sbi 37-32,4
 293               	/* epilogue start */
 393:stk500boot.c  **** }
 294               		.loc 1 393 0
 295 00c8 0F90      		pop __tmp_reg__
 296 00ca 0F90      		pop __tmp_reg__
 297 00cc DF91      		pop r29
 298 00ce CF91      		pop r28
 299 00d0 1F91      		pop r17
 300 00d2 0895      		ret
 301               		.cfi_endproc
 302               	.LFE14:
 304               		.section	.init9,"ax",@progbits
 305               	.global	__jumpMain
 307               	__jumpMain:
 308               	.LFB15:
 451:stk500boot.c  **** void __jumpMain(void) {
 309               		.loc 1 451 0
 310               		.cfi_startproc
 311               	/* prologue: naked */
 312               	/* frame size = 0 */
 313               	/* stack size = 0 */
 314               	.L__stack_usage = 0
 455:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 315               		.loc 1 455 0
 316               	/* #APP */
 317               	 ;  455 "stk500boot.c" 1
 318               		.set __stack, 8703
 319               	 ;  0 "" 2
 459:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 320               		.loc 1 459 0
 321               	 ;  459 "stk500boot.c" 1
 322 0000 01E2      		ldi	16, 33
 323               	 ;  0 "" 2
 460:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 324               		.loc 1 460 0
 325               	 ;  460 "stk500boot.c" 1
 326 0002 0EBF      		out 62,16
 327               	 ;  0 "" 2
 462:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 328               		.loc 1 462 0
 329               	 ;  462 "stk500boot.c" 1
 330 0004 0FEF      		ldi	16, 255
 331               	 ;  0 "" 2
 463:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 332               		.loc 1 463 0
 333               	 ;  463 "stk500boot.c" 1
 334 0006 0DBF      		out 61,16
 335               	 ;  0 "" 2
 465:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );
 336               		.loc 1 465 0
 337               	 ;  465 "stk500boot.c" 1
 338 0008 1124      		clr __zero_reg__
 339               	 ;  0 "" 2
 467:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );
 340               		.loc 1 467 0
 341               	 ;  467 "stk500boot.c" 1
 342 000a 1FBE      		out 63, __zero_reg__
 343               	 ;  0 "" 2
 469:stk500boot.c  **** 	asm volatile ( "jmp main");
 344               		.loc 1 469 0
 345               	 ;  469 "stk500boot.c" 1
 346 000c 0C94 0000 		jmp main
 347               	 ;  0 "" 2
 348               	/* epilogue start */
 471:stk500boot.c  **** }
 349               		.loc 1 471 0
 350               	/* #NOAPP */
 351               		.cfi_endproc
 352               	.LFE15:
 354               		.text
 355               	.global	delay_ms
 357               	delay_ms:
 358               	.LFB16:
 474:stk500boot.c  **** void delay_ms(unsigned int timedelay) {
 359               		.loc 1 474 0
 360               		.cfi_startproc
 361               	.LVL18:
 362               	/* prologue: function */
 363               	/* frame size = 0 */
 364               	/* stack size = 0 */
 365               	.L__stack_usage = 0
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 366               		.loc 1 476 0
 367 00d4 20E0      		ldi r18,lo8(0)
 368 00d6 30E0      		ldi r19,hi8(0)
 369 00d8 00C0      		rjmp .L21
 370               	.LVL19:
 371               	.L22:
 372               	.LBB32:
 373               	.LBB33:
 374               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 375               		.loc 2 164 0
 376 00da EFEC      		 ldi r30,lo8(1999)
 377 00dc F7E0      	    ldi r31,hi8(1999)
 378 00de 3197      	    1:sbiw r30,1
 379 00e0 01F4      	    brne 1b
 380 00e2 00C0      		rjmp .
 381 00e4 0000      		nop
 382               	.LBE33:
 383               	.LBE32:
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 384               		.loc 1 476 0
 385 00e6 2F5F      		subi r18,lo8(-(1))
 386 00e8 3F4F      		sbci r19,hi8(-(1))
 387               	.LVL20:
 388               	.L21:
 476:stk500boot.c  **** 	for (i = 0; i < timedelay; i++) {
 389               		.loc 1 476 0 is_stmt 0 discriminator 1
 390 00ea 2817      		cp r18,r24
 391 00ec 3907      		cpc r19,r25
 392 00ee 01F4      		brne .L22
 393               	/* epilogue start */
 479:stk500boot.c  **** }
 394               		.loc 1 479 0 is_stmt 1
 395 00f0 0895      		ret
 396               		.cfi_endproc
 397               	.LFE16:
 399               	.global	dec_hex
 401               	dec_hex:
 402               	.LFB20:
 491:stk500boot.c  **** 
 492:stk500boot.c  **** //************************************************************************
 493:stk500boot.c  **** static int Serial_Available(void) {
 494:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 495:stk500boot.c  **** }
 496:stk500boot.c  **** 
 497:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 498:stk500boot.c  **** //*****************************************************************************
 499:stk500boot.c  **** static unsigned char recchar_timeout(void) {
 500:stk500boot.c  **** 	uint32_t count = 0;
 501:stk500boot.c  **** 
 502:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 503:stk500boot.c  **** 		// wait for data
 504:stk500boot.c  **** 		count++;
 505:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 506:stk500boot.c  **** 			unsigned int data;
 507:stk500boot.c  **** #if (FLASHEND > 0x10000)
 508:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 509:stk500boot.c  **** #else
 510:stk500boot.c  **** 			data = pgm_read_word_near(0); //*	get the first word of the user program
 511:stk500boot.c  **** #endif
 512:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 513:stk500boot.c  **** 					{
 514:stk500boot.c  **** 				asm volatile(
 515:stk500boot.c  **** 						"clr	r30		\n\t"
 516:stk500boot.c  **** 						"clr	r31		\n\t"
 517:stk500boot.c  **** 						"ijmp	\n\t"
 518:stk500boot.c  **** 				);
 519:stk500boot.c  **** 			}
 520:stk500boot.c  **** 			count = 0;
 521:stk500boot.c  **** 		}
 522:stk500boot.c  **** 	}
 523:stk500boot.c  **** 	return UART_DATA_REG;
 524:stk500boot.c  **** }
 525:stk500boot.c  **** 
 526:stk500boot.c  **** 
 527:stk500boot.c  **** void dec_hex(long int num)   // Function Definition
 528:stk500boot.c  **** {
 403               		.loc 1 528 0
 404               		.cfi_startproc
 405               	.LVL21:
 406 00f2 CF92      		push r12
 407               	.LCFI6:
 408               		.cfi_def_cfa_offset 4
 409               		.cfi_offset 12, -3
 410 00f4 DF92      		push r13
 411               	.LCFI7:
 412               		.cfi_def_cfa_offset 5
 413               		.cfi_offset 13, -4
 414 00f6 EF92      		push r14
 415               	.LCFI8:
 416               		.cfi_def_cfa_offset 6
 417               		.cfi_offset 14, -5
 418 00f8 FF92      		push r15
 419               	.LCFI9:
 420               		.cfi_def_cfa_offset 7
 421               		.cfi_offset 15, -6
 422 00fa CF93      		push r28
 423               	.LCFI10:
 424               		.cfi_def_cfa_offset 8
 425               		.cfi_offset 28, -7
 426 00fc DF93      		push r29
 427               	.LCFI11:
 428               		.cfi_def_cfa_offset 9
 429               		.cfi_offset 29, -8
 430 00fe CDB7      		in r28,__SP_L__
 431 0100 DEB7      		in r29,__SP_H__
 432 0102 C85C      		subi r28,lo8(-(-200))
 433 0104 D040      		sbci r29,hi8(-(-200))
 434               	.LCFI12:
 435               		.cfi_def_cfa 28, 209
 436 0106 0FB6      		in __tmp_reg__,__SREG__
 437 0108 F894      		cli
 438 010a DEBF      		out __SP_H__,r29
 439 010c 0FBE      		out __SREG__,__tmp_reg__
 440 010e CDBF      		out __SP_L__,r28
 441               	/* prologue: function */
 442               	/* frame size = 200 */
 443               	/* stack size = 206 */
 444               	.L__stack_usage = 206
 445 0110 6B01      		movw r12,r22
 446 0112 7C01      		movw r14,r24
 447               	.LVL22:
 529:stk500boot.c  **** long int rem[50],i=0,length=0;
 530:stk500boot.c  **** if(num == 0){
 448               		.loc 1 530 0
 449 0114 6115      		cp r22,__zero_reg__
 450 0116 7105      		cpc r23,__zero_reg__
 451 0118 8105      		cpc r24,__zero_reg__
 452 011a 9105      		cpc r25,__zero_reg__
 453 011c 01F4      		brne .L24
 454               	.LVL23:
 531:stk500boot.c  **** 	sendchar('0');
 455               		.loc 1 531 0
 456 011e 80E3      		ldi r24,lo8(48)
 457 0120 0E94 0000 		call sendchar
 532:stk500boot.c  **** 	sendchar('0');
 458               		.loc 1 532 0
 459 0124 80E3      		ldi r24,lo8(48)
 460 0126 0E94 0000 		call sendchar
 461               	.L24:
 462               		.loc 1 532 0 is_stmt 0 discriminator 1
 463 012a FE01      		movw r30,r28
 464 012c 3196      		adiw r30,1
 528:stk500boot.c  **** {
 465               		.loc 1 528 0 is_stmt 1 discriminator 1
 466 012e 80E0      		ldi r24,lo8(0)
 467 0130 90E0      		ldi r25,hi8(0)
 468 0132 DC01      		movw r26,r24
 469 0134 00C0      		rjmp .L25
 470               	.LVL24:
 471               	.L26:
 533:stk500boot.c  **** }
 534:stk500boot.c  **** while(num>0)
 535:stk500boot.c  ****    {
 536:stk500boot.c  ****       rem[i]=num%16;
 472               		.loc 1 536 0
 473 0136 B701      		movw r22,r14
 474 0138 A601      		movw r20,r12
 475 013a 4F70      		andi r20,lo8(15)
 476 013c 5070      		andi r21,hi8(15)
 477 013e 6070      		andi r22,hlo8(15)
 478 0140 7070      		andi r23,hhi8(15)
 479 0142 4193      		st Z+,r20
 480 0144 5193      		st Z+,r21
 481 0146 6193      		st Z+,r22
 482 0148 7193      		st Z+,r23
 537:stk500boot.c  ****       num=num/16;
 483               		.loc 1 537 0
 484 014a 24E0      		ldi r18,4
 485 014c F594      	1:	asr r15
 486 014e E794      		ror r14
 487 0150 D794      		ror r13
 488 0152 C794      		ror r12
 489 0154 2A95      		dec r18
 490 0156 01F4      		brne 1b
 491               	.LVL25:
 538:stk500boot.c  ****       i++;
 492               		.loc 1 538 0
 493 0158 0196      		adiw r24,1
 494 015a A11D      		adc r26,__zero_reg__
 495 015c B11D      		adc r27,__zero_reg__
 496               	.LVL26:
 497               	.L25:
 534:stk500boot.c  **** while(num>0)
 498               		.loc 1 534 0 discriminator 1
 499 015e 1C14      		cp __zero_reg__,r12
 500 0160 1D04      		cpc __zero_reg__,r13
 501 0162 1E04      		cpc __zero_reg__,r14
 502 0164 1F04      		cpc __zero_reg__,r15
 503 0166 04F0      		brlt .L26
 539:stk500boot.c  ****       length++;
 540:stk500boot.c  ****    }
 541:stk500boot.c  **** 
 542:stk500boot.c  **** for(i=length-1;i>=0;i--)
 504               		.loc 1 542 0
 505 0168 6C01      		movw r12,r24
 506 016a 7D01      		movw r14,r26
 507               	.LVL27:
 508 016c 00C0      		rjmp .L53
 509               	.LVL28:
 510               	.L49:
 527:stk500boot.c  **** void dec_hex(long int num)   // Function Definition
 511               		.loc 1 527 0
 512 016e F601      		movw r30,r12
 513 0170 EE0F      		lsl r30
 514 0172 FF1F      		rol r31
 515 0174 EE0F      		lsl r30
 516 0176 FF1F      		rol r31
 517 0178 81E0      		ldi r24,lo8(1)
 518 017a 90E0      		ldi r25,hi8(1)
 519 017c 8C0F      		add r24,r28
 520 017e 9D1F      		adc r25,r29
 521 0180 E80F      		add r30,r24
 522 0182 F91F      		adc r31,r25
 543:stk500boot.c  ****   {
 544:stk500boot.c  ****     switch(rem[i])
 523               		.loc 1 544 0
 524 0184 8081      		ld r24,Z
 525 0186 9181      		ldd r25,Z+1
 526 0188 A281      		ldd r26,Z+2
 527 018a B381      		ldd r27,Z+3
 528 018c 8730      		cpi r24,lo8(7)
 529 018e 9105      		cpc r25,__zero_reg__
 530 0190 A105      		cpc r26,__zero_reg__
 531 0192 B105      		cpc r27,__zero_reg__
 532 0194 01F4      		brne .+2
 533 0196 00C0      		rjmp .L36
 534 0198 8830      		cpi r24,lo8(8)
 535 019a 9105      		cpc r25,__zero_reg__
 536 019c A105      		cpc r26,__zero_reg__
 537 019e B105      		cpc r27,__zero_reg__
 538 01a0 04F4      		brge .L45
 539 01a2 8330      		cpi r24,lo8(3)
 540 01a4 9105      		cpc r25,__zero_reg__
 541 01a6 A105      		cpc r26,__zero_reg__
 542 01a8 B105      		cpc r27,__zero_reg__
 543 01aa 01F4      		brne .+2
 544 01ac 00C0      		rjmp .L32
 545 01ae 8430      		cpi r24,lo8(4)
 546 01b0 9105      		cpc r25,__zero_reg__
 547 01b2 A105      		cpc r26,__zero_reg__
 548 01b4 B105      		cpc r27,__zero_reg__
 549 01b6 04F4      		brge .L46
 550 01b8 8130      		cpi r24,lo8(1)
 551 01ba 9105      		cpc r25,__zero_reg__
 552 01bc A105      		cpc r26,__zero_reg__
 553 01be B105      		cpc r27,__zero_reg__
 554 01c0 01F4      		brne .+2
 555 01c2 00C0      		rjmp .L30
 556 01c4 8230      		cpi r24,lo8(2)
 557 01c6 9105      		cpc r25,__zero_reg__
 558 01c8 A105      		cpc r26,__zero_reg__
 559 01ca B105      		cpc r27,__zero_reg__
 560 01cc 04F0      		brlt .+2
 561 01ce 00C0      		rjmp .L31
 562 01d0 0097      		sbiw r24,0
 563 01d2 A105      		cpc r26,__zero_reg__
 564 01d4 B105      		cpc r27,__zero_reg__
 565 01d6 01F0      		breq .L29
 566 01d8 00C0      		rjmp .L28
 567               	.L46:
 568 01da 8530      		cpi r24,lo8(5)
 569 01dc 9105      		cpc r25,__zero_reg__
 570 01de A105      		cpc r26,__zero_reg__
 571 01e0 B105      		cpc r27,__zero_reg__
 572 01e2 01F0      		breq .L34
 573 01e4 8630      		cpi r24,lo8(6)
 574 01e6 9105      		cpc r25,__zero_reg__
 575 01e8 A105      		cpc r26,__zero_reg__
 576 01ea B105      		cpc r27,__zero_reg__
 577 01ec 04F4      		brge .L35
 578 01ee 00C0      		rjmp .L54
 579               	.L45:
 580 01f0 8B30      		cpi r24,lo8(11)
 581 01f2 9105      		cpc r25,__zero_reg__
 582 01f4 A105      		cpc r26,__zero_reg__
 583 01f6 B105      		cpc r27,__zero_reg__
 584 01f8 01F0      		breq .L40
 585 01fa 8C30      		cpi r24,lo8(12)
 586 01fc 9105      		cpc r25,__zero_reg__
 587 01fe A105      		cpc r26,__zero_reg__
 588 0200 B105      		cpc r27,__zero_reg__
 589 0202 04F4      		brge .L47
 590 0204 8930      		cpi r24,lo8(9)
 591 0206 9105      		cpc r25,__zero_reg__
 592 0208 A105      		cpc r26,__zero_reg__
 593 020a B105      		cpc r27,__zero_reg__
 594 020c 01F0      		breq .L38
 595 020e 8A30      		cpi r24,lo8(10)
 596 0210 9105      		cpc r25,__zero_reg__
 597 0212 A105      		cpc r26,__zero_reg__
 598 0214 B105      		cpc r27,__zero_reg__
 599 0216 04F4      		brge .L39
 600 0218 00C0      		rjmp .L55
 601               	.L47:
 602 021a 8D30      		cpi r24,lo8(13)
 603 021c 9105      		cpc r25,__zero_reg__
 604 021e A105      		cpc r26,__zero_reg__
 605 0220 B105      		cpc r27,__zero_reg__
 606 0222 01F0      		breq .L42
 607 0224 8D30      		cpi r24,lo8(13)
 608 0226 9105      		cpc r25,__zero_reg__
 609 0228 A105      		cpc r26,__zero_reg__
 610 022a B105      		cpc r27,__zero_reg__
 611 022c 04F0      		brlt .L41
 612 022e 8E30      		cpi r24,lo8(14)
 613 0230 9105      		cpc r25,__zero_reg__
 614 0232 A105      		cpc r26,__zero_reg__
 615 0234 B105      		cpc r27,__zero_reg__
 616 0236 01F0      		breq .L43
 617 0238 8F30      		cpi r24,lo8(15)
 618 023a 9105      		cpc r25,__zero_reg__
 619 023c A105      		cpc r26,__zero_reg__
 620 023e B105      		cpc r27,__zero_reg__
 621 0240 01F4      		brne .L28
 622 0242 00C0      		rjmp .L56
 623               	.L29:
 545:stk500boot.c  ****     {
 546:stk500boot.c  ****     case 0:
 547:stk500boot.c  ****         sendchar('0');
 624               		.loc 1 547 0
 625 0244 80E3      		ldi r24,lo8(48)
 626 0246 00C0      		rjmp .L52
 627               	.L30:
 548:stk500boot.c  ****         break;
 549:stk500boot.c  ****     case 1:
 550:stk500boot.c  ****         sendchar('1');
 628               		.loc 1 550 0
 629 0248 81E3      		ldi r24,lo8(49)
 630 024a 00C0      		rjmp .L52
 631               	.L31:
 551:stk500boot.c  ****         break;
 552:stk500boot.c  ****     case 2:
 553:stk500boot.c  ****         sendchar('2');
 632               		.loc 1 553 0
 633 024c 82E3      		ldi r24,lo8(50)
 634 024e 00C0      		rjmp .L52
 635               	.L32:
 554:stk500boot.c  ****         break;
 555:stk500boot.c  ****     case 3:
 556:stk500boot.c  ****         sendchar('3');
 636               		.loc 1 556 0
 637 0250 83E3      		ldi r24,lo8(51)
 638 0252 00C0      		rjmp .L52
 639               	.L54:
 557:stk500boot.c  ****         break;
 558:stk500boot.c  ****     case 4:
 559:stk500boot.c  ****         sendchar('4');
 640               		.loc 1 559 0
 641 0254 84E3      		ldi r24,lo8(52)
 642 0256 00C0      		rjmp .L52
 643               	.L34:
 560:stk500boot.c  ****         break;
 561:stk500boot.c  ****     case 5:
 562:stk500boot.c  ****         sendchar('5');
 644               		.loc 1 562 0
 645 0258 85E3      		ldi r24,lo8(53)
 646 025a 00C0      		rjmp .L52
 647               	.L35:
 563:stk500boot.c  ****         break;
 564:stk500boot.c  ****     case 6:
 565:stk500boot.c  ****         sendchar('6');
 648               		.loc 1 565 0
 649 025c 86E3      		ldi r24,lo8(54)
 650 025e 00C0      		rjmp .L52
 651               	.L36:
 566:stk500boot.c  ****         break;
 567:stk500boot.c  ****     case 7:
 568:stk500boot.c  ****         sendchar('7');
 652               		.loc 1 568 0
 653 0260 87E3      		ldi r24,lo8(55)
 654 0262 00C0      		rjmp .L52
 655               	.L55:
 569:stk500boot.c  ****         break;
 570:stk500boot.c  ****     case 8:
 571:stk500boot.c  ****         sendchar('8');
 656               		.loc 1 571 0
 657 0264 88E3      		ldi r24,lo8(56)
 658 0266 00C0      		rjmp .L52
 659               	.L38:
 572:stk500boot.c  ****         break;
 573:stk500boot.c  ****     case 9:
 574:stk500boot.c  ****         sendchar('9');
 660               		.loc 1 574 0
 661 0268 89E3      		ldi r24,lo8(57)
 662 026a 00C0      		rjmp .L52
 663               	.L39:
 575:stk500boot.c  ****         break;
 576:stk500boot.c  ****       case 10:
 577:stk500boot.c  ****           sendchar('A');
 664               		.loc 1 577 0
 665 026c 81E4      		ldi r24,lo8(65)
 666 026e 00C0      		rjmp .L52
 667               	.L40:
 578:stk500boot.c  ****           break;
 579:stk500boot.c  ****       case 11:
 580:stk500boot.c  ****     	  sendchar('B');
 668               		.loc 1 580 0
 669 0270 82E4      		ldi r24,lo8(66)
 670 0272 00C0      		rjmp .L52
 671               	.L41:
 581:stk500boot.c  ****           break;
 582:stk500boot.c  ****       case 12:
 583:stk500boot.c  ****     	  sendchar('C');
 672               		.loc 1 583 0
 673 0274 83E4      		ldi r24,lo8(67)
 674 0276 00C0      		rjmp .L52
 675               	.L42:
 584:stk500boot.c  ****           break;
 585:stk500boot.c  ****       case 13:
 586:stk500boot.c  ****     	  sendchar('D');
 676               		.loc 1 586 0
 677 0278 84E4      		ldi r24,lo8(68)
 678 027a 00C0      		rjmp .L52
 679               	.L43:
 587:stk500boot.c  ****           break;
 588:stk500boot.c  ****       case 14:
 589:stk500boot.c  ****     	  sendchar('E');
 680               		.loc 1 589 0
 681 027c 85E4      		ldi r24,lo8(69)
 682 027e 00C0      		rjmp .L52
 683               	.L56:
 590:stk500boot.c  ****           break;
 591:stk500boot.c  ****       case 15:
 592:stk500boot.c  ****     	  sendchar('F');
 684               		.loc 1 592 0
 685 0280 86E4      		ldi r24,lo8(70)
 686 0282 00C0      		rjmp .L52
 687               	.L28:
 593:stk500boot.c  ****           break;
 594:stk500boot.c  ****       default :
 595:stk500boot.c  ****          sendchar('X');
 688               		.loc 1 595 0
 689 0284 88E5      		ldi r24,lo8(88)
 690               	.L52:
 691 0286 0E94 0000 		call sendchar
 692               	.L53:
 542:stk500boot.c  **** for(i=length-1;i>=0;i--)
 693               		.loc 1 542 0
 694 028a 0894      		sec
 695 028c C108      		sbc r12,__zero_reg__
 696 028e D108      		sbc r13,__zero_reg__
 697 0290 E108      		sbc r14,__zero_reg__
 698 0292 F108      		sbc r15,__zero_reg__
 699               	.LVL29:
 700 0294 9FEF      		ldi r25,lo8(-1)
 701 0296 C916      		cp r12,r25
 702 0298 9FEF      		ldi r25,hi8(-1)
 703 029a D906      		cpc r13,r25
 704 029c 9FEF      		ldi r25,hlo8(-1)
 705 029e E906      		cpc r14,r25
 706 02a0 9FEF      		ldi r25,hhi8(-1)
 707 02a2 F906      		cpc r15,r25
 708 02a4 01F0      		breq .+2
 709 02a6 00C0      		rjmp .L49
 710               	/* epilogue start */
 596:stk500boot.c  ****          break;
 597:stk500boot.c  ****     }
 598:stk500boot.c  ****   }
 599:stk500boot.c  **** }
 711               		.loc 1 599 0
 712 02a8 C853      		subi r28,lo8(-(200))
 713 02aa DF4F      		sbci r29,hi8(-(200))
 714 02ac 0FB6      		in __tmp_reg__,__SREG__
 715 02ae F894      		cli
 716 02b0 DEBF      		out __SP_H__,r29
 717 02b2 0FBE      		out __SREG__,__tmp_reg__
 718 02b4 CDBF      		out __SP_L__,r28
 719 02b6 DF91      		pop r29
 720 02b8 CF91      		pop r28
 721 02ba FF90      		pop r15
 722 02bc EF90      		pop r14
 723 02be DF90      		pop r13
 724 02c0 CF90      		pop r12
 725               	.LVL30:
 726 02c2 0895      		ret
 727               		.cfi_endproc
 728               	.LFE20:
 730               		.section	.text.startup,"ax",@progbits
 731               	.global	main
 733               	main:
 734               	.LFB21:
 600:stk500boot.c  **** 
 601:stk500boot.c  **** 
 602:stk500boot.c  **** //*	for watch dog timer startup
 603:stk500boot.c  **** void (*app_start)(void) = 0;
 604:stk500boot.c  **** uint8_t check = 1;
 605:stk500boot.c  **** 
 606:stk500boot.c  **** //*****************************************************************************
 607:stk500boot.c  **** int main(void) {
 735               		.loc 1 607 0
 736               		.cfi_startproc
 737 0000 CF93      		push r28
 738               	.LCFI13:
 739               		.cfi_def_cfa_offset 4
 740               		.cfi_offset 28, -3
 741 0002 DF93      		push r29
 742               	.LCFI14:
 743               		.cfi_def_cfa_offset 5
 744               		.cfi_offset 29, -4
 745 0004 CDB7      		in r28,__SP_L__
 746 0006 DEB7      		in r29,__SP_H__
 747 0008 CF52      		subi r28,lo8(-(-303))
 748 000a D140      		sbci r29,hi8(-(-303))
 749               	.LCFI15:
 750               		.cfi_def_cfa 28, 308
 751 000c 0FB6      		in __tmp_reg__,__SREG__
 752 000e F894      		cli
 753 0010 DEBF      		out __SP_H__,r29
 754 0012 0FBE      		out __SREG__,__tmp_reg__
 755 0014 CDBF      		out __SP_L__,r28
 756               	/* prologue: function */
 757               	/* frame size = 303 */
 758               	/* stack size = 305 */
 759               	.L__stack_usage = 305
 608:stk500boot.c  **** 
 609:stk500boot.c  **** 	setDataMode(0x00);
 760               		.loc 1 609 0
 761 0016 80E0      		ldi r24,lo8(0)
 762 0018 0E94 0000 		call setDataMode
 610:stk500boot.c  **** 	setBitOrder(1);
 763               		.loc 1 610 0
 764 001c 81E0      		ldi r24,lo8(1)
 765 001e 0E94 0000 		call setBitOrder
 611:stk500boot.c  **** 	setClockDivider(0x04);
 766               		.loc 1 611 0
 767 0022 84E0      		ldi r24,lo8(4)
 768 0024 0E94 0000 		call setClockDivider
 612:stk500boot.c  **** 
 613:stk500boot.c  **** 	SPI_PORTB = _BV(SCK) | _BV(MISO) | _BV(MOSI) | _BV(SS) | _BV(LED1) | _BV(LED2) | _BV(LED3);
 769               		.loc 1 613 0
 770 0028 8EEF      		ldi r24,lo8(-2)
 771 002a 85B9      		out 37-32,r24
 614:stk500boot.c  **** 	SPI_DDRB = _BV(SCK) | _BV(MOSI) |_BV(SS) | _BV(LED1) | _BV(LED2) | _BV(LED3);
 772               		.loc 1 614 0
 773 002c 86EF      		ldi r24,lo8(-10)
 774 002e 84B9      		out 36-32,r24
 615:stk500boot.c  **** 	
 616:stk500boot.c  **** 	LED1_LOW();
 775               		.loc 1 616 0
 776 0030 2D98      		cbi 37-32,5
 617:stk500boot.c  **** 	LED2_LOW();
 777               		.loc 1 617 0
 778 0032 2E98      		cbi 37-32,6
 618:stk500boot.c  **** 	LED3_LOW();
 779               		.loc 1 618 0
 780 0034 2F98      		cbi 37-32,7
 619:stk500boot.c  **** 	
 620:stk500boot.c  **** 	SS_HIGH();
 781               		.loc 1 620 0
 782 0036 2C9A      		sbi 37-32,4
 621:stk500boot.c  **** //	SS_MASTER_HIGH();
 622:stk500boot.c  **** 
 623:stk500boot.c  **** 	SPCR |= _BV(MSTR);
 783               		.loc 1 623 0
 784 0038 8CB5      		in r24,76-32
 785 003a 8061      		ori r24,lo8(16)
 786 003c 8CBD      		out 76-32,r24
 624:stk500boot.c  **** 	SPCR |= _BV(SPE);
 787               		.loc 1 624 0
 788 003e 8CB5      		in r24,76-32
 789 0040 8064      		ori r24,lo8(64)
 790 0042 8CBD      		out 76-32,r24
 791               	.LVL31:
 625:stk500boot.c  **** 
 626:stk500boot.c  **** 	address_t address = 0;
 627:stk500boot.c  **** 	address_t eraseAddress = 0;
 628:stk500boot.c  **** 	unsigned char msgParseState;
 629:stk500boot.c  **** 	unsigned int ii = 0;
 630:stk500boot.c  **** 	unsigned char checksum = 0;
 631:stk500boot.c  **** 	unsigned char seqNum = 0;
 632:stk500boot.c  **** 	unsigned int msgLength = 0;
 633:stk500boot.c  **** 	unsigned char msgBuffer[285];
 634:stk500boot.c  **** 	unsigned char c, *p;
 635:stk500boot.c  **** 	unsigned char isLeave = 0;
 636:stk500boot.c  **** 
 637:stk500boot.c  **** 	unsigned long boot_timeout;
 638:stk500boot.c  **** 	unsigned long boot_timer;
 639:stk500boot.c  **** 	unsigned int boot_state;
 640:stk500boot.c  **** #ifdef ENABLE_MONITOR
 641:stk500boot.c  **** 	unsigned int exPointCntr = 0;
 642:stk500boot.c  **** 	unsigned int rcvdCharCntr = 0;
 643:stk500boot.c  **** #endif
 644:stk500boot.c  **** 
 645:stk500boot.c  **** 	//*	some chips dont set the stack properly
 646:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 792               		.loc 1 646 0
 793               	/* #APP */
 794               	 ;  646 "stk500boot.c" 1
 795               		.set __stack, 8703
 796               	 ;  0 "" 2
 647:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 797               		.loc 1 647 0
 798               	 ;  647 "stk500boot.c" 1
 799 0044 01E2      		ldi	16, 33
 800               	 ;  0 "" 2
 648:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 801               		.loc 1 648 0
 802               	 ;  648 "stk500boot.c" 1
 803 0046 0EBF      		out 62,16
 804               	 ;  0 "" 2
 649:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 805               		.loc 1 649 0
 806               	 ;  649 "stk500boot.c" 1
 807 0048 0FEF      		ldi	16, 255
 808               	 ;  0 "" 2
 650:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 809               		.loc 1 650 0
 810               	 ;  650 "stk500boot.c" 1
 811 004a 0DBF      		out 61,16
 812               	 ;  0 "" 2
 651:stk500boot.c  **** 
 652:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 653:stk500boot.c  **** 	//************************************************************************
 654:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 655:stk500boot.c  **** 	//*	handle the watch dog timer
 656:stk500boot.c  **** 	uint8_t mcuStatusReg;
 657:stk500boot.c  **** 	mcuStatusReg = MCUSR;
 813               		.loc 1 657 0
 814               	/* #NOAPP */
 815 004c 94B7      		in r25,84-32
 816               	.LVL32:
 658:stk500boot.c  **** 
 659:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 817               		.loc 1 659 0
 818               	/* #APP */
 819               	 ;  659 "stk500boot.c" 1
 820 004e F894      		cli
 821               	 ;  0 "" 2
 660:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 822               		.loc 1 660 0
 823               	 ;  660 "stk500boot.c" 1
 824 0050 A895      		wdr
 825               	 ;  0 "" 2
 661:stk500boot.c  **** 	MCUSR = 0;
 826               		.loc 1 661 0
 827               	/* #NOAPP */
 828 0052 14BE      		out 84-32,__zero_reg__
 662:stk500boot.c  **** 	WDTCSR |= _BV(WDCE) | _BV(WDE);
 829               		.loc 1 662 0
 830 0054 8091 6000 		lds r24,96
 831 0058 8861      		ori r24,lo8(24)
 832 005a 8093 6000 		sts 96,r24
 663:stk500boot.c  **** 	WDTCSR = 0;
 833               		.loc 1 663 0
 834 005e 1092 6000 		sts 96,__zero_reg__
 664:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 835               		.loc 1 664 0
 836               	/* #APP */
 837               	 ;  664 "stk500boot.c" 1
 838 0062 7894      		sei
 839               	 ;  0 "" 2
 665:stk500boot.c  **** 
 666:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 667:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF)) {
 840               		.loc 1 667 0
 841               	/* #NOAPP */
 842 0064 93FF      		sbrs r25,3
 843 0066 00C0      		rjmp .L58
 668:stk500boot.c  **** 		app_start();
 844               		.loc 1 668 0
 845 0068 E091 0000 		lds r30,app_start
 846 006c F091 0000 		lds r31,app_start+1
 847 0070 1995      		eicall
 848               	.LVL33:
 849               	.L58:
 669:stk500boot.c  **** 	}
 670:stk500boot.c  **** 	//************************************************************************
 671:stk500boot.c  **** #endif
 672:stk500boot.c  **** 
 673:stk500boot.c  **** 	boot_timer = 0;
 674:stk500boot.c  **** 	boot_state = 0;
 675:stk500boot.c  **** 
 676:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 677:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 678:stk500boot.c  **** //	boot_timeout	=	170000;
 679:stk500boot.c  **** 	boot_timeout = 100000; //*	should be about 1 second
 680:stk500boot.c  **** #else
 681:stk500boot.c  **** 			boot_timeout = 3500000; // 7 seconds , approx 2us per step when optimize "s"
 682:stk500boot.c  **** #endif
 683:stk500boot.c  **** 	/*
 684:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 685:stk500boot.c  **** 	 */
 686:stk500boot.c  **** 
 687:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 688:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 689:stk500boot.c  **** 			//PROGLED_DDR |= (1 << PROGLED_PIN);
 690:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 691:stk500boot.c  **** //	PROGLED_PORT |= (1 << PROGLED_PIN); // active high LED ON
 692:stk500boot.c  **** 
 693:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 694:stk500boot.c  **** //	for (ii=0; ii<3; ii++)
 695:stk500boot.c  **** //	{
 696:stk500boot.c  **** //		PROGLED_PORT &= ~(1<<PROGLED_PIN); // turn LED off
 697:stk500boot.c  **** //		delay_ms(100);
 698:stk500boot.c  **** //		PROGLED_PORT |= (1<<PROGLED_PIN);// turn LED on
 699:stk500boot.c  **** //		delay_ms(100);
 700:stk500boot.c  **** //	}
 701:stk500boot.c  **** #endif
 702:stk500boot.c  **** 
 703:stk500boot.c  **** #endif
 704:stk500boot.c  **** 
 705:stk500boot.c  **** 	/*
 706:stk500boot.c  **** 	 * Init UART
 707:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 708:stk500boot.c  **** 	 */
 709:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 710:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_DOUBLE_SPEED);
 850               		.loc 1 710 0
 851 0072 8091 C000 		lds r24,192
 852 0076 8260      		ori r24,lo8(2)
 853 0078 8093 C000 		sts 192,r24
 711:stk500boot.c  **** #endif
 712:stk500boot.c  **** 	UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
 854               		.loc 1 712 0
 855 007c 80E1      		ldi r24,lo8(16)
 856 007e 8093 C400 		sts 196,r24
 713:stk500boot.c  **** 	UART_CONTROL_REG = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 857               		.loc 1 713 0
 858 0082 88E1      		ldi r24,lo8(24)
 859 0084 8093 C100 		sts 193,r24
 714:stk500boot.c  **** 
 715:stk500boot.c  **** 	asm volatile ("nop");
 860               		.loc 1 715 0
 861               	/* #APP */
 862               	 ;  715 "stk500boot.c" 1
 863 0088 0000      		nop
 864               	 ;  0 "" 2
 673:stk500boot.c  **** 	boot_timer = 0;
 865               		.loc 1 673 0
 866               	/* #NOAPP */
 867 008a 40E0      		ldi r20,lo8(0)
 868 008c 50E0      		ldi r21,hi8(0)
 869 008e BA01      		movw r22,r20
 870 0090 00C0      		rjmp .L168
 871               	.LVL34:
 872               	.L62:
 873               	.LBB34:
 874               	.LBB35:
 875               		.loc 2 164 0
 876 0092 25E0      		 ldi r18,lo8(5)
 877 0094 2A95      	    1:dec r18
 878 0096 01F4      	    brne 1b
 879 0098 0000      		nop
 880               	.LBE35:
 881               	.LBE34:
 716:stk500boot.c  **** 	// wait until port has changed
 717:stk500boot.c  **** 
 718:stk500boot.c  **** //	sendchar('b');
 719:stk500boot.c  **** //    sendchar('o');
 720:stk500boot.c  **** //    sendchar('o');
 721:stk500boot.c  **** //    sendchar('t');
 722:stk500boot.c  **** //    sendchar('i');
 723:stk500boot.c  **** //    sendchar('n');
 724:stk500boot.c  **** //    sendchar('g');
 725:stk500boot.c  **** //    sendchar('.');
 726:stk500boot.c  **** //    sendchar('.');
 727:stk500boot.c  **** //    sendchar('.');
 728:stk500boot.c  **** //    sendchar(0x0d);
 729:stk500boot.c  **** //    sendchar(0x0a);
 730:stk500boot.c  **** //    delay_ms(100);
 731:stk500boot.c  **** 
 732:stk500boot.c  **** 	while (boot_state == 0) {
 733:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 734:stk500boot.c  **** 		{
 735:stk500boot.c  **** 			_delay_ms(0.001);
 736:stk500boot.c  **** 			boot_timer++;
 882               		.loc 1 736 0
 883 009a 4F5F      		subi r20,lo8(-(1))
 884 009c 5F4F      		sbci r21,hi8(-(1))
 885 009e 6F4F      		sbci r22,hlo8(-(1))
 886 00a0 7F4F      		sbci r23,hhi8(-(1))
 887               	.LVL35:
 737:stk500boot.c  **** 			if (boot_timer > boot_timeout) {
 738:stk500boot.c  **** 				boot_state = 1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 888               		.loc 1 738 0
 889 00a2 81E0      		ldi r24,lo8(1)
 890 00a4 90E0      		ldi r25,hi8(1)
 891               	.LVL36:
 892 00a6 413A      		cpi r20,lo8(100001)
 893 00a8 36E8      		ldi r19,hi8(100001)
 894 00aa 5307      		cpc r21,r19
 895 00ac 31E0      		ldi r19,hlo8(100001)
 896 00ae 6307      		cpc r22,r19
 897 00b0 30E0      		ldi r19,hhi8(100001)
 898 00b2 7307      		cpc r23,r19
 899 00b4 00F4      		brsh .L163
 900               	.LVL37:
 901               	.L168:
 902 00b6 80E0      		ldi r24,lo8(0)
 903 00b8 90E0      		ldi r25,hi8(0)
 904               	.L163:
 905               	.LVL38:
 906               	.LBB36:
 907               	.LBB37:
 494:stk500boot.c  **** 	return (UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)); // wait for data
 908               		.loc 1 494 0 discriminator 1
 909 00ba 2091 C000 		lds r18,192
 910               	.LBE37:
 911               	.LBE36:
 733:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 912               		.loc 1 733 0 discriminator 1
 913 00be 27FD      		sbrc r18,7
 914 00c0 00C0      		rjmp .L61
 733:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0)) // wait for data
 915               		.loc 1 733 0 is_stmt 0 discriminator 2
 916 00c2 0097      		sbiw r24,0
 917 00c4 01F0      		breq .L62
 918               	.L61:
 919               	.LVL39:
 732:stk500boot.c  **** 	while (boot_state == 0) {
 920               		.loc 1 732 0 is_stmt 1
 921 00c6 0196      		adiw r24,1
 922               	.LVL40:
 739:stk500boot.c  **** 			}
 740:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 741:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0) {
 742:stk500boot.c  **** 				//*	toggle the LED
 743:stk500boot.c  **** 				//PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
 744:stk500boot.c  **** 			}
 745:stk500boot.c  **** #endif
 746:stk500boot.c  **** 		}
 747:stk500boot.c  **** 		/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 748:stk500boot.c  **** 		//	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 749:stk500boot.c  **** 		// SDCARD BOOTLOADER
 750:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 751:stk500boot.c  **** 	}
 752:stk500boot.c  **** 
 753:stk500boot.c  **** 	if (boot_state == 1) {
 923               		.loc 1 753 0
 924 00c8 8130      		cpi r24,1
 925 00ca 9105      		cpc r25,__zero_reg__
 926 00cc 01F0      		breq .+2
 927 00ce 00C0      		rjmp .L165
 928 00d0 00C0      		rjmp .L178
 929               	.LVL41:
 930               	.L83:
 931 00d2 80E0      		ldi r24,lo8(0)
 932 00d4 90E0      		ldi r25,hi8(0)
 933               	.LVL42:
 934               	.L126:
 754:stk500boot.c  **** 		//*	main loop
 755:stk500boot.c  **** 		while (!isLeave) {
 756:stk500boot.c  **** 			/*
 757:stk500boot.c  **** 			 * Collect received bytes to a complete message
 758:stk500boot.c  **** 			 */
 759:stk500boot.c  **** 			msgParseState = ST_START;
 760:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 761:stk500boot.c  **** 				if (boot_state == 1) {
 935               		.loc 1 761 0
 936 00d6 8130      		cpi r24,1
 937 00d8 9105      		cpc r25,__zero_reg__
 938 00da 01F4      		brne .L134
 939 00dc 00C0      		rjmp .L169
 940               	.LVL43:
 941               	.L70:
 942               	.LBB38:
 943               	.LBB39:
 504:stk500boot.c  **** 		count++;
 944               		.loc 1 504 0
 945 00de 0196      		adiw r24,1
 946 00e0 A11D      		adc r26,__zero_reg__
 947 00e2 B11D      		adc r27,__zero_reg__
 948               	.LVL44:
 505:stk500boot.c  **** 		if (count > MAX_TIME_COUNT) {
 949               		.loc 1 505 0
 950 00e4 8130      		cpi r24,lo8(8000001)
 951 00e6 E2E1      		ldi r30,hi8(8000001)
 952 00e8 9E07      		cpc r25,r30
 953 00ea EAE7      		ldi r30,hlo8(8000001)
 954 00ec AE07      		cpc r26,r30
 955 00ee E0E0      		ldi r30,hhi8(8000001)
 956 00f0 BE07      		cpc r27,r30
 957 00f2 00F0      		brlo .L164
 958               	.LVL45:
 959               	.LBB40:
 512:stk500boot.c  **** 			if (data != 0xffff) //*	make sure its valid before jumping to it.
 960               		.loc 1 512 0
 961 00f4 C25D      		subi r28,lo8(-302)
 962 00f6 DE4F      		sbci r29,hi8(-302)
 963 00f8 8881      		ld r24,Y
 964 00fa 9981      		ldd r25,Y+1
 965 00fc CE52      		subi r28,lo8(302)
 966 00fe D140      		sbci r29,hi8(302)
 967               	.LVL46:
 968 0100 AFEF      		ldi r26,hi8(-1)
 969 0102 8F3F      		cpi r24,lo8(-1)
 970 0104 9A07      		cpc r25,r26
 971 0106 01F0      		breq .L134
 514:stk500boot.c  **** 				asm volatile(
 972               		.loc 1 514 0
 973               	/* #APP */
 974               	 ;  514 "stk500boot.c" 1
 975 0108 EE27      		clr	r30		
 976 010a FF27      		clr	r31		
 977 010c 0994      		ijmp	
 978               		
 979               	 ;  0 "" 2
 980               	.LVL47:
 981               	/* #NOAPP */
 982               	.L134:
 983               	.LBE40:
 984               	.LBE39:
 985               	.LBE38:
 986               		.loc 1 761 0
 987 010e 80E0      		ldi r24,lo8(0)
 988 0110 90E0      		ldi r25,hi8(0)
 989 0112 DC01      		movw r26,r24
 990               	.L164:
 991               	.LVL48:
 992               	.LBB45:
 993               	.LBB43:
 502:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE))) {
 994               		.loc 1 502 0
 995 0114 3091 C000 		lds r19,192
 996 0118 37FF      		sbrs r19,7
 997 011a 00C0      		rjmp .L70
 998               	.LVL49:
 999               	.L169:
 523:stk500boot.c  **** 	return UART_DATA_REG;
 1000               		.loc 1 523 0
 1001 011c 3091 C600 		lds r19,198
 1002               	.LVL50:
 1003               	.LBE43:
 1004               	.LBE45:
 762:stk500boot.c  **** 					boot_state = 0;
 763:stk500boot.c  **** 					c = UART_DATA_REG;
 764:stk500boot.c  **** 				} else {
 765:stk500boot.c  **** 					//	c	=	recchar();
 766:stk500boot.c  **** 					c = recchar_timeout();
 767:stk500boot.c  **** 
 768:stk500boot.c  **** 				}
 769:stk500boot.c  **** 
 770:stk500boot.c  **** #ifdef ENABLE_MONITOR
 771:stk500boot.c  **** 				rcvdCharCntr++;
 1005               		.loc 1 771 0
 1006 0120 0894      		sec
 1007 0122 C11C      		adc r12,__zero_reg__
 1008 0124 D11C      		adc r13,__zero_reg__
 1009               	.LVL51:
 772:stk500boot.c  **** 
 773:stk500boot.c  **** 				if ((c == '!') && (rcvdCharCntr < 10))
 1010               		.loc 1 773 0
 1011 0126 3132      		cpi r19,lo8(33)
 1012 0128 01F4      		brne .L137
 1013               		.loc 1 773 0 is_stmt 0 discriminator 1
 1014 012a BAE0      		ldi r27,lo8(10)
 1015 012c CB16      		cp r12,r27
 1016 012e D104      		cpc r13,__zero_reg__
 1017 0130 00F4      		brsh .L137
 774:stk500boot.c  **** 				{
 775:stk500boot.c  **** 					exPointCntr++;
 1018               		.loc 1 775 0 is_stmt 1
 1019 0132 6F5F      		subi r22,lo8(-(1))
 1020 0134 7F4F      		sbci r23,hi8(-(1))
 1021               	.LVL52:
 776:stk500boot.c  **** 					if (exPointCntr == 3)
 1022               		.loc 1 776 0
 1023 0136 6330      		cpi r22,3
 1024 0138 7105      		cpc r23,__zero_reg__
 1025 013a 01F4      		brne .L71
 1026 013c CE5D      		subi r28,lo8(-290)
 1027 013e DE4F      		sbci r29,hi8(-290)
 1028 0140 1983      		std Y+1,r17
 1029 0142 0883      		st Y,r16
 1030 0144 C252      		subi r28,lo8(290)
 1031 0146 D140      		sbci r29,hi8(290)
 1032 0148 CA5D      		subi r28,lo8(-294)
 1033 014a DE4F      		sbci r29,hi8(-294)
 1034 014c D982      		std Y+1,r13
 1035 014e C882      		st Y,r12
 1036 0150 C652      		subi r28,lo8(294)
 1037 0152 D140      		sbci r29,hi8(294)
 777:stk500boot.c  **** 					{
 778:stk500boot.c  **** 						exPointCntr = 0; //	reset back to zero so we dont get in an endless loop
 1038               		.loc 1 778 0
 1039 0154 CC5D      		subi r28,lo8(-292)
 1040 0156 DE4F      		sbci r29,hi8(-292)
 1041 0158 1982      		std Y+1,__zero_reg__
 1042 015a 1882      		st Y,__zero_reg__
 1043 015c C452      		subi r28,lo8(292)
 1044 015e D140      		sbci r29,hi8(292)
 779:stk500boot.c  **** 						isLeave = 1;
 1045               		.loc 1 779 0
 1046 0160 3324      		clr r3
 1047 0162 3394      		inc r3
 1048 0164 00C0      		rjmp .L72
 1049               	.L137:
 780:stk500boot.c  **** 						msgParseState = 99;//*	we dont want it do anything
 781:stk500boot.c  **** 						break;
 782:stk500boot.c  **** 					}
 783:stk500boot.c  **** 				}
 784:stk500boot.c  **** 				else
 785:stk500boot.c  **** 				{
 786:stk500boot.c  **** 					exPointCntr = 0;
 1050               		.loc 1 786 0
 1051 0166 60E0      		ldi r22,lo8(0)
 1052 0168 70E0      		ldi r23,hi8(0)
 1053               	.LVL53:
 1054               	.L71:
 787:stk500boot.c  **** 				}
 788:stk500boot.c  **** #endif
 789:stk500boot.c  **** 
 790:stk500boot.c  **** 				switch (msgParseState) {
 1055               		.loc 1 790 0
 1056 016a 2330      		cpi r18,lo8(3)
 1057 016c 01F0      		breq .L77
 1058 016e 2430      		cpi r18,lo8(4)
 1059 0170 00F4      		brsh .L81
 1060 0172 2130      		cpi r18,lo8(1)
 1061 0174 01F0      		breq .L75
 1062 0176 2230      		cpi r18,lo8(2)
 1063 0178 00F4      		brsh .L76
 1064 017a 00C0      		rjmp .L179
 1065               	.L81:
 1066 017c 2530      		cpi r18,lo8(5)
 1067 017e 01F0      		breq .L79
 1068 0180 2530      		cpi r18,lo8(5)
 1069 0182 00F0      		brlo .L78
 1070 0184 2630      		cpi r18,lo8(6)
 1071 0186 01F4      		brne .L167
 1072 0188 00C0      		rjmp .L180
 1073               	.L179:
 791:stk500boot.c  **** 				case ST_START:
 792:stk500boot.c  **** 					if (c == MESSAGE_START) {
 1074               		.loc 1 792 0
 1075 018a 3B31      		cpi r19,lo8(27)
 1076 018c 01F0      		breq .+2
 1077 018e 00C0      		rjmp .L83
 1078 0190 00C0      		rjmp .L181
 1079               	.L75:
 1080               	.LVL54:
 793:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 794:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 795:stk500boot.c  **** 					}
 796:stk500boot.c  **** 					break;
 797:stk500boot.c  **** 
 798:stk500boot.c  **** 				case ST_GET_SEQ_NUM:
 799:stk500boot.c  **** #ifdef _FIX_ISSUE_505_
 800:stk500boot.c  **** 					seqNum = c;
 801:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 802:stk500boot.c  **** 					checksum ^= c;
 1081               		.loc 1 802 0
 1082 0192 E326      		eor r14,r19
 1083               	.LVL55:
 803:stk500boot.c  **** #else
 804:stk500boot.c  **** 					if ( (c == 1) || (c == seqNum) )
 805:stk500boot.c  **** 					{
 806:stk500boot.c  **** 						seqNum = c;
 807:stk500boot.c  **** 						msgParseState = ST_MSG_SIZE_1;
 808:stk500boot.c  **** 						checksum ^= c;
 809:stk500boot.c  **** 					}
 810:stk500boot.c  **** 					else
 811:stk500boot.c  **** 					{
 812:stk500boot.c  **** 						msgParseState = ST_START;
 813:stk500boot.c  **** 					}
 814:stk500boot.c  **** #endif
 815:stk500boot.c  **** 					break;
 1084               		.loc 1 815 0
 1085 0194 232E      		mov r2,r19
 801:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_1;
 1086               		.loc 1 801 0
 1087 0196 22E0      		ldi r18,lo8(2)
 1088               		.loc 1 815 0
 1089 0198 00C0      		rjmp .L83
 1090               	.LVL56:
 1091               	.L76:
 816:stk500boot.c  **** 
 817:stk500boot.c  **** 				case ST_MSG_SIZE_1:
 818:stk500boot.c  **** 					msgLength = c << 8;
 1092               		.loc 1 818 0
 1093 019a 532F      		mov r21,r19
 1094 019c 40E0      		ldi r20,lo8(0)
 1095               	.LVL57:
 819:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 820:stk500boot.c  **** 					checksum ^= c;
 1096               		.loc 1 820 0
 1097 019e E326      		eor r14,r19
 1098               	.LVL58:
 819:stk500boot.c  **** 					msgParseState = ST_MSG_SIZE_2;
 1099               		.loc 1 819 0
 1100 01a0 23E0      		ldi r18,lo8(3)
 821:stk500boot.c  **** 					break;
 1101               		.loc 1 821 0
 1102 01a2 00C0      		rjmp .L83
 1103               	.LVL59:
 1104               	.L77:
 822:stk500boot.c  **** 
 823:stk500boot.c  **** 				case ST_MSG_SIZE_2:
 824:stk500boot.c  **** 					msgLength |= c;
 1105               		.loc 1 824 0
 1106 01a4 832F      		mov r24,r19
 1107 01a6 90E0      		ldi r25,lo8(0)
 1108 01a8 482B      		or r20,r24
 1109 01aa 592B      		or r21,r25
 1110               	.LVL60:
 825:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 826:stk500boot.c  **** 					checksum ^= c;
 1111               		.loc 1 826 0
 1112 01ac E326      		eor r14,r19
 1113               	.LVL61:
 825:stk500boot.c  **** 					msgParseState = ST_GET_TOKEN;
 1114               		.loc 1 825 0
 1115 01ae 24E0      		ldi r18,lo8(4)
 827:stk500boot.c  **** 					break;
 1116               		.loc 1 827 0
 1117 01b0 00C0      		rjmp .L83
 1118               	.LVL62:
 1119               	.L78:
 828:stk500boot.c  **** 
 829:stk500boot.c  **** 				case ST_GET_TOKEN:
 830:stk500boot.c  **** 					if (c == TOKEN) {
 1120               		.loc 1 830 0
 1121 01b2 3E30      		cpi r19,lo8(14)
 1122 01b4 01F0      		breq .+2
 1123 01b6 00C0      		rjmp .L140
 1124               	.LVL63:
 831:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 832:stk500boot.c  **** 						checksum ^= c;
 1125               		.loc 1 832 0
 1126 01b8 E326      		eor r14,r19
 1127               	.LVL64:
 833:stk500boot.c  **** 						ii = 0;
 1128               		.loc 1 833 0
 1129 01ba 00E0      		ldi r16,lo8(0)
 1130 01bc 10E0      		ldi r17,hi8(0)
 831:stk500boot.c  **** 						msgParseState = ST_GET_DATA;
 1131               		.loc 1 831 0
 1132 01be 25E0      		ldi r18,lo8(5)
 1133 01c0 00C0      		rjmp .L83
 1134               	.LVL65:
 1135               	.L79:
 834:stk500boot.c  **** 					} else {
 835:stk500boot.c  **** 						msgParseState = ST_START;
 836:stk500boot.c  **** 					}
 837:stk500boot.c  **** 					break;
 838:stk500boot.c  **** 
 839:stk500boot.c  **** 				case ST_GET_DATA:
 840:stk500boot.c  **** 					msgBuffer[ii++] = c;
 1136               		.loc 1 840 0
 1137 01c2 E1E0      		ldi r30,lo8(1)
 1138 01c4 F0E0      		ldi r31,hi8(1)
 1139 01c6 EC0F      		add r30,r28
 1140 01c8 FD1F      		adc r31,r29
 1141 01ca E00F      		add r30,r16
 1142 01cc F11F      		adc r31,r17
 1143 01ce 3083      		st Z,r19
 1144 01d0 0F5F      		subi r16,lo8(-(1))
 1145 01d2 1F4F      		sbci r17,hi8(-(1))
 1146               	.LVL66:
 841:stk500boot.c  **** 					checksum ^= c;
 1147               		.loc 1 841 0
 1148 01d4 E326      		eor r14,r19
 1149               	.LVL67:
 842:stk500boot.c  **** 					if (ii == msgLength) {
 1150               		.loc 1 842 0
 1151 01d6 0417      		cp r16,r20
 1152 01d8 1507      		cpc r17,r21
 1153 01da 01F0      		breq .+2
 1154 01dc 00C0      		rjmp .L83
 1155 01de 00C0      		rjmp .L182
 1156               	.LVL68:
 1157               	.L180:
 843:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 844:stk500boot.c  **** 					}
 845:stk500boot.c  **** 					break;
 846:stk500boot.c  **** 
 847:stk500boot.c  **** 				case ST_GET_CHECK:
 848:stk500boot.c  **** 					if (c == checksum) {
 1158               		.loc 1 848 0
 1159 01e0 3E15      		cp r19,r14
 1160 01e2 01F0      		breq .+2
 1161 01e4 00C0      		rjmp .L140
 1162 01e6 00C0      		rjmp .L142
 1163               	.L167:
 1164               	.LVL69:
 760:stk500boot.c  **** 			while (msgParseState != ST_PROCESS) {
 1165               		.loc 1 760 0 discriminator 1
 1166 01e8 2730      		cpi r18,lo8(7)
 1167 01ea 01F0      		breq .+2
 1168 01ec 00C0      		rjmp .L83
 1169               	.LVL70:
 1170               	.L142:
 1171 01ee CE5D      		subi r28,lo8(-290)
 1172 01f0 DE4F      		sbci r29,hi8(-290)
 1173 01f2 1983      		std Y+1,r17
 1174 01f4 0883      		st Y,r16
 1175 01f6 C252      		subi r28,lo8(290)
 1176 01f8 D140      		sbci r29,hi8(290)
 1177 01fa CC5D      		subi r28,lo8(-292)
 1178 01fc DE4F      		sbci r29,hi8(-292)
 1179 01fe 7983      		std Y+1,r23
 1180 0200 6883      		st Y,r22
 1181 0202 C452      		subi r28,lo8(292)
 1182 0204 D140      		sbci r29,hi8(292)
 1183 0206 CA5D      		subi r28,lo8(-294)
 1184 0208 DE4F      		sbci r29,hi8(-294)
 1185 020a D982      		std Y+1,r13
 1186 020c C882      		st Y,r12
 1187 020e C652      		subi r28,lo8(294)
 1188 0210 D140      		sbci r29,hi8(294)
 1189               		.loc 1 848 0
 1190 0212 3324      		clr r3
 1191               	.L72:
 1192               	.LVL71:
 849:stk500boot.c  **** 						msgParseState = ST_PROCESS;
 850:stk500boot.c  **** 					} else {
 851:stk500boot.c  **** 						msgParseState = ST_START;
 852:stk500boot.c  **** 					}
 853:stk500boot.c  **** 					break;
 854:stk500boot.c  **** 				} //	switch
 855:stk500boot.c  **** 			} //	while(msgParseState)
 856:stk500boot.c  **** 
 857:stk500boot.c  **** 			/*
 858:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 859:stk500boot.c  **** 			 */
 860:stk500boot.c  **** 
 861:stk500boot.c  **** 			switch (msgBuffer[0]) {
 1193               		.loc 1 861 0
 1194 0214 8981      		ldd r24,Y+1
 1195 0216 8331      		cpi r24,lo8(19)
 1196 0218 01F4      		brne .+2
 1197 021a 00C0      		rjmp .L91
 1198 021c 8431      		cpi r24,lo8(20)
 1199 021e 00F4      		brsh .L98
 1200 0220 8630      		cpi r24,lo8(6)
 1201 0222 01F4      		brne .+2
 1202 0224 00C0      		rjmp .L88
 1203 0226 8730      		cpi r24,lo8(7)
 1204 0228 00F4      		brsh .L99
 1205 022a 8230      		cpi r24,lo8(2)
 1206 022c 01F4      		brne .+2
 1207 022e 00C0      		rjmp .L177
 1208 0230 8330      		cpi r24,lo8(3)
 1209 0232 01F4      		brne .+2
 1210 0234 00C0      		rjmp .L87
 1211 0236 8130      		cpi r24,lo8(1)
 1212 0238 01F0      		breq .+2
 1213 023a 00C0      		rjmp .L84
 1214 023c 00C0      		rjmp .L183
 1215               	.L99:
 1216 023e 8131      		cpi r24,lo8(17)
 1217 0240 01F4      		brne .+2
 1218 0242 00C0      		rjmp .L143
 1219 0244 8231      		cpi r24,lo8(18)
 1220 0246 00F0      		brlo .+2
 1221 0248 00C0      		rjmp .L90
 1222 024a 8031      		cpi r24,lo8(16)
 1223 024c 01F0      		breq .+2
 1224 024e 00C0      		rjmp .L84
 1225 0250 00C0      		rjmp .L177
 1226               	.L98:
 1227 0252 8831      		cpi r24,lo8(24)
 1228 0254 01F4      		brne .+2
 1229 0256 00C0      		rjmp .L93
 1230 0258 8931      		cpi r24,lo8(25)
 1231 025a 00F4      		brsh .L100
 1232 025c 8531      		cpi r24,lo8(21)
 1233 025e 01F4      		brne .+2
 1234 0260 00C0      		rjmp .L91
 1235 0262 8531      		cpi r24,lo8(21)
 1236 0264 00F4      		brsh .+2
 1237 0266 00C0      		rjmp .L92
 1238 0268 8631      		cpi r24,lo8(22)
 1239 026a 01F0      		breq .+2
 1240 026c 00C0      		rjmp .L84
 1241 026e 00C0      		rjmp .L92
 1242               	.L100:
 1243 0270 8A31      		cpi r24,lo8(26)
 1244 0272 01F4      		brne .+2
 1245 0274 00C0      		rjmp .L95
 1246 0276 8A31      		cpi r24,lo8(26)
 1247 0278 00F4      		brsh .+2
 1248 027a 00C0      		rjmp .L94
 1249 027c 8B31      		cpi r24,lo8(27)
 1250 027e 01F4      		brne .+2
 1251 0280 00C0      		rjmp .L96
 1252 0282 8D31      		cpi r24,lo8(29)
 1253 0284 01F0      		breq .+2
 1254 0286 00C0      		rjmp .L84
 1255               	.LVL72:
 1256               	.LBB46:
 862:stk500boot.c  **** #ifndef REMOVE_CMD_SPI_MULTI
 863:stk500boot.c  **** 			case CMD_SPI_MULTI: {
 864:stk500boot.c  **** 				unsigned char answerByte;
 865:stk500boot.c  **** 				unsigned char flag = 0;
 866:stk500boot.c  **** 
 867:stk500boot.c  **** 				if (msgBuffer[4] == 0x30) {
 1257               		.loc 1 867 0
 1258 0288 8D81      		ldd r24,Y+5
 1259 028a 8033      		cpi r24,lo8(48)
 1260 028c 01F4      		brne .L101
 1261               	.LBB47:
 868:stk500boot.c  **** 					unsigned char signatureIndex = msgBuffer[6];
 1262               		.loc 1 868 0
 1263 028e 9F81      		ldd r25,Y+7
 1264               	.LVL73:
 869:stk500boot.c  **** 
 870:stk500boot.c  **** 					if (signatureIndex == 0) {
 1265               		.loc 1 870 0
 1266 0290 9923      		tst r25
 1267 0292 01F0      		breq .L144
 871:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 872:stk500boot.c  **** 					} else if (signatureIndex == 1) {
 1268               		.loc 1 872 0
 1269 0294 9130      		cpi r25,lo8(1)
 1270 0296 01F4      		brne .L145
 873:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1271               		.loc 1 873 0
 1272 0298 E8E9      		ldi r30,lo8(-104)
 1273 029a 00C0      		rjmp .L102
 1274               	.LVL74:
 1275               	.L101:
 1276               	.LBE47:
 874:stk500boot.c  **** 					} else {
 875:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 876:stk500boot.c  **** 					}
 877:stk500boot.c  **** 				} else if (msgBuffer[4] & 0x50) {
 1277               		.loc 1 877 0
 1278 029c 982F      		mov r25,r24
 1279 029e 9075      		andi r25,lo8(80)
 1280 02a0 01F0      		breq .L147
 878:stk500boot.c  **** 					//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 879:stk500boot.c  **** 					//*	I cant find the docs that say what these are supposed to be but this was figured out by tr
 880:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 881:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 882:stk500boot.c  **** 					//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 883:stk500boot.c  **** 					if (msgBuffer[4] == 0x50) {
 1281               		.loc 1 883 0
 1282 02a2 8035      		cpi r24,lo8(80)
 1283 02a4 01F4      		brne .L103
 1284               	.LBB48:
 884:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1285               		.loc 1 884 0
 1286 02a6 E0E0      		ldi r30,lo8(0)
 1287 02a8 F0E0      		ldi r31,hi8(0)
 1288 02aa 00C0      		rjmp .L170
 1289               	.L103:
 1290               	.LBE48:
 885:stk500boot.c  **** 					} else if (msgBuffer[4] == 0x58) {
 1291               		.loc 1 885 0
 1292 02ac 8835      		cpi r24,lo8(88)
 1293 02ae 01F4      		brne .L147
 1294               	.LBB49:
 886:stk500boot.c  **** 						answerByte = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1295               		.loc 1 886 0
 1296 02b0 E3E0      		ldi r30,lo8(3)
 1297 02b2 F0E0      		ldi r31,hi8(3)
 1298               	.L170:
 1299 02b4 99E0      		ldi r25,lo8(9)
 1300               	/* #APP */
 1301               	 ;  886 "stk500boot.c" 1
 1302 02b6 9093 5700 		sts 87, r25
 1303 02ba E491      		lpm r30, Z
 1304               		
 1305               	 ;  0 "" 2
 1306               	.LVL75:
 1307               	/* #NOAPP */
 1308 02bc 00C0      		rjmp .L102
 1309               	.LVL76:
 1310               	.L144:
 1311               	.LBE49:
 1312               	.LBB50:
 871:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1313               		.loc 1 871 0
 1314 02be EEE1      		ldi r30,lo8(30)
 1315 02c0 00C0      		rjmp .L102
 1316               	.L145:
 875:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 1317               		.loc 1 875 0
 1318 02c2 E1E0      		ldi r30,lo8(1)
 1319 02c4 00C0      		rjmp .L102
 1320               	.LVL77:
 1321               	.L147:
 1322               	.LBE50:
 887:stk500boot.c  **** 					} else {
 888:stk500boot.c  **** 						answerByte = 0;
 1323               		.loc 1 888 0
 1324 02c6 E0E0      		ldi r30,lo8(0)
 1325               	.L102:
 1326               	.LVL78:
 889:stk500boot.c  **** 					}
 890:stk500boot.c  **** 				} else {
 891:stk500boot.c  **** 					answerByte = 0; // for all others command are not implemented, return dummy value for AVRDUDE 
 892:stk500boot.c  **** 				}
 893:stk500boot.c  **** 				if (!flag) {
 894:stk500boot.c  **** 					msgLength = 7;
 895:stk500boot.c  **** 					msgBuffer[1] = STATUS_CMD_OK;
 1327               		.loc 1 895 0
 1328 02c8 1A82      		std Y+2,__zero_reg__
 896:stk500boot.c  **** 					msgBuffer[2] = 0;
 1329               		.loc 1 896 0
 1330 02ca 1B82      		std Y+3,__zero_reg__
 897:stk500boot.c  **** 					msgBuffer[3] = msgBuffer[4];
 1331               		.loc 1 897 0
 1332 02cc 8C83      		std Y+4,r24
 898:stk500boot.c  **** 					msgBuffer[4] = 0;
 1333               		.loc 1 898 0
 1334 02ce 1D82      		std Y+5,__zero_reg__
 899:stk500boot.c  **** 					msgBuffer[5] = answerByte;
 1335               		.loc 1 899 0
 1336 02d0 EE83      		std Y+6,r30
 900:stk500boot.c  **** 					msgBuffer[6] = STATUS_CMD_OK;
 1337               		.loc 1 900 0
 1338 02d2 1F82      		std Y+7,__zero_reg__
 894:stk500boot.c  **** 					msgLength = 7;
 1339               		.loc 1 894 0
 1340 02d4 37E0      		ldi r19,lo8(7)
 1341 02d6 C32E      		mov r12,r19
 1342 02d8 D12C      		mov r13,__zero_reg__
 1343               	.LVL79:
 1344 02da 00C0      		rjmp .L104
 1345               	.LVL80:
 1346               	.L183:
 1347               	.LBE46:
 901:stk500boot.c  **** 				}
 902:stk500boot.c  **** 			}
 903:stk500boot.c  **** 				break;
 904:stk500boot.c  **** #endif
 905:stk500boot.c  **** 			case CMD_SIGN_ON:
 906:stk500boot.c  **** 				msgLength = 11;
 907:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1348               		.loc 1 907 0
 1349 02dc 1A82      		std Y+2,__zero_reg__
 908:stk500boot.c  **** 				msgBuffer[2] = 8;
 1350               		.loc 1 908 0
 1351 02de 88E0      		ldi r24,lo8(8)
 1352 02e0 8B83      		std Y+3,r24
 909:stk500boot.c  **** 				msgBuffer[3] = 'A';
 1353               		.loc 1 909 0
 1354 02e2 81E4      		ldi r24,lo8(65)
 1355 02e4 8C83      		std Y+4,r24
 910:stk500boot.c  **** 				msgBuffer[4] = 'V';
 1356               		.loc 1 910 0
 1357 02e6 86E5      		ldi r24,lo8(86)
 1358 02e8 8D83      		std Y+5,r24
 911:stk500boot.c  **** 				msgBuffer[5] = 'R';
 1359               		.loc 1 911 0
 1360 02ea 82E5      		ldi r24,lo8(82)
 1361 02ec 8E83      		std Y+6,r24
 912:stk500boot.c  **** 				msgBuffer[6] = 'I';
 1362               		.loc 1 912 0
 1363 02ee 89E4      		ldi r24,lo8(73)
 1364 02f0 8F83      		std Y+7,r24
 913:stk500boot.c  **** 				msgBuffer[7] = 'S';
 1365               		.loc 1 913 0
 1366 02f2 83E5      		ldi r24,lo8(83)
 1367 02f4 8887      		std Y+8,r24
 914:stk500boot.c  **** 				msgBuffer[8] = 'P';
 1368               		.loc 1 914 0
 1369 02f6 80E5      		ldi r24,lo8(80)
 1370 02f8 8987      		std Y+9,r24
 915:stk500boot.c  **** 				msgBuffer[9] = '_';
 1371               		.loc 1 915 0
 1372 02fa 8FE5      		ldi r24,lo8(95)
 1373 02fc 8A87      		std Y+10,r24
 916:stk500boot.c  **** 				msgBuffer[10] = '2';
 1374               		.loc 1 916 0
 1375 02fe 82E3      		ldi r24,lo8(50)
 1376 0300 8B87      		std Y+11,r24
 906:stk500boot.c  **** 				msgLength = 11;
 1377               		.loc 1 906 0
 1378 0302 2BE0      		ldi r18,lo8(11)
 1379 0304 C22E      		mov r12,r18
 1380 0306 D12C      		mov r13,__zero_reg__
 917:stk500boot.c  **** 				break;
 1381               		.loc 1 917 0
 1382 0308 00C0      		rjmp .L104
 1383               	.LVL81:
 1384               	.L87:
 1385 030a EA81      		ldd r30,Y+2
 1386 030c E059      		subi r30,lo8(-(112))
 1387 030e E330      		cpi r30,lo8(3)
 1388 0310 00F4      		brsh .L148
 1389 0312 F0E0      		ldi r31,lo8(0)
 1390 0314 E050      		subi r30,lo8(-(CSWTCH.16))
 1391 0316 F040      		sbci r31,hi8(-(CSWTCH.16))
 1392 0318 8081      		ld r24,Z
 1393 031a 00C0      		rjmp .L105
 1394               	.L148:
 1395               	.LBB51:
 918:stk500boot.c  **** 
 919:stk500boot.c  **** 			case CMD_GET_PARAMETER: {
 920:stk500boot.c  **** 				unsigned char value;
 921:stk500boot.c  **** 
 922:stk500boot.c  **** 				switch (msgBuffer[1]) {
 1396               		.loc 1 922 0
 1397 031c 80E0      		ldi r24,lo8(0)
 1398               	.L105:
 1399               	.LVL82:
 923:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_LOW:
 924:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_LOW;
 925:stk500boot.c  **** 					break;
 926:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_HIGH:
 927:stk500boot.c  **** 					value = CONFIG_PARAM_BUILD_NUMBER_HIGH;
 928:stk500boot.c  **** 					break;
 929:stk500boot.c  **** 				case PARAM_HW_VER:
 930:stk500boot.c  **** 					value = CONFIG_PARAM_HW_VER;
 931:stk500boot.c  **** 					break;
 932:stk500boot.c  **** 				case PARAM_SW_MAJOR:
 933:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MAJOR;
 934:stk500boot.c  **** 					break;
 935:stk500boot.c  **** 				case PARAM_SW_MINOR:
 936:stk500boot.c  **** 					value = CONFIG_PARAM_SW_MINOR;
 937:stk500boot.c  **** 					break;
 938:stk500boot.c  **** 				default:
 939:stk500boot.c  **** 					value = 0;
 940:stk500boot.c  **** 					break;
 941:stk500boot.c  **** 				}
 942:stk500boot.c  **** 				msgLength = 3;
 943:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1400               		.loc 1 943 0
 1401 031e 1A82      		std Y+2,__zero_reg__
 944:stk500boot.c  **** 				msgBuffer[2] = value;
 1402               		.loc 1 944 0
 1403 0320 8B83      		std Y+3,r24
 1404 0322 00C0      		rjmp .L172
 1405               	.LVL83:
 1406               	.L143:
 1407               	.LBE51:
 945:stk500boot.c  **** 			}
 946:stk500boot.c  **** 				break;
 947:stk500boot.c  **** 
 948:stk500boot.c  **** 			case CMD_LEAVE_PROGMODE_ISP:
 949:stk500boot.c  **** 				isLeave = 1;
 1408               		.loc 1 949 0
 1409 0324 3324      		clr r3
 1410 0326 3394      		inc r3
 1411               	.LVL84:
 1412 0328 00C0      		rjmp .L177
 1413               	.LVL85:
 1414               	.L96:
 1415               	.LBB52:
 950:stk500boot.c  **** 				//*	fall thru
 951:stk500boot.c  **** 
 952:stk500boot.c  **** 			case CMD_SET_PARAMETER:
 953:stk500boot.c  **** 			case CMD_ENTER_PROGMODE_ISP:
 954:stk500boot.c  **** 				msgLength = 2;
 955:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 956:stk500boot.c  **** 				break;
 957:stk500boot.c  **** 
 958:stk500boot.c  **** 			case CMD_READ_SIGNATURE_ISP: {
 959:stk500boot.c  **** 				unsigned char signatureIndex = msgBuffer[4];
 1416               		.loc 1 959 0
 1417 032a 8D81      		ldd r24,Y+5
 1418               	.LVL86:
 960:stk500boot.c  **** 				unsigned char signature;
 961:stk500boot.c  **** 
 962:stk500boot.c  **** 				if (signatureIndex == 0)
 1419               		.loc 1 962 0
 1420 032c 8823      		tst r24
 1421 032e 01F0      		breq .L149
 963:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 964:stk500boot.c  **** 				else if (signatureIndex == 1)
 1422               		.loc 1 964 0
 1423 0330 8130      		cpi r24,lo8(1)
 1424 0332 01F4      		brne .L150
 965:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1425               		.loc 1 965 0
 1426 0334 88E9      		ldi r24,lo8(-104)
 1427 0336 00C0      		rjmp .L106
 1428               	.L149:
 963:stk500boot.c  **** 					signature = (SIGNATURE_BYTES >> 16) & 0x000000FF;
 1429               		.loc 1 963 0
 1430 0338 8EE1      		ldi r24,lo8(30)
 1431 033a 00C0      		rjmp .L106
 1432               	.L150:
 966:stk500boot.c  **** 				else
 967:stk500boot.c  **** 					signature = SIGNATURE_BYTES & 0x000000FF;
 1433               		.loc 1 967 0
 1434 033c 81E0      		ldi r24,lo8(1)
 1435               	.L106:
 1436               	.LVL87:
 968:stk500boot.c  **** 
 969:stk500boot.c  **** 				msgLength = 4;
 970:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1437               		.loc 1 970 0
 1438 033e 1A82      		std Y+2,__zero_reg__
 971:stk500boot.c  **** 				msgBuffer[2] = signature;
 1439               		.loc 1 971 0
 1440 0340 8B83      		std Y+3,r24
 1441 0342 00C0      		rjmp .L174
 1442               	.LVL88:
 1443               	.L95:
 1444               	.LBE52:
 972:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 973:stk500boot.c  **** 			}
 974:stk500boot.c  **** 				break;
 975:stk500boot.c  **** 
 976:stk500boot.c  **** 			case CMD_READ_LOCK_ISP:
 977:stk500boot.c  **** 				msgLength = 4;
 978:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1445               		.loc 1 978 0
 1446 0344 1A82      		std Y+2,__zero_reg__
 1447               	.LBB53:
 979:stk500boot.c  **** 				msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
 1448               		.loc 1 979 0
 1449 0346 E1E0      		ldi r30,lo8(1)
 1450 0348 F0E0      		ldi r31,hi8(1)
 1451 034a 89E0      		ldi r24,lo8(9)
 1452               	/* #APP */
 1453               	 ;  979 "stk500boot.c" 1
 1454 034c 8093 5700 		sts 87, r24
 1455 0350 E491      		lpm r30, Z
 1456               		
 1457               	 ;  0 "" 2
 1458               	/* #NOAPP */
 1459               	.L176:
 1460               	.LVL89:
 1461               	.LBE53:
 1462 0352 EB83      		std Y+3,r30
 1463               	.LVL90:
 1464               	.L174:
 980:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 1465               		.loc 1 980 0
 1466 0354 1C82      		std Y+4,__zero_reg__
 977:stk500boot.c  **** 				msgLength = 4;
 1467               		.loc 1 977 0
 1468 0356 94E0      		ldi r25,lo8(4)
 1469 0358 C92E      		mov r12,r25
 1470 035a D12C      		mov r13,__zero_reg__
 981:stk500boot.c  **** 				break;
 1471               		.loc 1 981 0
 1472 035c 00C0      		rjmp .L104
 1473               	.LVL91:
 1474               	.L93:
 1475               	.LBB54:
 982:stk500boot.c  **** 
 983:stk500boot.c  **** 			case CMD_READ_FUSE_ISP: {
 984:stk500boot.c  **** 				unsigned char fuseBits;
 985:stk500boot.c  **** 
 986:stk500boot.c  **** 				if (msgBuffer[2] == 0x50) {
 1476               		.loc 1 986 0
 1477 035e 8B81      		ldd r24,Y+3
 1478 0360 8035      		cpi r24,lo8(80)
 1479 0362 01F4      		brne .L107
 987:stk500boot.c  **** 					if (msgBuffer[3] == 0x08)
 1480               		.loc 1 987 0
 1481 0364 8C81      		ldd r24,Y+4
 1482 0366 8830      		cpi r24,lo8(8)
 1483 0368 01F4      		brne .L108
 1484               	.LBB55:
 988:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1485               		.loc 1 988 0
 1486 036a E2E0      		ldi r30,lo8(2)
 1487 036c F0E0      		ldi r31,hi8(2)
 1488 036e 00C0      		rjmp .L171
 1489               	.L108:
 1490               	.LBE55:
 1491               	.LBB56:
 989:stk500boot.c  **** 					else
 990:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 1492               		.loc 1 990 0
 1493 0370 E0E0      		ldi r30,lo8(0)
 1494 0372 F0E0      		ldi r31,hi8(0)
 1495 0374 00C0      		rjmp .L171
 1496               	.L107:
 1497               	.LBE56:
 1498               	.LBB57:
 991:stk500boot.c  **** 				} else {
 992:stk500boot.c  **** 					fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 1499               		.loc 1 992 0
 1500 0376 E3E0      		ldi r30,lo8(3)
 1501 0378 F0E0      		ldi r31,hi8(3)
 1502               	.L171:
 1503 037a 89E0      		ldi r24,lo8(9)
 1504               	/* #APP */
 1505               	 ;  992 "stk500boot.c" 1
 1506 037c 8093 5700 		sts 87, r24
 1507 0380 E491      		lpm r30, Z
 1508               		
 1509               	 ;  0 "" 2
 1510               	.LVL92:
 1511               	/* #NOAPP */
 1512               	.LBE57:
 993:stk500boot.c  **** 				}
 994:stk500boot.c  **** 				msgLength = 4;
 995:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1513               		.loc 1 995 0
 1514 0382 1A82      		std Y+2,__zero_reg__
 1515 0384 00C0      		rjmp .L176
 1516               	.LVL93:
 1517               	.L94:
 1518               	.LBE54:
 1519               	.LBB59:
 996:stk500boot.c  **** 				msgBuffer[2] = fuseBits;
 997:stk500boot.c  **** 				msgBuffer[3] = STATUS_CMD_OK;
 998:stk500boot.c  **** 			}
 999:stk500boot.c  **** 				break;
1000:stk500boot.c  **** 
1001:stk500boot.c  **** #ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1002:stk500boot.c  **** 			case CMD_PROGRAM_LOCK_ISP: {
1003:stk500boot.c  **** 				unsigned char lockBits = msgBuffer[4];
1004:stk500boot.c  **** 
1005:stk500boot.c  **** 				lockBits = (~lockBits) & 0x3C; // mask BLBxx bits
 1520               		.loc 1 1005 0
 1521 0386 8D81      		ldd r24,Y+5
 1522               	.LVL94:
 1523               	.LBB60:
1006:stk500boot.c  **** 				boot_lock_bits_set(lockBits);
 1524               		.loc 1 1006 0
 1525 0388 836C      		ori r24,lo8(-61)
 1526 038a 99E0      		ldi r25,lo8(9)
 1527               	/* #APP */
 1528               	 ;  1006 "stk500boot.c" 1
 1529 038c E1E0      		ldi r30, 1
 1530 038e F0E0      		ldi r31, 0
 1531 0390 082E      		mov r0, r24
 1532 0392 9093 5700 		sts 87, r25
 1533 0396 E895      		spm
 1534               		
 1535               	 ;  0 "" 2
 1536               	/* #NOAPP */
 1537               	.L110:
 1538               	.LBE60:
1007:stk500boot.c  **** 				// and program it
1008:stk500boot.c  **** 				boot_spm_busy_wait();
 1539               		.loc 1 1008 0 discriminator 1
 1540 0398 07B6      		in __tmp_reg__,87-32
 1541 039a 00FC      		sbrc __tmp_reg__,0
 1542 039c 00C0      		rjmp .L110
 1543               	.LVL95:
1009:stk500boot.c  **** 
1010:stk500boot.c  **** 				msgLength = 3;
1011:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1544               		.loc 1 1011 0
 1545 039e 1A82      		std Y+2,__zero_reg__
1012:stk500boot.c  **** 				msgBuffer[2] = STATUS_CMD_OK;
 1546               		.loc 1 1012 0
 1547 03a0 1B82      		std Y+3,__zero_reg__
 1548               	.LVL96:
 1549               	.L172:
 1550               	.LBE59:
1010:stk500boot.c  **** 				msgLength = 3;
 1551               		.loc 1 1010 0
 1552 03a2 83E0      		ldi r24,lo8(3)
 1553 03a4 C82E      		mov r12,r24
 1554 03a6 D12C      		mov r13,__zero_reg__
1013:stk500boot.c  **** 			}
1014:stk500boot.c  **** 				break;
 1555               		.loc 1 1014 0
 1556 03a8 00C0      		rjmp .L104
 1557               	.LVL97:
 1558               	.L90:
1015:stk500boot.c  **** #endif
1016:stk500boot.c  **** 			case CMD_CHIP_ERASE_ISP:
1017:stk500boot.c  **** 				eraseAddress = 0;
1018:stk500boot.c  **** 				msgLength = 2;
1019:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1020:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED; //*	isue 543, return FAILED instead of OK
 1559               		.loc 1 1020 0
 1560 03aa 80EC      		ldi r24,lo8(-64)
 1561 03ac 8A83      		std Y+2,r24
1018:stk500boot.c  **** 				msgLength = 2;
 1562               		.loc 1 1018 0
 1563 03ae 02E0      		ldi r16,lo8(2)
 1564 03b0 C02E      		mov r12,r16
 1565 03b2 D12C      		mov r13,__zero_reg__
1017:stk500boot.c  **** 				eraseAddress = 0;
 1566               		.loc 1 1017 0
 1567 03b4 C25E      		subi r28,lo8(-286)
 1568 03b6 DE4F      		sbci r29,hi8(-286)
 1569 03b8 1882      		st Y,__zero_reg__
 1570 03ba 1982      		std Y+1,__zero_reg__
 1571 03bc 1A82      		std Y+2,__zero_reg__
 1572 03be 1B82      		std Y+3,__zero_reg__
 1573 03c0 CE51      		subi r28,lo8(286)
 1574 03c2 D140      		sbci r29,hi8(286)
1021:stk500boot.c  **** 				break;
 1575               		.loc 1 1021 0
 1576 03c4 00C0      		rjmp .L104
 1577               	.LVL98:
 1578               	.L88:
1022:stk500boot.c  **** 
1023:stk500boot.c  **** 			case CMD_LOAD_ADDRESS:
1024:stk500boot.c  **** #if defined(RAMPZ)
1025:stk500boot.c  **** 				address = ( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuf
 1579               		.loc 1 1025 0
 1580 03c6 8A81      		ldd r24,Y+2
 1581 03c8 90E0      		ldi r25,lo8(0)
 1582 03ca A0E0      		ldi r26,lo8(0)
 1583 03cc B0E0      		ldi r27,hi8(0)
 1584 03ce 782E      		mov r7,r24
 1585 03d0 6624      		clr r6
 1586 03d2 5524      		clr r5
 1587 03d4 4424      		clr r4
 1588 03d6 8B81      		ldd r24,Y+3
 1589 03d8 90E0      		ldi r25,lo8(0)
 1590 03da A0E0      		ldi r26,lo8(0)
 1591 03dc B0E0      		ldi r27,hi8(0)
 1592 03de DC01      		movw r26,r24
 1593 03e0 9927      		clr r25
 1594 03e2 8827      		clr r24
 1595 03e4 482A      		or r4,r24
 1596 03e6 592A      		or r5,r25
 1597 03e8 6A2A      		or r6,r26
 1598 03ea 7B2A      		or r7,r27
 1599 03ec 8D81      		ldd r24,Y+5
 1600 03ee 90E0      		ldi r25,lo8(0)
 1601 03f0 A0E0      		ldi r26,lo8(0)
 1602 03f2 B0E0      		ldi r27,hi8(0)
 1603 03f4 482A      		or r4,r24
 1604 03f6 592A      		or r5,r25
 1605 03f8 6A2A      		or r6,r26
 1606 03fa 7B2A      		or r7,r27
 1607 03fc 8C81      		ldd r24,Y+4
 1608 03fe 90E0      		ldi r25,lo8(0)
 1609 0400 A0E0      		ldi r26,lo8(0)
 1610 0402 B0E0      		ldi r27,hi8(0)
 1611 0404 BA2F      		mov r27,r26
 1612 0406 A92F      		mov r26,r25
 1613 0408 982F      		mov r25,r24
 1614 040a 8827      		clr r24
 1615 040c 482A      		or r4,r24
 1616 040e 592A      		or r5,r25
 1617 0410 6A2A      		or r6,r26
 1618 0412 7B2A      		or r7,r27
 1619 0414 440C      		lsl r4
 1620 0416 551C      		rol r5
 1621 0418 661C      		rol r6
 1622 041a 771C      		rol r7
 1623               	.L177:
 1624               	.LVL99:
1026:stk500boot.c  **** #else
1027:stk500boot.c  **** 				address = (((msgBuffer[3]) << 8) | (msgBuffer[4])) << 1; //convert word to byte address
1028:stk500boot.c  **** #endif
1029:stk500boot.c  **** 				msgLength = 2;
1030:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1625               		.loc 1 1030 0
 1626 041c 1A82      		std Y+2,__zero_reg__
 1627 041e 00C0      		rjmp .L173
 1628               	.LVL100:
 1629               	.L91:
 1630               	.LBB61:
1031:stk500boot.c  **** 				break;
1032:stk500boot.c  **** 
1033:stk500boot.c  **** 			case CMD_PROGRAM_FLASH_ISP:
1034:stk500boot.c  **** 			case CMD_PROGRAM_EEPROM_ISP: {
1035:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1631               		.loc 1 1035 0
 1632 0420 EA81      		ldd r30,Y+2
 1633 0422 C75D      		subi r28,lo8(-297)
 1634 0424 DE4F      		sbci r29,hi8(-297)
 1635 0426 E883      		st Y,r30
 1636 0428 C952      		subi r28,lo8(297)
 1637 042a D140      		sbci r29,hi8(297)
 1638 042c C85D      		subi r28,lo8(-296)
 1639 042e DE4F      		sbci r29,hi8(-296)
 1640 0430 1882      		st Y,__zero_reg__
 1641 0432 C852      		subi r28,lo8(296)
 1642 0434 D140      		sbci r29,hi8(296)
 1643 0436 CB80      		ldd r12,Y+3
 1644 0438 DD24      		clr r13
 1645 043a C85D      		subi r28,lo8(-296)
 1646 043c DE4F      		sbci r29,hi8(-296)
 1647 043e 2881      		ld r18,Y
 1648 0440 3981      		ldd r19,Y+1
 1649 0442 C852      		subi r28,lo8(296)
 1650 0444 D140      		sbci r29,hi8(296)
 1651 0446 C22A      		or r12,r18
 1652 0448 D32A      		or r13,r19
 1653               	.LVL101:
1036:stk500boot.c  **** 				unsigned char *p = msgBuffer + 10;
1037:stk500boot.c  **** 				unsigned int data;
1038:stk500boot.c  **** 				unsigned char highByte, lowByte;
1039:stk500boot.c  **** 				address_t tempaddress = address;
1040:stk500boot.c  **** 
1041:stk500boot.c  **** 				if (msgBuffer[0] == CMD_PROGRAM_FLASH_ISP) {
 1654               		.loc 1 1041 0
 1655 044a 8331      		cpi r24,lo8(19)
 1656 044c 01F0      		breq .+2
 1657 044e 00C0      		rjmp .L111
1042:stk500boot.c  **** 					// erase only main section (bootloader protection)
1043:stk500boot.c  **** 					if (eraseAddress < APP_END) {
 1658               		.loc 1 1043 0
 1659 0450 C25E      		subi r28,lo8(-286)
 1660 0452 DE4F      		sbci r29,hi8(-286)
 1661 0454 2881      		ld r18,Y
 1662 0456 3981      		ldd r19,Y+1
 1663 0458 4A81      		ldd r20,Y+2
 1664 045a 5B81      		ldd r21,Y+3
 1665 045c CE51      		subi r28,lo8(286)
 1666 045e D140      		sbci r29,hi8(286)
 1667 0460 2030      		cpi r18,lo8(245760)
 1668 0462 80EC      		ldi r24,hi8(245760)
 1669 0464 3807      		cpc r19,r24
 1670 0466 83E0      		ldi r24,hlo8(245760)
 1671 0468 4807      		cpc r20,r24
 1672 046a 80E0      		ldi r24,hhi8(245760)
 1673 046c 5807      		cpc r21,r24
 1674 046e 00F4      		brsh .L112
1044:stk500boot.c  **** 						boot_page_erase(eraseAddress);
 1675               		.loc 1 1044 0
 1676 0470 83E0      		ldi r24,lo8(3)
 1677               	/* #APP */
 1678               	 ;  1044 "stk500boot.c" 1
 1679 0472 F901      		movw r30, r18
 1680 0474 4093 5B00 		sts  91, r20
 1681 0478 8093 5700 		sts 87, r24
 1682 047c E895      		spm
 1683               		
 1684               	 ;  0 "" 2
 1685               	/* #NOAPP */
 1686               	.L113:
1045:stk500boot.c  **** 						// Perform page erase
1046:stk500boot.c  **** 						boot_spm_busy_wait(); // Wait until the memory is erased.
 1687               		.loc 1 1046 0 discriminator 1
 1688 047e 07B6      		in __tmp_reg__,87-32
 1689 0480 00FC      		sbrc __tmp_reg__,0
 1690 0482 00C0      		rjmp .L113
1047:stk500boot.c  **** 						eraseAddress += SPM_PAGESIZE; // point to next page to be erase
 1691               		.loc 1 1047 0
 1692 0484 C25E      		subi r28,lo8(-286)
 1693 0486 DE4F      		sbci r29,hi8(-286)
 1694 0488 2881      		ld r18,Y
 1695 048a 3981      		ldd r19,Y+1
 1696 048c 4A81      		ldd r20,Y+2
 1697 048e 5B81      		ldd r21,Y+3
 1698 0490 CE51      		subi r28,lo8(286)
 1699 0492 D140      		sbci r29,hi8(286)
 1700 0494 2050      		subi r18,lo8(-(256))
 1701 0496 3F4F      		sbci r19,hi8(-(256))
 1702 0498 4F4F      		sbci r20,hlo8(-(256))
 1703 049a 5F4F      		sbci r21,hhi8(-(256))
 1704 049c C25E      		subi r28,lo8(-286)
 1705 049e DE4F      		sbci r29,hi8(-286)
 1706 04a0 2883      		st Y,r18
 1707 04a2 3983      		std Y+1,r19
 1708 04a4 4A83      		std Y+2,r20
 1709 04a6 5B83      		std Y+3,r21
 1710 04a8 CE51      		subi r28,lo8(286)
 1711 04aa D140      		sbci r29,hi8(286)
 1712               	.LVL102:
 1713               	.L112:
 1714               		.loc 1 1047 0 is_stmt 0 discriminator 1
 1715 04ac 8B85      		ldd r24,Y+11
 1716 04ae DE01      		movw r26,r28
 1717 04b0 1D96      		adiw r26,13
 1718               	.LBE61:
 1719               	.LBB63:
 1720               	.LBB58:
 988:stk500boot.c  **** 						fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1721               		.loc 1 988 0 is_stmt 1 discriminator 1
 1722 04b2 9301      		movw r18,r6
 1723 04b4 8201      		movw r16,r4
 1724               	.LBE58:
 1725               	.LBE63:
 1726               	.LBB64:
1048:stk500boot.c  **** 					}
1049:stk500boot.c  **** 
1050:stk500boot.c  **** 					/* Write FLASH */
1051:stk500boot.c  **** 					do {
1052:stk500boot.c  **** 						lowByte = *p++;
1053:stk500boot.c  **** 						highByte = *p++;
1054:stk500boot.c  **** 
1055:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
1056:stk500boot.c  **** 						boot_page_fill(address, data);
 1727               		.loc 1 1056 0 discriminator 1
 1728 04b6 41E0      		ldi r20,lo8(1)
 1729 04b8 B601      		movw r22,r12
 1730               	.LVL103:
 1731               	.L115:
 607:stk500boot.c  **** int main(void) {
 1732               		.loc 1 607 0 discriminator 1
 1733 04ba FD01      		movw r30,r26
 1734 04bc 3197      		sbiw r30,1
1055:stk500boot.c  **** 						data = (highByte << 8) | lowByte;
 1735               		.loc 1 1055 0 discriminator 1
 1736 04be 5081      		ld r21,Z
 1737 04c0 C55D      		subi r28,lo8(-299)
 1738 04c2 DE4F      		sbci r29,hi8(-299)
 1739 04c4 5883      		st Y,r21
 1740 04c6 CB52      		subi r28,lo8(299)
 1741 04c8 D140      		sbci r29,hi8(299)
 1742 04ca C65D      		subi r28,lo8(-298)
 1743 04cc DE4F      		sbci r29,hi8(-298)
 1744 04ce 1882      		st Y,__zero_reg__
 1745 04d0 CA52      		subi r28,lo8(298)
 1746 04d2 D140      		sbci r29,hi8(298)
 1747 04d4 90E0      		ldi r25,lo8(0)
 1748 04d6 C65D      		subi r28,lo8(-298)
 1749 04d8 DE4F      		sbci r29,hi8(-298)
 1750 04da E881      		ld r30,Y
 1751 04dc F981      		ldd r31,Y+1
 1752 04de CA52      		subi r28,lo8(298)
 1753 04e0 D140      		sbci r29,hi8(298)
 1754 04e2 8E2B      		or r24,r30
 1755 04e4 9F2B      		or r25,r31
 1756               	.LVL104:
 1757               		.loc 1 1056 0 discriminator 1
 1758               	/* #APP */
 1759               	 ;  1056 "stk500boot.c" 1
 1760 04e6 0C01      		movw  r0, r24
 1761 04e8 F801      		movw r30, r16
 1762 04ea 2093 5B00 		sts 91, r18
 1763 04ee 4093 5700 		sts 87, r20
 1764 04f2 E895      		spm
 1765 04f4 1124      		clr  r1
 1766               		
 1767               	 ;  0 "" 2
1057:stk500boot.c  **** 
1058:stk500boot.c  **** 						address = address + 2; // Select next word in memory
 1768               		.loc 1 1058 0 discriminator 1
 1769               	/* #NOAPP */
 1770 04f6 0E5F      		subi r16,lo8(-(2))
 1771 04f8 1F4F      		sbci r17,hi8(-(2))
 1772 04fa 2F4F      		sbci r18,hlo8(-(2))
 1773 04fc 3F4F      		sbci r19,hhi8(-(2))
 1774               	.LVL105:
1059:stk500boot.c  **** 						size -= 2; // Reduce number of bytes to write by two
 1775               		.loc 1 1059 0 discriminator 1
 1776 04fe 6250      		subi r22,lo8(-(-2))
 1777 0500 7040      		sbci r23,hi8(-(-2))
 1778               	.LVL106:
1060:stk500boot.c  **** 					} while (size); // Loop until all bytes written
 1779               		.loc 1 1060 0 discriminator 1
 1780 0502 01F0      		breq .L114
1053:stk500boot.c  **** 						highByte = *p++;
 1781               		.loc 1 1053 0
 1782 0504 8C91      		ld r24,X
 1783 0506 1296      		adiw r26,2
 1784               	.LVL107:
 1785 0508 00C0      		rjmp .L115
 1786               	.LVL108:
 1787               	.L114:
1061:stk500boot.c  **** 
1062:stk500boot.c  **** 					boot_page_write(tempaddress);
 1788               		.loc 1 1062 0
 1789 050a 85E0      		ldi r24,lo8(5)
 1790               	/* #APP */
 1791               	 ;  1062 "stk500boot.c" 1
 1792 050c F201      		movw r30, r4
 1793 050e 6092 5B00 		sts 91, r6
 1794 0512 8093 5700 		sts 87, r24
 1795 0516 E895      		spm
 1796               		
 1797               	 ;  0 "" 2
 1798               	/* #NOAPP */
 1799               	.L116:
1063:stk500boot.c  **** 					boot_spm_busy_wait();
 1800               		.loc 1 1063 0 discriminator 1
 1801 0518 07B6      		in __tmp_reg__,87-32
 1802 051a 00FC      		sbrc __tmp_reg__,0
 1803 051c 00C0      		rjmp .L116
1064:stk500boot.c  **** 					boot_rww_enable(); // Re-enable the RWW section
 1804               		.loc 1 1064 0
 1805 051e 81E1      		ldi r24,lo8(17)
 1806               	/* #APP */
 1807               	 ;  1064 "stk500boot.c" 1
 1808 0520 8093 5700 		sts 87, r24
 1809 0524 E895      		spm
 1810               		
 1811               	 ;  0 "" 2
 1812               	/* #NOAPP */
 1813 0526 00C0      		rjmp .L117
 1814               	.LVL109:
 1815               	.L111:
 1816               	.LBB62:
1065:stk500boot.c  **** 				} else {
1066:stk500boot.c  **** 					//*	issue 543, this should work, It has not been tested.
1067:stk500boot.c  **** 					uint16_t ii = address >> 1;
 1817               		.loc 1 1067 0
 1818 0528 5301      		movw r10,r6
 1819 052a 4201      		movw r8,r4
 1820 052c B694      		lsr r11
 1821 052e A794      		ror r10
 1822 0530 9794      		ror r9
 1823 0532 8794      		ror r8
 1824               	.LVL110:
1068:stk500boot.c  **** 					/* write EEPROM */
1069:stk500boot.c  **** 					while (size) {
 1825               		.loc 1 1069 0
 1826 0534 00E0      		ldi r16,lo8(0)
 1827 0536 10E0      		ldi r17,hi8(0)
1036:stk500boot.c  **** 				unsigned char *p = msgBuffer + 10;
 1828               		.loc 1 1036 0
 1829 0538 6BE0      		ldi r22,lo8(11)
 1830 053a E62E      		mov r14,r22
 1831 053c F12C      		mov r15,__zero_reg__
 1832 053e EC0E      		add r14,r28
 1833 0540 FD1E      		adc r15,r29
 1834               		.loc 1 1069 0
 1835 0542 00C0      		rjmp .L118
 1836               	.LVL111:
 1837               	.L119:
1070:stk500boot.c  **** 						eeprom_write_byte((uint8_t*) ii, *p++);
 1838               		.loc 1 1070 0
 1839 0544 D701      		movw r26,r14
 1840 0546 6D91      		ld r22,X+
 1841 0548 7D01      		movw r14,r26
 1842               	.LVL112:
 607:stk500boot.c  **** int main(void) {
 1843               		.loc 1 607 0
 1844 054a C801      		movw r24,r16
 1845 054c 880D      		add r24,r8
 1846 054e 991D      		adc r25,r9
 1847               		.loc 1 1070 0
 1848 0550 0E94 0000 		call __eewr_byte_m2560
 1849               	.LVL113:
 1850 0554 0F5F      		subi r16,lo8(-(1))
 1851 0556 1F4F      		sbci r17,hi8(-(1))
 1852               	.LVL114:
 1853               	.L118:
1069:stk500boot.c  **** 					while (size) {
 1854               		.loc 1 1069 0 discriminator 1
 1855 0558 0C15      		cp r16,r12
 1856 055a 1D05      		cpc r17,r13
 1857 055c 01F4      		brne .L119
 607:stk500boot.c  **** int main(void) {
 1858               		.loc 1 607 0
 1859 055e 20E0      		ldi r18,lo8(0)
 1860 0560 30E0      		ldi r19,hi8(0)
 1861 0562 000F      		lsl r16
 1862 0564 111F      		rol r17
 1863 0566 221F      		rol r18
 1864 0568 331F      		rol r19
1069:stk500boot.c  **** 					while (size) {
 1865               		.loc 1 1069 0
 1866 056a 040D      		add r16,r4
 1867 056c 151D      		adc r17,r5
 1868 056e 261D      		adc r18,r6
 1869 0570 371D      		adc r19,r7
 1870               	.LVL115:
 1871               	.L117:
 1872               	.LBE62:
1071:stk500boot.c  **** 						address += 2; // Select next EEPROM byte
1072:stk500boot.c  **** 						ii++;
1073:stk500boot.c  **** 						size--;
1074:stk500boot.c  **** 					}
1075:stk500boot.c  **** 				}
1076:stk500boot.c  **** 				msgLength = 2;
1077:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_OK;
 1873               		.loc 1 1077 0
 1874 0572 1A82      		std Y+2,__zero_reg__
 1875               	.LBE64:
1078:stk500boot.c  **** 			}
1079:stk500boot.c  **** 				break;
 1876               		.loc 1 1079 0
 1877 0574 2801      		movw r4,r16
 1878 0576 3901      		movw r6,r18
 1879               	.LVL116:
 1880 0578 00C0      		rjmp .L173
 1881               	.LVL117:
 1882               	.L92:
 1883               	.LBB65:
1080:stk500boot.c  **** 
1081:stk500boot.c  **** 			case CMD_READ_FLASH_ISP:
1082:stk500boot.c  **** 			case CMD_READ_EEPROM_ISP: {
1083:stk500boot.c  **** 				unsigned int size = ((msgBuffer[1]) << 8) | msgBuffer[2];
 1884               		.loc 1 1083 0
 1885 057a BA81      		ldd r27,Y+2
 1886 057c C35D      		subi r28,lo8(-301)
 1887 057e DE4F      		sbci r29,hi8(-301)
 1888 0580 B883      		st Y,r27
 1889 0582 CD52      		subi r28,lo8(301)
 1890 0584 D140      		sbci r29,hi8(301)
 1891 0586 C45D      		subi r28,lo8(-300)
 1892 0588 DE4F      		sbci r29,hi8(-300)
 1893 058a 1882      		st Y,__zero_reg__
 1894 058c CC52      		subi r28,lo8(300)
 1895 058e D140      		sbci r29,hi8(300)
 1896 0590 2B81      		ldd r18,Y+3
 1897 0592 30E0      		ldi r19,lo8(0)
 1898               	.LVL118:
 1899 0594 C45D      		subi r28,lo8(-300)
 1900 0596 DE4F      		sbci r29,hi8(-300)
 1901 0598 4881      		ld r20,Y
 1902 059a 5981      		ldd r21,Y+1
 1903 059c CC52      		subi r28,lo8(300)
 1904 059e D140      		sbci r29,hi8(300)
 1905 05a0 242B      		or r18,r20
 1906 05a2 352B      		or r19,r21
 1907               	.LVL119:
1084:stk500boot.c  **** 				unsigned char *p = msgBuffer + 1;
1085:stk500boot.c  **** 				msgLength = size + 3;
 1908               		.loc 1 1085 0
 1909 05a4 93E0      		ldi r25,lo8(3)
 1910 05a6 C92E      		mov r12,r25
 1911 05a8 D12C      		mov r13,__zero_reg__
 1912 05aa C20E      		add r12,r18
 1913 05ac D31E      		adc r13,r19
 1914               	.LVL120:
1086:stk500boot.c  **** 
1087:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 1915               		.loc 1 1087 0
 1916 05ae 1A82      		std Y+2,__zero_reg__
 1917               	.LVL121:
1088:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1918               		.loc 1 1088 0
 1919 05b0 8431      		cpi r24,lo8(20)
 1920 05b2 01F4      		brne .L151
 1921 05b4 DE01      		movw r26,r28
 1922 05b6 1396      		adiw r26,3
 1923 05b8 A901      		movw r20,r18
 1924 05ba 9D01      		movw r18,r26
 1925               	.LVL122:
 1926 05bc D301      		movw r26,r6
 1927 05be C201      		movw r24,r4
 1928               	.LVL123:
 1929               	.L121:
 1930               	.LBB66:
 1931               	.LBB67:
1089:stk500boot.c  **** 					unsigned int data;
1090:stk500boot.c  **** 
1091:stk500boot.c  **** 					// Read FLASH
1092:stk500boot.c  **** 					do {
1093:stk500boot.c  **** 						//#if defined(RAMPZ)
1094:stk500boot.c  **** #if (FLASHEND > 0x10000)
1095:stk500boot.c  **** 						data = pgm_read_word_far(address);
 1932               		.loc 1 1095 0 discriminator 1
 1933               	/* #APP */
 1934               	 ;  1095 "stk500boot.c" 1
 1935 05c0 ABBF      		out 59, r26
 1936 05c2 FC01      		movw r30, r24
 1937 05c4 6791      		elpm r22, Z+
 1938 05c6 7691      		elpm r23, Z
 1939               		
 1940               	 ;  0 "" 2
 1941               	/* #NOAPP */
 1942               	.LBE67:
1096:stk500boot.c  **** #else
1097:stk500boot.c  **** 						data = pgm_read_word_near(address);
1098:stk500boot.c  **** #endif
1099:stk500boot.c  **** 						*p++ = (unsigned char) data; //LSB
 1943               		.loc 1 1099 0 discriminator 1
 1944 05c8 F901      		movw r30,r18
 1945 05ca 6083      		st Z,r22
 1946               	.LVL124:
1100:stk500boot.c  **** 						*p++ = (unsigned char) (data >> 8); //MSB
 1947               		.loc 1 1100 0 discriminator 1
 1948 05cc 7183      		std Z+1,r23
 607:stk500boot.c  **** int main(void) {
 1949               		.loc 1 607 0 discriminator 1
 1950 05ce 2E5F      		subi r18,lo8(-(2))
 1951 05d0 3F4F      		sbci r19,hi8(-(2))
 1952               	.LVL125:
1101:stk500boot.c  **** 						address += 2; // Select next word in memory
 1953               		.loc 1 1101 0 discriminator 1
 1954 05d2 0296      		adiw r24,2
 1955 05d4 A11D      		adc r26,__zero_reg__
 1956 05d6 B11D      		adc r27,__zero_reg__
 1957               	.LVL126:
1102:stk500boot.c  **** 						size -= 2;
 1958               		.loc 1 1102 0 discriminator 1
 1959 05d8 4250      		subi r20,lo8(-(-2))
 1960 05da 5040      		sbci r21,hi8(-(-2))
 1961               	.LVL127:
1103:stk500boot.c  **** 					} while (size);
 1962               		.loc 1 1103 0 discriminator 1
 1963 05dc 01F4      		brne .L121
 1964 05de 2C01      		movw r4,r24
 1965 05e0 3D01      		movw r6,r26
 1966 05e2 D901      		movw r26,r18
 1967 05e4 00C0      		rjmp .L122
 1968               	.LVL128:
 1969               	.L151:
 1970               	.LBE66:
1088:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP) {
 1971               		.loc 1 1088 0
 1972 05e6 F901      		movw r30,r18
 1973 05e8 B301      		movw r22,r6
 1974 05ea A201      		movw r20,r4
 1975 05ec 8E01      		movw r16,r28
 1976 05ee 0D5F      		subi r16,lo8(-(3))
 1977 05f0 1F4F      		sbci r17,hi8(-(3))
 1978               	.LVL129:
 1979               	.L120:
1104:stk500boot.c  **** 				} else {
1105:stk500boot.c  **** 					/* Read EEPROM */
1106:stk500boot.c  **** 					do {
1107:stk500boot.c  **** 						EEARL = address; // Setup EEPROM address
 1980               		.loc 1 1107 0 discriminator 1
 1981 05f2 41BD      		out 65-32,r20
1108:stk500boot.c  **** 						EEARH = ((address >> 8));
 1982               		.loc 1 1108 0 discriminator 1
 1983 05f4 BB27      		clr r27
 1984 05f6 A72F      		mov r26,r23
 1985 05f8 962F      		mov r25,r22
 1986 05fa 852F      		mov r24,r21
 1987 05fc 82BD      		out 66-32,r24
1109:stk500boot.c  **** 						address++; // Select next EEPROM byte
 1988               		.loc 1 1109 0 discriminator 1
 1989 05fe 4F5F      		subi r20,lo8(-(1))
 1990 0600 5F4F      		sbci r21,hi8(-(1))
 1991 0602 6F4F      		sbci r22,hlo8(-(1))
 1992 0604 7F4F      		sbci r23,hhi8(-(1))
 1993               	.LVL130:
1110:stk500boot.c  **** 						EECR |= (1 << EERE); // Read EEPROM
 1994               		.loc 1 1110 0 discriminator 1
 1995 0606 F89A      		sbi 63-32,0
1111:stk500boot.c  **** 						*p++ = EEDR; // Send EEPROM data
 1996               		.loc 1 1111 0 discriminator 1
 1997 0608 80B5      		in r24,64-32
 1998 060a D801      		movw r26,r16
 1999 060c 8D93      		st X+,r24
 2000 060e 8D01      		movw r16,r26
 2001               	.LVL131:
1112:stk500boot.c  **** 						size--;
 2002               		.loc 1 1112 0 discriminator 1
 2003 0610 3197      		sbiw r30,1
 2004               	.LVL132:
1113:stk500boot.c  **** 					} while (size);
 2005               		.loc 1 1113 0 discriminator 1
 2006 0612 01F4      		brne .L120
 607:stk500boot.c  **** int main(void) {
 2007               		.loc 1 607 0
 2008 0614 C901      		movw r24,r18
 2009 0616 0197      		sbiw r24,1
 2010 0618 A0E0      		ldi r26,lo8(0)
 2011 061a B0E0      		ldi r27,hi8(0)
 2012               	.LVL133:
 2013 061c 0196      		adiw r24,1
 2014 061e A11D      		adc r26,__zero_reg__
 2015 0620 B11D      		adc r27,__zero_reg__
 2016               		.loc 1 1113 0
 2017 0622 480E      		add r4,r24
 2018 0624 591E      		adc r5,r25
 2019 0626 6A1E      		adc r6,r26
 2020 0628 7B1E      		adc r7,r27
 2021 062a A3E0      		ldi r26,lo8(3)
 2022 062c B0E0      		ldi r27,hi8(3)
 2023 062e AC0F      		add r26,r28
 2024 0630 BD1F      		adc r27,r29
 2025 0632 A20F      		add r26,r18
 2026 0634 B31F      		adc r27,r19
 2027               	.LVL134:
 2028               	.L122:
1114:stk500boot.c  **** 				}
1115:stk500boot.c  **** 				*p++ = STATUS_CMD_OK;
 2029               		.loc 1 1115 0
 2030 0636 1C92      		st X,__zero_reg__
 2031               	.LVL135:
 2032               	.LBE65:
1116:stk500boot.c  **** 			}
1117:stk500boot.c  **** 				break;
 2033               		.loc 1 1117 0
 2034 0638 00C0      		rjmp .L104
 2035               	.LVL136:
 2036               	.L84:
1118:stk500boot.c  **** 
1119:stk500boot.c  **** 			default:
1120:stk500boot.c  **** 				msgLength = 2;
1121:stk500boot.c  **** 				msgBuffer[1] = STATUS_CMD_FAILED;
 2037               		.loc 1 1121 0
 2038 063a 80EC      		ldi r24,lo8(-64)
 2039 063c 8A83      		std Y+2,r24
 2040               	.LVL137:
 2041               	.L173:
1120:stk500boot.c  **** 				msgLength = 2;
 2042               		.loc 1 1120 0
 2043 063e B2E0      		ldi r27,lo8(2)
 2044 0640 CB2E      		mov r12,r27
 2045 0642 D12C      		mov r13,__zero_reg__
 2046               	.LVL138:
 2047               	.L104:
1122:stk500boot.c  **** 				break;
1123:stk500boot.c  **** 			}
1124:stk500boot.c  **** 
1125:stk500boot.c  **** 			/*
1126:stk500boot.c  **** 			 * Now send answer message back
1127:stk500boot.c  **** 			 */
1128:stk500boot.c  **** 			sendchar(MESSAGE_START);
 2048               		.loc 1 1128 0
 2049 0644 8BE1      		ldi r24,lo8(27)
 2050 0646 0E94 0000 		call sendchar
 2051               	.LVL139:
1129:stk500boot.c  **** 			checksum = MESSAGE_START ^ 0;
1130:stk500boot.c  **** 
1131:stk500boot.c  **** 			sendchar(seqNum);
 2052               		.loc 1 1131 0
 2053 064a 822D      		mov r24,r2
 2054 064c 0E94 0000 		call sendchar
 2055               	.LVL140:
1132:stk500boot.c  **** 			checksum ^= seqNum;
1133:stk500boot.c  **** 
1134:stk500boot.c  **** 			c = ((msgLength >> 8) & 0xFF);
1135:stk500boot.c  **** 			sendchar(c);
 2056               		.loc 1 1135 0
 2057 0650 8D2D      		mov r24,r13
 2058 0652 0E94 0000 		call sendchar
 2059               	.LVL141:
1136:stk500boot.c  **** 			checksum ^= c;
1137:stk500boot.c  **** 
1138:stk500boot.c  **** 			c = msgLength & 0x00FF;
1139:stk500boot.c  **** 			sendchar(c);
 2060               		.loc 1 1139 0
 2061 0656 8C2D      		mov r24,r12
 2062 0658 0E94 0000 		call sendchar
 2063               	.LVL142:
1140:stk500boot.c  **** 			checksum ^= c;
1141:stk500boot.c  **** 
1142:stk500boot.c  **** 			sendchar(TOKEN);
 2064               		.loc 1 1142 0
 2065 065c 8EE0      		ldi r24,lo8(14)
 2066 065e 0E94 0000 		call sendchar
1136:stk500boot.c  **** 			checksum ^= c;
 2067               		.loc 1 1136 0
 2068 0662 A5E1      		ldi r26,lo8(21)
 2069 0664 EA2E      		mov r14,r26
 2070 0666 E224      		eor r14,r2
1140:stk500boot.c  **** 			checksum ^= c;
 2071               		.loc 1 1140 0
 2072 0668 EC24      		eor r14,r12
1143:stk500boot.c  **** 			checksum ^= TOKEN;
 2073               		.loc 1 1143 0
 2074 066a ED24      		eor r14,r13
 2075               	.LVL143:
1144:stk500boot.c  **** 
1145:stk500boot.c  **** 			p = msgBuffer;
 2076               		.loc 1 1145 0
 2077 066c 4E01      		movw r8,r28
 2078 066e 0894      		sec
 2079 0670 811C      		adc r8,__zero_reg__
 2080 0672 911C      		adc r9,__zero_reg__
1146:stk500boot.c  **** 			while (msgLength) {
 2081               		.loc 1 1146 0
 2082 0674 00C0      		rjmp .L123
 2083               	.LVL144:
 2084               	.L124:
1147:stk500boot.c  **** 				c = *p++;
 2085               		.loc 1 1147 0
 2086 0676 F401      		movw r30,r8
 2087 0678 1191      		ld r17,Z+
 2088 067a 4F01      		movw r8,r30
 2089               	.LVL145:
1148:stk500boot.c  **** 				sendchar(c);
 2090               		.loc 1 1148 0
 2091 067c 812F      		mov r24,r17
 2092 067e 0E94 0000 		call sendchar
 2093               	.LVL146:
1149:stk500boot.c  **** 				checksum ^= c;
 2094               		.loc 1 1149 0
 2095 0682 E126      		eor r14,r17
 2096               	.LVL147:
1150:stk500boot.c  **** 				msgLength--;
 2097               		.loc 1 1150 0
 2098 0684 0894      		sec
 2099 0686 C108      		sbc r12,__zero_reg__
 2100 0688 D108      		sbc r13,__zero_reg__
 2101               	.LVL148:
 2102               	.L123:
1146:stk500boot.c  **** 			while (msgLength) {
 2103               		.loc 1 1146 0 discriminator 1
 2104 068a C114      		cp r12,__zero_reg__
 2105 068c D104      		cpc r13,__zero_reg__
 2106 068e 01F4      		brne .L124
1151:stk500boot.c  **** 			}
1152:stk500boot.c  **** 			sendchar(checksum);
 2107               		.loc 1 1152 0
 2108 0690 8E2D      		mov r24,r14
 2109 0692 0E94 0000 		call sendchar
1153:stk500boot.c  **** 			seqNum++;
 2110               		.loc 1 1153 0
 2111 0696 2394      		inc r2
 2112               	.LVL149:
 755:stk500boot.c  **** 		while (!isLeave) {
 2113               		.loc 1 755 0
 2114 0698 3320      		tst r3
 2115 069a 01F0      		breq .+2
 2116 069c 00C0      		rjmp .L125
 2117 069e 80E0      		ldi r24,lo8(0)
 2118 06a0 90E0      		ldi r25,hi8(0)
 2119 06a2 00C0      		rjmp .L65
 2120               	.LVL150:
 2121               	.L178:
 753:stk500boot.c  **** 	if (boot_state == 1) {
 2122               		.loc 1 753 0
 2123 06a4 CA5D      		subi r28,lo8(-294)
 2124 06a6 DE4F      		sbci r29,hi8(-294)
 2125 06a8 1982      		std Y+1,__zero_reg__
 2126 06aa 1882      		st Y,__zero_reg__
 2127 06ac C652      		subi r28,lo8(294)
 2128 06ae D140      		sbci r29,hi8(294)
 2129 06b0 CC5D      		subi r28,lo8(-292)
 2130 06b2 DE4F      		sbci r29,hi8(-292)
 2131 06b4 1982      		std Y+1,__zero_reg__
 2132 06b6 1882      		st Y,__zero_reg__
 2133 06b8 C452      		subi r28,lo8(292)
 2134 06ba D140      		sbci r29,hi8(292)
 2135 06bc 2224      		clr r2
 2136 06be 10E0      		ldi r17,lo8(0)
 2137 06c0 CE5D      		subi r28,lo8(-290)
 2138 06c2 DE4F      		sbci r29,hi8(-290)
 2139 06c4 1982      		std Y+1,__zero_reg__
 2140 06c6 1882      		st Y,__zero_reg__
 2141 06c8 C252      		subi r28,lo8(290)
 2142 06ca D140      		sbci r29,hi8(290)
 2143 06cc C25E      		subi r28,lo8(-286)
 2144 06ce DE4F      		sbci r29,hi8(-286)
 2145 06d0 1882      		st Y,__zero_reg__
 2146 06d2 1982      		std Y+1,__zero_reg__
 2147 06d4 1A82      		std Y+2,__zero_reg__
 2148 06d6 1B82      		std Y+3,__zero_reg__
 2149 06d8 CE51      		subi r28,lo8(286)
 2150 06da D140      		sbci r29,hi8(286)
 2151 06dc 4424      		clr r4
 2152 06de 5524      		clr r5
 2153 06e0 3201      		movw r6,r4
 2154               	.LBB68:
 2155               	.LBB44:
 2156               	.LBB42:
 2157               	.LBB41:
 508:stk500boot.c  **** 			data = pgm_read_word_far(0); //*	get the first word of the user program
 2158               		.loc 1 508 0
 2159 06e2 20E0      		ldi r18,lo8(0)
 2160 06e4 30E0      		ldi r19,hi8(0)
 2161 06e6 A901      		movw r20,r18
 2162               	/* #APP */
 2163               	 ;  508 "stk500boot.c" 1
 2164 06e8 4BBF      		out 59, r20
 2165 06ea F901      		movw r30, r18
 2166 06ec 4791      		elpm r20, Z+
 2167 06ee 5691      		elpm r21, Z
 2168               		
 2169               	 ;  0 "" 2
 2170               	/* #NOAPP */
 2171 06f0 C25D      		subi r28,lo8(-302)
 2172 06f2 DE4F      		sbci r29,hi8(-302)
 2173 06f4 5983      		std Y+1,r21
 2174 06f6 4883      		st Y,r20
 2175 06f8 CE52      		subi r28,lo8(302)
 2176 06fa D140      		sbci r29,hi8(302)
 2177 06fc E12E      		mov r14,r17
 2178               	.LVL151:
 2179               	.L65:
 2180               	.LBE41:
 2181               	.LBE42:
 2182               	.LBE44:
 2183               	.LBE68:
 673:stk500boot.c  **** 	boot_timer = 0;
 2184               		.loc 1 673 0 discriminator 1
 2185 06fe 40E0      		ldi r20,lo8(0)
 2186 0700 50E0      		ldi r21,hi8(0)
 2187 0702 20E0      		ldi r18,lo8(0)
 2188 0704 CE5D      		subi r28,lo8(-290)
 2189 0706 DE4F      		sbci r29,hi8(-290)
 2190 0708 0881      		ld r16,Y
 2191 070a 1981      		ldd r17,Y+1
 2192 070c C252      		subi r28,lo8(290)
 2193 070e D140      		sbci r29,hi8(290)
 2194 0710 CC5D      		subi r28,lo8(-292)
 2195 0712 DE4F      		sbci r29,hi8(-292)
 2196 0714 6881      		ld r22,Y
 2197 0716 7981      		ldd r23,Y+1
 2198 0718 C452      		subi r28,lo8(292)
 2199 071a D140      		sbci r29,hi8(292)
 2200 071c CA5D      		subi r28,lo8(-294)
 2201 071e DE4F      		sbci r29,hi8(-294)
 2202 0720 C880      		ld r12,Y
 2203 0722 D980      		ldd r13,Y+1
 2204 0724 C652      		subi r28,lo8(294)
 2205 0726 D140      		sbci r29,hi8(294)
 2206 0728 00C0      		rjmp .L126
 2207               	.LVL152:
 2208               	.L165:
1154:stk500boot.c  **** 
1155:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1156:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1157:stk500boot.c  **** 		//	PROGLED_PORT ^= (1 << PROGLED_PIN); // active high LED ON
1158:stk500boot.c  **** #endif
1159:stk500boot.c  **** 
1160:stk500boot.c  **** 		}
1161:stk500boot.c  **** 	}
1162:stk500boot.c  **** 
1163:stk500boot.c  **** 	if (boot_state == 2) {
 2209               		.loc 1 1163 0
 2210 072a 8230      		cpi r24,2
 2211 072c 9105      		cpc r25,__zero_reg__
 2212 072e 01F0      		breq .+2
 2213 0730 00C0      		rjmp .L125
1164:stk500boot.c  **** 		if (eeprom_read_byte(4095) == 0xF0) {
 2214               		.loc 1 1164 0
 2215 0732 8FEF      		ldi r24,lo8(4095)
 2216 0734 9FE0      		ldi r25,hi8(4095)
 2217               	.LVL153:
 2218 0736 0E94 0000 		call __eerd_byte_m2560
 2219 073a 803F      		cpi r24,lo8(-16)
 2220 073c 01F0      		breq .+2
 2221 073e 00C0      		rjmp .L125
 2222               	.LBB69:
1165:stk500boot.c  **** 			sendchar('u');
 2223               		.loc 1 1165 0
 2224 0740 85E7      		ldi r24,lo8(117)
 2225 0742 0E94 0000 		call sendchar
1166:stk500boot.c  **** 			sendchar('p');
 2226               		.loc 1 1166 0
 2227 0746 80E7      		ldi r24,lo8(112)
 2228 0748 0E94 0000 		call sendchar
1167:stk500boot.c  **** 			sendchar('g');
 2229               		.loc 1 1167 0
 2230 074c 87E6      		ldi r24,lo8(103)
 2231 074e 0E94 0000 		call sendchar
1168:stk500boot.c  **** 			sendchar('r');
 2232               		.loc 1 1168 0
 2233 0752 82E7      		ldi r24,lo8(114)
 2234 0754 0E94 0000 		call sendchar
1169:stk500boot.c  **** 			sendchar('a');
 2235               		.loc 1 1169 0
 2236 0758 81E6      		ldi r24,lo8(97)
 2237 075a 0E94 0000 		call sendchar
1170:stk500boot.c  **** 			sendchar('d');
 2238               		.loc 1 1170 0
 2239 075e 84E6      		ldi r24,lo8(100)
 2240 0760 0E94 0000 		call sendchar
1171:stk500boot.c  **** 			sendchar('i');
 2241               		.loc 1 1171 0
 2242 0764 89E6      		ldi r24,lo8(105)
 2243 0766 0E94 0000 		call sendchar
1172:stk500boot.c  **** 			sendchar('n');
 2244               		.loc 1 1172 0
 2245 076a 8EE6      		ldi r24,lo8(110)
 2246 076c 0E94 0000 		call sendchar
1173:stk500boot.c  **** 			sendchar('g');
 2247               		.loc 1 1173 0
 2248 0770 87E6      		ldi r24,lo8(103)
 2249 0772 0E94 0000 		call sendchar
1174:stk500boot.c  **** 			sendchar(0x0d);
 2250               		.loc 1 1174 0
 2251 0776 8DE0      		ldi r24,lo8(13)
 2252 0778 0E94 0000 		call sendchar
1175:stk500boot.c  **** 			sendchar(0x0a);
 2253               		.loc 1 1175 0
 2254 077c 8AE0      		ldi r24,lo8(10)
 2255 077e 0E94 0000 		call sendchar
1176:stk500boot.c  **** 			delay_ms(100);
 2256               		.loc 1 1176 0
 2257 0782 84E6      		ldi r24,lo8(100)
 2258 0784 90E0      		ldi r25,hi8(100)
 2259 0786 0E94 0000 		call delay_ms
1177:stk500boot.c  **** 
1178:stk500boot.c  **** 			DWORD fa; /* Flash address */
1179:stk500boot.c  **** 			sendchar(0x0d);
 2260               		.loc 1 1179 0
 2261 078a 8DE0      		ldi r24,lo8(13)
 2262 078c 0E94 0000 		call sendchar
1180:stk500boot.c  **** 			sendchar(0x0a);
 2263               		.loc 1 1180 0
 2264 0790 8AE0      		ldi r24,lo8(10)
 2265 0792 0E94 0000 		call sendchar
 2266               	.LVL154:
1181:stk500boot.c  **** 			long address = 16;
1182:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2267               		.loc 1 1182 0
 2268 0796 8824      		clr r8
 2269 0798 9924      		clr r9
 2270 079a 5401      		movw r10,r8
 2271               	.LBB70:
1183:stk500boot.c  **** 		//		PROGLED_PORT ^= (1 << PROGLED_PIN); // turn LED ON
1184:stk500boot.c  **** 				delay_ms(50);
1185:stk500boot.c  **** 				flash_erase(fa); /* Erase a page */
1186:stk500boot.c  **** 				memset(Buff, 0xFF, SPM_PAGESIZE); /* Clear buffer */
1187:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
1188:stk500boot.c  **** 					Buff[i] = spiReadReg(address);
1189:stk500boot.c  **** 					address++;
1190:stk500boot.c  **** 					// sendchar('[');
1191:stk500boot.c  **** 					// dec_hex(Buff[i]);
1192:stk500boot.c  **** 					// sendchar(']');
1193:stk500boot.c  **** 					// if(address % 16 == 0 && address != 0){
1194:stk500boot.c  **** 					// 	sendchar(0x0d);
1195:stk500boot.c  **** 					// 	sendchar(0x0a);
1196:stk500boot.c  **** 					// }
1197:stk500boot.c  **** 					// 
1198:stk500boot.c  **** 					// 
1199:stk500boot.c  **** 					if(((address +1)%1200) <= 300 && ((address +1)%1200) >= 0){
 2272               		.loc 1 1199 0
 2273 079c F0EB      		ldi r31,lo8(1200)
 2274 079e 4F2E      		mov r4,r31
 2275 07a0 F4E0      		ldi r31,hi8(1200)
 2276 07a2 5F2E      		mov r5,r31
 2277 07a4 612C      		mov r6,__zero_reg__
 2278 07a6 712C      		mov r7,__zero_reg__
 2279               	.LVL155:
 2280               	.L131:
 2281               	.LBE70:
 607:stk500boot.c  **** int main(void) {
 2282               		.loc 1 607 0
 2283 07a8 40E1      		ldi r20,lo8(16)
 2284 07aa C42E      		mov r12,r20
 2285 07ac D12C      		mov r13,__zero_reg__
 2286 07ae E12C      		mov r14,__zero_reg__
 2287 07b0 F12C      		mov r15,__zero_reg__
 2288 07b2 C80C      		add r12,r8
 2289 07b4 D91C      		adc r13,r9
 2290 07b6 EA1C      		adc r14,r10
 2291 07b8 FB1C      		adc r15,r11
1184:stk500boot.c  **** 				delay_ms(50);
 2292               		.loc 1 1184 0
 2293 07ba 82E3      		ldi r24,lo8(50)
 2294 07bc 90E0      		ldi r25,hi8(50)
 2295 07be 0E94 0000 		call delay_ms
1185:stk500boot.c  **** 				flash_erase(fa); /* Erase a page */
 2296               		.loc 1 1185 0
 2297 07c2 C501      		movw r24,r10
 2298 07c4 B401      		movw r22,r8
 2299 07c6 0E94 0000 		call flash_erase
1186:stk500boot.c  **** 				memset(Buff, 0xFF, SPM_PAGESIZE); /* Clear buffer */
 2300               		.loc 1 1186 0
 2301 07ca 80E0      		ldi r24,lo8(Buff)
 2302 07cc 90E0      		ldi r25,hi8(Buff)
 2303 07ce 6FEF      		ldi r22,lo8(255)
 2304 07d0 70E0      		ldi r23,hi8(255)
 2305 07d2 40E0      		ldi r20,lo8(256)
 2306 07d4 51E0      		ldi r21,hi8(256)
 2307 07d6 0E94 0000 		call memset
 2308               	.LVL156:
 2309 07da E0E0      		ldi r30,lo8(Buff)
 2310 07dc 2E2E      		mov r2,r30
 2311 07de E0E0      		ldi r30,hi8(Buff)
 2312 07e0 3E2E      		mov r3,r30
1187:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
 2313               		.loc 1 1187 0
 2314 07e2 00E0      		ldi r16,lo8(0)
 2315 07e4 10E0      		ldi r17,hi8(0)
 2316               	.LVL157:
 2317               	.L130:
 2318               	.LBB71:
1188:stk500boot.c  **** 					Buff[i] = spiReadReg(address);
 2319               		.loc 1 1188 0
 2320 07e6 C701      		movw r24,r14
 2321 07e8 B601      		movw r22,r12
 2322 07ea 0E94 0000 		call spiReadReg
 2323 07ee D101      		movw r26,r2
 2324 07f0 8D93      		st X+,r24
 2325 07f2 1D01      		movw r2,r26
1189:stk500boot.c  **** 					address++;
 2326               		.loc 1 1189 0
 2327 07f4 0894      		sec
 2328 07f6 C11C      		adc r12,__zero_reg__
 2329 07f8 D11C      		adc r13,__zero_reg__
 2330 07fa E11C      		adc r14,__zero_reg__
 2331 07fc F11C      		adc r15,__zero_reg__
 2332               	.LVL158:
 607:stk500boot.c  **** int main(void) {
 2333               		.loc 1 607 0
 2334 07fe C701      		movw r24,r14
 2335 0800 B601      		movw r22,r12
 2336 0802 6F5F      		subi r22,lo8(-(1))
 2337 0804 7F4F      		sbci r23,hi8(-(1))
 2338 0806 8F4F      		sbci r24,hlo8(-(1))
 2339 0808 9F4F      		sbci r25,hhi8(-(1))
 2340               		.loc 1 1199 0
 2341 080a A301      		movw r20,r6
 2342 080c 9201      		movw r18,r4
 2343 080e 0E94 0000 		call __divmodsi4
 2344 0812 DC01      		movw r26,r24
 2345 0814 CB01      		movw r24,r22
 2346 0816 8D32      		cpi r24,lo8(301)
 2347 0818 E1E0      		ldi r30,hi8(301)
 2348 081a 9E07      		cpc r25,r30
 2349 081c E0E0      		ldi r30,hlo8(301)
 2350 081e AE07      		cpc r26,r30
 2351 0820 E0E0      		ldi r30,hhi8(301)
 2352 0822 BE07      		cpc r27,r30
 2353 0824 00F4      		brsh .L127
1200:stk500boot.c  **** 						LED1_HIGH();
 2354               		.loc 1 1200 0
 2355 0826 2D9A      		sbi 37-32,5
1201:stk500boot.c  **** 						LED2_LOW();
 2356               		.loc 1 1201 0
 2357 0828 2E98      		cbi 37-32,6
 2358 082a 00C0      		rjmp .L175
 2359               	.L127:
1202:stk500boot.c  **** 						LED3_LOW();
1203:stk500boot.c  **** 					}else if(((address +1)%1200) <= 700 && ((address +1)%1200) >= 400){
 2360               		.loc 1 1203 0
 2361 082c AC01      		movw r20,r24
 2362 082e BD01      		movw r22,r26
 2363 0830 4059      		subi r20,lo8(-(-400))
 2364 0832 5140      		sbci r21,hi8(-(-400))
 2365 0834 6040      		sbci r22,hlo8(-(-400))
 2366 0836 7040      		sbci r23,hhi8(-(-400))
 2367 0838 4D32      		cpi r20,lo8(301)
 2368 083a F1E0      		ldi r31,hi8(301)
 2369 083c 5F07      		cpc r21,r31
 2370 083e F0E0      		ldi r31,hlo8(301)
 2371 0840 6F07      		cpc r22,r31
 2372 0842 F0E0      		ldi r31,hhi8(301)
 2373 0844 7F07      		cpc r23,r31
 2374 0846 00F4      		brsh .L129
1204:stk500boot.c  **** 						LED1_LOW();
 2375               		.loc 1 1204 0
 2376 0848 2D98      		cbi 37-32,5
1205:stk500boot.c  **** 						LED2_HIGH();
 2377               		.loc 1 1205 0
 2378 084a 2E9A      		sbi 37-32,6
 2379               	.L175:
1206:stk500boot.c  **** 						LED3_LOW();
 2380               		.loc 1 1206 0
 2381 084c 2F98      		cbi 37-32,7
 2382 084e 00C0      		rjmp .L128
 2383               	.L129:
1207:stk500boot.c  **** 					}else if( ((address +1) %1200) <= 1100  && ((address +1) %1200) >= 8){
 2384               		.loc 1 1207 0
 2385 0850 0897      		sbiw r24,8
 2386 0852 A109      		sbc r26,__zero_reg__
 2387 0854 B109      		sbc r27,__zero_reg__
 2388 0856 8534      		cpi r24,lo8(1093)
 2389 0858 24E0      		ldi r18,hi8(1093)
 2390 085a 9207      		cpc r25,r18
 2391 085c 20E0      		ldi r18,hlo8(1093)
 2392 085e A207      		cpc r26,r18
 2393 0860 20E0      		ldi r18,hhi8(1093)
 2394 0862 B207      		cpc r27,r18
 2395 0864 00F4      		brsh .L128
1208:stk500boot.c  **** 						LED1_LOW();
 2396               		.loc 1 1208 0
 2397 0866 2D98      		cbi 37-32,5
1209:stk500boot.c  **** 						LED2_LOW();
 2398               		.loc 1 1209 0
 2399 0868 2E98      		cbi 37-32,6
1210:stk500boot.c  **** 						LED3_HIGH();
 2400               		.loc 1 1210 0
 2401 086a 2F9A      		sbi 37-32,7
 2402               	.L128:
1187:stk500boot.c  **** 				for (int i = 0; i < SPM_PAGESIZE; i++) {
 2403               		.loc 1 1187 0
 2404 086c 0F5F      		subi r16,lo8(-(1))
 2405 086e 1F4F      		sbci r17,hi8(-(1))
 2406               	.LVL159:
 2407 0870 31E0      		ldi r19,hi8(256)
 2408 0872 0030      		cpi r16,lo8(256)
 2409 0874 1307      		cpc r17,r19
 2410 0876 01F0      		breq .+2
 2411 0878 00C0      		rjmp .L130
 2412               	.LBE71:
1211:stk500boot.c  **** 					}
1212:stk500boot.c  **** 				}
1213:stk500boot.c  **** 				flash_write(fa, Buff); /* Write it if the data is available */
 2413               		.loc 1 1213 0
 2414 087a C501      		movw r24,r10
 2415 087c B401      		movw r22,r8
 2416 087e 40E0      		ldi r20,lo8(Buff)
 2417 0880 50E0      		ldi r21,hi8(Buff)
 2418 0882 0E94 0000 		call flash_write
1182:stk500boot.c  **** 			for (fa = 0; fa < 0x3E000; fa += SPM_PAGESIZE) { /* Update all application pages */
 2419               		.loc 1 1182 0
 2420 0886 80E0      		ldi r24,lo8(256)
 2421 0888 91E0      		ldi r25,hi8(256)
 2422 088a A0E0      		ldi r26,hlo8(256)
 2423 088c B0E0      		ldi r27,hhi8(256)
 2424 088e 880E      		add r8,r24
 2425 0890 991E      		adc r9,r25
 2426 0892 AA1E      		adc r10,r26
 2427 0894 BB1E      		adc r11,r27
 2428               	.LVL160:
 2429 0896 90E0      		ldi r25,lo8(253952)
 2430 0898 8916      		cp r8,r25
 2431 089a 90EE      		ldi r25,hi8(253952)
 2432 089c 9906      		cpc r9,r25
 2433 089e 93E0      		ldi r25,hlo8(253952)
 2434 08a0 A906      		cpc r10,r25
 2435 08a2 90E0      		ldi r25,hhi8(253952)
 2436 08a4 B906      		cpc r11,r25
 2437 08a6 01F0      		breq .+2
 2438 08a8 00C0      		rjmp .L131
1214:stk500boot.c  **** 			}
1215:stk500boot.c  **** 			sendchar('d');
 2439               		.loc 1 1215 0
 2440 08aa 84E6      		ldi r24,lo8(100)
 2441 08ac 0E94 0000 		call sendchar
1216:stk500boot.c  **** 			sendchar(0x0d);
 2442               		.loc 1 1216 0
 2443 08b0 8DE0      		ldi r24,lo8(13)
 2444 08b2 0E94 0000 		call sendchar
1217:stk500boot.c  **** 			sendchar(0x0a);
 2445               		.loc 1 1217 0
 2446 08b6 8AE0      		ldi r24,lo8(10)
 2447 08b8 0E94 0000 		call sendchar
1218:stk500boot.c  **** 			check = 0;
 2448               		.loc 1 1218 0
 2449 08bc 1092 0000 		sts check,__zero_reg__
1219:stk500boot.c  **** 			eeprom_write_byte(4095, 0x00);
 2450               		.loc 1 1219 0
 2451 08c0 8FEF      		ldi r24,lo8(4095)
 2452 08c2 9FE0      		ldi r25,hi8(4095)
 2453 08c4 60E0      		ldi r22,lo8(0)
 2454 08c6 0E94 0000 		call __eewr_byte_m2560
 2455               	.LVL161:
 2456               	.L125:
 2457               	.LBE69:
1220:stk500boot.c  **** 		}
1221:stk500boot.c  **** 
1222:stk500boot.c  **** 		boot_state = 0;
1223:stk500boot.c  **** 	}
1224:stk500boot.c  **** 
1225:stk500boot.c  **** 	asm volatile ("nop");
 2458               		.loc 1 1225 0
 2459               	/* #APP */
 2460               	 ;  1225 "stk500boot.c" 1
 2461 08ca 0000      		nop
 2462               	 ;  0 "" 2
1226:stk500boot.c  **** 	// wait until port has changed
1227:stk500boot.c  **** 
1228:stk500boot.c  **** //    // SDCARD BOOTLOADER
1229:stk500boot.c  **** //
1230:stk500boot.c  **** //    WORD fa;	/* Flash address */
1231:stk500boot.c  **** //    WORD br;	/* Bytes read */
1232:stk500boot.c  **** //	uint8_t i = 0;
1233:stk500boot.c  **** //
1234:stk500boot.c  **** //
1235:stk500boot.c  **** //	pf_mount(&Fatfs);	/* Initialize file system */
1236:stk500boot.c  **** //
1237:stk500boot.c  **** //
1238:stk500boot.c  **** //	if (pf_open("app.bin") == FR_OK) {	/* Open application file */
1239:stk500boot.c  **** //        PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1240:stk500boot.c  **** //		
1241:stk500boot.c  **** //        for (fa = 0; fa < 0x1000; fa += SPM_PAGESIZE) {	/* Update all application pages */
1242:stk500boot.c  **** //            memset(Buff, 0xFF, SPM_PAGESIZE);		/* Clear buffer */
1243:stk500boot.c  **** //            pf_read(Buff, SPM_PAGESIZE, &br);		/* Load a page data */
1244:stk500boot.c  **** //            
1245:stk500boot.c  **** //			if (br) {					/* Bytes Read > 0? */
1246:stk500boot.c  **** //            	for (i = br; i < SPM_PAGESIZE; i++)     /* Pad the remaining last page with 0xFF so 
1247:stk500boot.c  **** //                    Buff[i] = 0xFF;
1248:stk500boot.c  **** //                if (pagecmp(fa, Buff)) {
1249:stk500boot.c  **** //                    flash_erase(fa);		/* Erase a page */
1250:stk500boot.c  **** //                    flash_write(fa, Buff);		/* Write it if the data is available */
1251:stk500boot.c  **** //                }
1252:stk500boot.c  **** //            }
1253:stk500boot.c  **** //    	}
1254:stk500boot.c  **** //        PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1255:stk500boot.c  **** //        
1256:stk500boot.c  **** //    }
1257:stk500boot.c  **** //    
1258:stk500boot.c  **** //    if (pgm_read_word(0) != 0xFFFF)		/* Start application if exist */
1259:stk500boot.c  **** //        asm volatile("jmp 0000");
1260:stk500boot.c  **** //    // SD CARD BOOTLOADER
1261:stk500boot.c  **** 
1262:stk500boot.c  **** 	/*
1263:stk500boot.c  **** 	 * Now leave bootloader
1264:stk500boot.c  **** 	 */
1265:stk500boot.c  **** 
1266:stk500boot.c  **** 	UART_STATUS_REG &= 0xfd;
 2463               		.loc 1 1266 0
 2464               	/* #NOAPP */
 2465 08cc 8091 C000 		lds r24,192
 2466 08d0 8D7F      		andi r24,lo8(-3)
 2467 08d2 8093 C000 		sts 192,r24
1267:stk500boot.c  **** 	boot_rww_enable(); // enable application section
 2468               		.loc 1 1267 0
 2469 08d6 81E1      		ldi r24,lo8(17)
 2470               	/* #APP */
 2471               	 ;  1267 "stk500boot.c" 1
 2472 08d8 8093 5700 		sts 87, r24
 2473 08dc E895      		spm
 2474               		
 2475               	 ;  0 "" 2
1268:stk500boot.c  **** 
1269:stk500boot.c  **** 	asm volatile(
 2476               		.loc 1 1269 0
 2477               	 ;  1269 "stk500boot.c" 1
 2478 08de EE27      		clr	r30		
 2479 08e0 FF27      		clr	r31		
 2480 08e2 0994      		ijmp	
 2481               		
 2482               	 ;  0 "" 2
 2483               	/* #NOAPP */
 2484               	.L132:
 2485 08e4 00C0      		rjmp .L132
 2486               	.LVL162:
 2487               	.L181:
 794:stk500boot.c  **** 						checksum = MESSAGE_START ^ 0;
 2488               		.loc 1 794 0
 2489 08e6 3BE1      		ldi r19,lo8(27)
 2490 08e8 E32E      		mov r14,r19
 2491               	.LVL163:
 793:stk500boot.c  **** 						msgParseState = ST_GET_SEQ_NUM;
 2492               		.loc 1 793 0
 2493 08ea 21E0      		ldi r18,lo8(1)
 2494 08ec 00C0      		rjmp .L83
 2495               	.LVL164:
 2496               	.L140:
 835:stk500boot.c  **** 						msgParseState = ST_START;
 2497               		.loc 1 835 0
 2498 08ee 20E0      		ldi r18,lo8(0)
 2499 08f0 00C0      		rjmp .L83
 2500               	.LVL165:
 2501               	.L182:
 843:stk500boot.c  **** 						msgParseState = ST_GET_CHECK;
 2502               		.loc 1 843 0
 2503 08f2 26E0      		ldi r18,lo8(6)
 2504               	.LVL166:
 2505 08f4 00C0      		rjmp .L83
 2506               		.cfi_endproc
 2507               	.LFE21:
 2509               		.text
 2510               	.global	PrintFromPROGMEM
 2512               	PrintFromPROGMEM:
 2513               	.LFB22:
1270:stk500boot.c  **** 			"clr	r30		\n\t"
1271:stk500boot.c  **** 			"clr	r31		\n\t"
1272:stk500boot.c  **** 			"ijmp	\n\t"
1273:stk500boot.c  **** 	);
1274:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1275:stk500boot.c  **** //					"push r1" "\n\t"
1276:stk500boot.c  **** //					"ret"	 "\n\t"
1277:stk500boot.c  **** //					::);
1278:stk500boot.c  **** 
1279:stk500boot.c  **** 	/*
1280:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1281:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1282:stk500boot.c  **** 	 * understand this
1283:stk500boot.c  **** 	 */
1284:stk500boot.c  **** 	for (;;)
1285:stk500boot.c  **** 		;
1286:stk500boot.c  **** }
1287:stk500boot.c  **** 
1288:stk500boot.c  **** /*
1289:stk500boot.c  ****  base address = f800
1290:stk500boot.c  **** 
1291:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1292:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1293:stk500boot.c  ****  avrdude: safemode: hfuse reads as DA
1294:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1295:stk500boot.c  ****  avrdude>
1296:stk500boot.c  **** 
1297:stk500boot.c  **** 
1298:stk500boot.c  ****  base address = f000
1299:stk500boot.c  ****  avrdude: Device signature = 0x1e9703
1300:stk500boot.c  ****  avrdude: safemode: lfuse reads as FF
1301:stk500boot.c  ****  avrdude: safemode: hfuse reads as D8
1302:stk500boot.c  ****  avrdude: safemode: efuse reads as F5
1303:stk500boot.c  ****  avrdude>
1304:stk500boot.c  ****  */
1305:stk500boot.c  **** 
1306:stk500boot.c  **** //************************************************************************
1307:stk500boot.c  **** #ifdef ENABLE_MONITOR
1308:stk500boot.c  **** #include	<math.h>
1309:stk500boot.c  **** 
1310:stk500boot.c  **** unsigned long gRamIndex;
1311:stk500boot.c  **** unsigned long gFlashIndex;
1312:stk500boot.c  **** unsigned long gEepromIndex;
1313:stk500boot.c  **** 
1314:stk500boot.c  **** #define	true	1
1315:stk500boot.c  **** #define	false	0
1316:stk500boot.c  **** 
1317:stk500boot.c  **** #include	"avr_cpunames.h"
1318:stk500boot.c  **** 
1319:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1320:stk500boot.c  **** #error cpu name not defined
1321:stk500boot.c  **** #endif
1322:stk500boot.c  **** 
1323:stk500boot.c  **** #ifdef _VECTORS_SIZE
1324:stk500boot.c  **** #define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1325:stk500boot.c  **** #else
1326:stk500boot.c  **** #define	kInterruptVectorCount 23
1327:stk500boot.c  **** #endif
1328:stk500boot.c  **** 
1329:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt);
1330:stk500boot.c  **** 
1331:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1332:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = _AVR_CPU_NAME_;
1333:stk500boot.c  **** #else
1334:stk500boot.c  **** const char gTextMsg_CPU_Name[] PROGMEM = "UNKNOWN";
1335:stk500boot.c  **** #endif
1336:stk500boot.c  **** 
1337:stk500boot.c  **** //************************************************************************
1338:stk500boot.c  **** void PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1339:stk500boot.c  **** {
 2514               		.loc 1 1339 0
 2515               		.cfi_startproc
 2516               	.LVL167:
 2517 02c4 CF93      		push r28
 2518               	.LCFI16:
 2519               		.cfi_def_cfa_offset 4
 2520               		.cfi_offset 28, -3
 2521 02c6 DF93      		push r29
 2522               	.LCFI17:
 2523               		.cfi_def_cfa_offset 5
 2524               		.cfi_offset 29, -4
 2525               	/* prologue: function */
 2526               	/* frame size = 0 */
 2527               	/* stack size = 2 */
 2528               	.L__stack_usage = 2
1340:stk500boot.c  **** 	char theChar;
1341:stk500boot.c  **** 
1342:stk500boot.c  **** 	dataPtr += offset;
 2529               		.loc 1 1342 0
 2530 02c8 EC01      		movw r28,r24
 2531 02ca C60F      		add r28,r22
 2532 02cc D11D      		adc r29,__zero_reg__
 2533               	.LVL168:
 2534               	.L186:
 2535               	.LBB72:
1343:stk500boot.c  **** 
1344:stk500boot.c  **** 	do {
1345:stk500boot.c  **** #if (FLASHEND > 0x10000)
1346:stk500boot.c  **** 		theChar = pgm_read_byte_far((uint16_t)dataPtr++);
 2536               		.loc 1 1346 0
 2537 02ce CE01      		movw r24,r28
 2538 02d0 A0E0      		ldi r26,lo8(0)
 2539 02d2 B0E0      		ldi r27,hi8(0)
 2540               	.LVL169:
 2541 02d4 2196      		adiw r28,1
 2542               	.LVL170:
 2543               	/* #APP */
 2544               	 ;  1346 "stk500boot.c" 1
 2545 02d6 ABBF      		out 59, r26
 2546 02d8 FC01      		movw r30, r24
 2547 02da 8791      		elpm r24, Z+
 2548               		
 2549               	 ;  0 "" 2
 2550               	.LVL171:
 2551               	/* #NOAPP */
 2552               	.LBE72:
1347:stk500boot.c  **** #else
1348:stk500boot.c  **** 		theChar = pgm_read_byte_near((uint16_t)dataPtr++);
1349:stk500boot.c  **** #endif
1350:stk500boot.c  **** 		if (theChar != 0)
 2553               		.loc 1 1350 0
 2554 02dc 8823      		tst r24
 2555 02de 01F0      		breq .L184
1351:stk500boot.c  **** 		{
1352:stk500boot.c  **** 			sendchar(theChar);
 2556               		.loc 1 1352 0
 2557 02e0 0E94 0000 		call sendchar
 2558               	.LVL172:
 2559 02e4 00C0      		rjmp .L186
 2560               	.LVL173:
 2561               	.L184:
 2562               	/* epilogue start */
1353:stk500boot.c  **** 		}
1354:stk500boot.c  **** 	}while (theChar != 0);
1355:stk500boot.c  **** }
 2563               		.loc 1 1355 0
 2564 02e6 DF91      		pop r29
 2565 02e8 CF91      		pop r28
 2566               	.LVL174:
 2567 02ea 0895      		ret
 2568               		.cfi_endproc
 2569               	.LFE22:
 2571               	.global	PrintNewLine
 2573               	PrintNewLine:
 2574               	.LFB23:
1356:stk500boot.c  **** 
1357:stk500boot.c  **** //************************************************************************
1358:stk500boot.c  **** void PrintNewLine(void)
1359:stk500boot.c  **** {
 2575               		.loc 1 1359 0
 2576               		.cfi_startproc
 2577               	/* prologue: function */
 2578               	/* frame size = 0 */
 2579               	/* stack size = 0 */
 2580               	.L__stack_usage = 0
1360:stk500boot.c  **** 	sendchar(0x0d);
 2581               		.loc 1 1360 0
 2582 02ec 8DE0      		ldi r24,lo8(13)
 2583 02ee 0E94 0000 		call sendchar
1361:stk500boot.c  **** 	sendchar(0x0a);
 2584               		.loc 1 1361 0
 2585 02f2 8AE0      		ldi r24,lo8(10)
 2586 02f4 0E94 0000 		call sendchar
 2587               	/* epilogue start */
1362:stk500boot.c  **** }
 2588               		.loc 1 1362 0
 2589 02f8 0895      		ret
 2590               		.cfi_endproc
 2591               	.LFE23:
 2593               	.global	PrintFromPROGMEMln
 2595               	PrintFromPROGMEMln:
 2596               	.LFB24:
1363:stk500boot.c  **** 
1364:stk500boot.c  **** //************************************************************************
1365:stk500boot.c  **** void PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1366:stk500boot.c  **** {
 2597               		.loc 1 1366 0
 2598               		.cfi_startproc
 2599               	.LVL175:
 2600               	/* prologue: function */
 2601               	/* frame size = 0 */
 2602               	/* stack size = 0 */
 2603               	.L__stack_usage = 0
1367:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 2604               		.loc 1 1367 0
 2605 02fa 0E94 0000 		call PrintFromPROGMEM
 2606               	.LVL176:
1368:stk500boot.c  **** 
1369:stk500boot.c  **** 	PrintNewLine();
 2607               		.loc 1 1369 0
 2608 02fe 0E94 0000 		call PrintNewLine
 2609               	/* epilogue start */
1370:stk500boot.c  **** }
 2610               		.loc 1 1370 0
 2611 0302 0895      		ret
 2612               		.cfi_endproc
 2613               	.LFE24:
 2615               	.global	PrintString
 2617               	PrintString:
 2618               	.LFB25:
1371:stk500boot.c  **** 
1372:stk500boot.c  **** //************************************************************************
1373:stk500boot.c  **** void PrintString(char *textString)
1374:stk500boot.c  **** {
 2619               		.loc 1 1374 0
 2620               		.cfi_startproc
 2621               	.LVL177:
 2622 0304 CF93      		push r28
 2623               	.LCFI18:
 2624               		.cfi_def_cfa_offset 4
 2625               		.cfi_offset 28, -3
 2626 0306 DF93      		push r29
 2627               	.LCFI19:
 2628               		.cfi_def_cfa_offset 5
 2629               		.cfi_offset 29, -4
 2630               	/* prologue: function */
 2631               	/* frame size = 0 */
 2632               	/* stack size = 2 */
 2633               	.L__stack_usage = 2
 2634               	.LVL178:
 2635               		.loc 1 1374 0
 2636 0308 EC01      		movw r28,r24
 2637               	.LVL179:
 2638               	.L191:
1375:stk500boot.c  **** 	char theChar;
1376:stk500boot.c  **** 	int ii;
1377:stk500boot.c  **** 
1378:stk500boot.c  **** 	theChar = 1;
1379:stk500boot.c  **** 	ii = 0;
1380:stk500boot.c  **** 	while (theChar != 0)
1381:stk500boot.c  **** 	{
1382:stk500boot.c  **** 		theChar = textString[ii];
 2639               		.loc 1 1382 0
 2640 030a 8991      		ld r24,Y+
 2641               	.LVL180:
1383:stk500boot.c  **** 		if (theChar != 0)
 2642               		.loc 1 1383 0
 2643 030c 8823      		tst r24
 2644 030e 01F0      		breq .L189
1384:stk500boot.c  **** 		{
1385:stk500boot.c  **** 			sendchar(theChar);
 2645               		.loc 1 1385 0
 2646 0310 0E94 0000 		call sendchar
 2647               	.LVL181:
 2648 0314 00C0      		rjmp .L191
 2649               	.LVL182:
 2650               	.L189:
 2651               	/* epilogue start */
1386:stk500boot.c  **** 		}
1387:stk500boot.c  **** 		ii++;
1388:stk500boot.c  **** 	}
1389:stk500boot.c  **** }
 2652               		.loc 1 1389 0
 2653 0316 DF91      		pop r29
 2654 0318 CF91      		pop r28
 2655 031a 0895      		ret
 2656               		.cfi_endproc
 2657               	.LFE25:
 2659               	.global	PrintHexByte
 2661               	PrintHexByte:
 2662               	.LFB26:
1390:stk500boot.c  **** 
1391:stk500boot.c  **** //************************************************************************
1392:stk500boot.c  **** void PrintHexByte(unsigned char theByte)
1393:stk500boot.c  **** {
 2663               		.loc 1 1393 0
 2664               		.cfi_startproc
 2665               	.LVL183:
 2666 031c CF93      		push r28
 2667               	.LCFI20:
 2668               		.cfi_def_cfa_offset 4
 2669               		.cfi_offset 28, -3
 2670               	/* prologue: function */
 2671               	/* frame size = 0 */
 2672               	/* stack size = 1 */
 2673               	.L__stack_usage = 1
 2674 031e C82F      		mov r28,r24
1394:stk500boot.c  **** 	char theChar;
1395:stk500boot.c  **** 
1396:stk500boot.c  **** 	theChar = 0x30 + ((theByte >> 4) & 0x0f);
 2675               		.loc 1 1396 0
 2676 0320 982F      		mov r25,r24
 2677 0322 9295      		swap r25
 2678 0324 9F70      		andi r25,lo8(15)
 2679 0326 892F      		mov r24,r25
 2680               	.LVL184:
 2681 0328 805D      		subi r24,lo8(-(48))
 2682               	.LVL185:
1397:stk500boot.c  **** 	if (theChar > 0x39)
 2683               		.loc 1 1397 0
 2684 032a 8A33      		cpi r24,lo8(58)
 2685 032c 00F0      		brlo .L193
1398:stk500boot.c  **** 	{
1399:stk500boot.c  **** 		theChar += 7;
 2686               		.loc 1 1399 0
 2687 032e 895F      		subi r24,lo8(-(7))
 2688               	.LVL186:
 2689               	.L193:
1400:stk500boot.c  **** 	}
1401:stk500boot.c  **** 	sendchar(theChar );
 2690               		.loc 1 1401 0
 2691 0330 0E94 0000 		call sendchar
 2692               	.LVL187:
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 	theChar = 0x30 + (theByte & 0x0f);
 2693               		.loc 1 1403 0
 2694 0334 CF70      		andi r28,lo8(15)
 2695               	.LVL188:
 2696 0336 8C2F      		mov r24,r28
 2697 0338 805D      		subi r24,lo8(-(48))
 2698               	.LVL189:
1404:stk500boot.c  **** 	if (theChar > 0x39)
 2699               		.loc 1 1404 0
 2700 033a 8A33      		cpi r24,lo8(58)
 2701 033c 00F0      		brlo .L194
1405:stk500boot.c  **** 	{
1406:stk500boot.c  **** 		theChar += 7;
 2702               		.loc 1 1406 0
 2703 033e 895F      		subi r24,lo8(-(7))
 2704               	.LVL190:
 2705               	.L194:
1407:stk500boot.c  **** 	}
1408:stk500boot.c  **** 	sendchar(theChar );
 2706               		.loc 1 1408 0
 2707 0340 0E94 0000 		call sendchar
 2708               	.LVL191:
 2709               	/* epilogue start */
1409:stk500boot.c  **** }
 2710               		.loc 1 1409 0
 2711 0344 CF91      		pop r28
 2712 0346 0895      		ret
 2713               		.cfi_endproc
 2714               	.LFE26:
 2716               	.global	PrintDecInt
 2718               	PrintDecInt:
 2719               	.LFB27:
1410:stk500boot.c  **** 
1411:stk500boot.c  **** //************************************************************************
1412:stk500boot.c  **** void PrintDecInt(int theNumber, int digitCnt)
1413:stk500boot.c  **** {
 2720               		.loc 1 1413 0
 2721               		.cfi_startproc
 2722               	.LVL192:
 2723 0348 0F93      		push r16
 2724               	.LCFI21:
 2725               		.cfi_def_cfa_offset 4
 2726               		.cfi_offset 16, -3
 2727 034a 1F93      		push r17
 2728               	.LCFI22:
 2729               		.cfi_def_cfa_offset 5
 2730               		.cfi_offset 17, -4
 2731 034c CF93      		push r28
 2732               	.LCFI23:
 2733               		.cfi_def_cfa_offset 6
 2734               		.cfi_offset 28, -5
 2735 034e DF93      		push r29
 2736               	.LCFI24:
 2737               		.cfi_def_cfa_offset 7
 2738               		.cfi_offset 29, -6
 2739               	/* prologue: function */
 2740               	/* frame size = 0 */
 2741               	/* stack size = 4 */
 2742               	.L__stack_usage = 4
 2743 0350 EC01      		movw r28,r24
 2744 0352 8B01      		movw r16,r22
 2745               	.LVL193:
1414:stk500boot.c  **** 	int theChar;
1415:stk500boot.c  **** 	int myNumber;
1416:stk500boot.c  **** 
1417:stk500boot.c  **** 	myNumber = theNumber;
1418:stk500boot.c  **** 
1419:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 2746               		.loc 1 1419 0
 2747 0354 8536      		cpi r24,101
 2748 0356 9105      		cpc r25,__zero_reg__
 2749 0358 04F4      		brge .L196
 2750               	.LVL194:
 2751               		.loc 1 1419 0 is_stmt 0 discriminator 1
 2752 035a 6330      		cpi r22,3
 2753 035c 7105      		cpc r23,__zero_reg__
 2754 035e 04F0      		brlt .L197
 2755               	.LVL195:
 2756               	.L196:
1420:stk500boot.c  **** 	{
1421:stk500boot.c  **** 		theChar = 0x30 + myNumber / 100;
 2757               		.loc 1 1421 0 is_stmt 1
 2758 0360 CE01      		movw r24,r28
 2759               	.LVL196:
 2760 0362 64E6      		ldi r22,lo8(100)
 2761 0364 70E0      		ldi r23,hi8(100)
 2762 0366 0E94 0000 		call __divmodhi4
1422:stk500boot.c  **** 		sendchar(theChar );
 2763               		.loc 1 1422 0
 2764 036a 862F      		mov r24,r22
 2765 036c 805D      		subi r24,lo8(-(48))
 2766 036e 0E94 0000 		call sendchar
 2767               	.LVL197:
 2768               	.L197:
1423:stk500boot.c  **** 	}
1424:stk500boot.c  **** 
1425:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 2769               		.loc 1 1425 0
 2770 0372 CB30      		cpi r28,11
 2771 0374 D105      		cpc r29,__zero_reg__
 2772 0376 04F4      		brge .L198
 2773               		.loc 1 1425 0 is_stmt 0 discriminator 1
 2774 0378 0230      		cpi r16,2
 2775 037a 1105      		cpc r17,__zero_reg__
 2776 037c 04F0      		brlt .L199
 2777               	.L198:
 2778               	.LVL198:
1426:stk500boot.c  **** 	{
1427:stk500boot.c  **** 		theChar = 0x30 + ((myNumber % 100) / 10 );
 2779               		.loc 1 1427 0 is_stmt 1
 2780 037e CE01      		movw r24,r28
 2781 0380 64E6      		ldi r22,lo8(100)
 2782 0382 70E0      		ldi r23,hi8(100)
 2783 0384 0E94 0000 		call __divmodhi4
 2784 0388 6AE0      		ldi r22,lo8(10)
 2785 038a 70E0      		ldi r23,hi8(10)
 2786 038c 0E94 0000 		call __divmodhi4
1428:stk500boot.c  **** 		sendchar(theChar );
 2787               		.loc 1 1428 0
 2788 0390 862F      		mov r24,r22
 2789 0392 805D      		subi r24,lo8(-(48))
 2790 0394 0E94 0000 		call sendchar
 2791               	.LVL199:
 2792               	.L199:
1429:stk500boot.c  **** 	}
1430:stk500boot.c  **** 	theChar = 0x30 + (myNumber % 10);
 2793               		.loc 1 1430 0
 2794 0398 CE01      		movw r24,r28
 2795 039a 6AE0      		ldi r22,lo8(10)
 2796 039c 70E0      		ldi r23,hi8(10)
 2797 039e 0E94 0000 		call __divmodhi4
1431:stk500boot.c  **** 	sendchar(theChar );
 2798               		.loc 1 1431 0
 2799 03a2 805D      		subi r24,lo8(-(48))
 2800 03a4 0E94 0000 		call sendchar
 2801               	/* epilogue start */
1432:stk500boot.c  **** }
 2802               		.loc 1 1432 0
 2803 03a8 DF91      		pop r29
 2804 03aa CF91      		pop r28
 2805               	.LVL200:
 2806 03ac 1F91      		pop r17
 2807 03ae 0F91      		pop r16
 2808               	.LVL201:
 2809 03b0 0895      		ret
 2810               		.cfi_endproc
 2811               	.LFE27:
 2813               	.global	gTextMsg_CPU_Name
 2814               		.section	.progmem.data,"a",@progbits
 2817               	gTextMsg_CPU_Name:
 2818 0000 4154 6D65 		.string	"ATmega2560"
 2818      6761 3235 
 2818      3630 00
 2819               		.comm gEepromIndex,4,1
 2820               		.comm gFlashIndex,4,1
 2821               		.comm gRamIndex,4,1
 2822               	.global	check
 2823               		.data
 2826               	check:
 2827 0000 01        		.byte	1
 2828               	.global	app_start
 2829               	.global	app_start
 2830               		.section .bss
 2833               	app_start:
 2834 0000 0000      		.skip 2,0
 2835               		.comm Buff,256,1
 2836               		.data
 2839               	CSWTCH.16:
 2840 0001 0F        		.byte	15
 2841 0002 02        		.byte	2
 2842 0003 0A        		.byte	10
 2843               		.text
 2844               	.Letext0:
 2845               		.file 3 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 2846               		.file 4 "integer.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stk500boot.c
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2      *ABS*:0000003f __SREG__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:3      *ABS*:0000003e __SP_H__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:4      *ABS*:0000003d __SP_L__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:5      *ABS*:00000034 __CCP__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:14     .text:00000000 sendchar
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:44     .text:00000018 transfer
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:71     .text:00000024 setDataMode
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:93     .text:0000002e setBitOrder
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:124    .text:00000040 setClockDivider
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:157    .text:0000005c readStatus
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:184    .text:0000006e busy
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:203    .text:00000076 command
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:238    .text:0000008e spiReadReg
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:307    .init9:00000000 __jumpMain
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:318    *ABS*:000021ff __stack
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:733    .text.startup:00000000 main
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:357    .text:000000d4 delay_ms
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:401    .text:000000f2 dec_hex
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2833   .bss:00000000 app_start
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2839   .data:00000001 CSWTCH.16
                            *COM*:00000100 Buff
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2826   .data:00000000 check
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2512   .text:000002c4 PrintFromPROGMEM
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2573   .text:000002ec PrintNewLine
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2595   .text:000002fa PrintFromPROGMEMln
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2617   .text:00000304 PrintString
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2661   .text:0000031c PrintHexByte
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2718   .text:00000348 PrintDecInt
/var/folders/v_/frz4s8vn63g2ztygqj155f6m0000gn/T//ccdMM75X.s:2817   .progmem.data:00000000 gTextMsg_CPU_Name
                            *COM*:00000004 gEepromIndex
                            *COM*:00000004 gFlashIndex
                            *COM*:00000004 gRamIndex

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__eewr_byte_m2560
__eerd_byte_m2560
flash_erase
memset
__divmodsi4
flash_write
__divmodhi4
